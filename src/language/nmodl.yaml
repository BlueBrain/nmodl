######################### NMODL Abstract Language Definition ##############################
#
# PURPOSE
# =======
#
# Lot of information about language constructs is necessary at various stages
# like AST definitions, visitors implementation, source-to-source transformations
# etc. In case of small changes in grammar or AST definition, especially
# during early development stage, we have to re-write considerable part of the code.
# The idea of "abstract" language definition is to define framework that can automatically
# generate part of this "mechanical" code. This approach has been used in some open source
# projects (e.g. compiler design courses, TableGen format in LLVM).
#
# During first prototyping phase we defined simple text rules inspired by compiler course
# assignment available at jazariethach/project6_CS160.git (no longer available on github).
#
# The basic format of the every construct specification was:
#
#       BaseType:ChildType => MemberType<member_name>
#
# Here "ChildType" is a new AST class that we are defining. "ParentType" is the base class,
# "MemberType" is the type of member variable with variable name "member_name". The name is
# specified in the angle braces "< >". This will generate C++ class definition like :
#
#       class ChildType : public BaseType {
#         private:
#           MemberType member_name;
#       };
#
# This specification format was sufficient initial AST design but as we started implementing
# more features and compiler passes, we need to add more information to language definition.
# For example, we need to make certain members vector, some are optional, some need
# specific method (get/set) etc. In the future we may need to make certain members private.
# Above text definition is limiting if we have to accomodate future enhancements.
#
# To overcome above limitation, we are moving to YAML definition format. This allows easy
# extension to language construct. For example, new properties could be easily added to
# exisiting specification.
#
#
# IMPORTANT NOTE
# ==============
#
#   Below documentation is from old text specification (i.e. nmod.def). We converted
#   old text specification to YAML format which we will describe at the end. We should
#   convert all below documentation/notes for YAML format. For now, keeping old documentation
#   as it has valuable information about how/why specific types were choose for AST.
#
#
# TEXT BASED RULE SPECIFICATION (OLD, SKIP UP TO YAML SECTION)
# ============================================================
#
# FORMT :
# =====
#
# Here is brief information about the format of rules specification itself:
#
# To define an abstract class "ChildType", we use below specification:
#
#       BaseType:ChildType =>
#
# The member variable could be an optional or vector type. This is captured by symbol ? and *
#
#       BaseType:ChildType => Member1Type<mname1> ?Member2Type<mname2> *Member3Type<mname3>
#
# In above specification the ChildType class has three member variables:
#
#       mname1 : is a member variable of type Member1Type
#       mname2 : is an optional variable i.e. pointer of type Member2Type
#       mname3 : is a vector variable of type Member3Type
#
# Above specification will generate class definition lik :
#
#       class ChildType: public BaseType {
#         private:
#           Member1Type mname1;
#           Member2Type* mname2;
#           std::vector<Member3Type> mname3;
#       };
#
# NOTE : Many member variables need to hold subclasses (due to various optimization).
# Hence all member variables are now of type pointer.
#
# Some parser actions add new node while parsing the input. This requires "addMemberType"
# method. This is specified using '+' decorator for that member as:
#
#       BaseType:ChildType => *MemberType<+name>
#
# In order to print AST back to NMODL format, we need a way to map every AST node
# back to NMODL. In order to achieve this we introduced node "taging". Every node
# can have prefix, printing name, separator and suffix. For example, if we have
# following specification:
#
#       BaseType:ChildType("MYNAME") =>
#
# When we will print ChildType class, it will be written as "MYNAME" to NMODL file.
# This will be more clear when we will look the examples.
#
# The member variable can have prefix, suffix and separator specification. The
# simple syntax is ("prefix:suffix"). If the member is of type vector, then it
# could have separator specification as ("prefix:suffix:separator). The separator
# is used usually for vector data types. Note that the member could have value as
# well as prefix, suffix and separator.
#
# These rules are best illustrated by following example:
#
#       BaseType:ChildType => Member1Type<name1>(":=") Member2Type<name2>(" USEION :") *Member3Type<name2>("::,")
#
# Above specification will be translated as:
#
#       <name1>(":=")     => prefix is empty, followed by value of name1, followed by suffix "="
#       <name2>(" USEION :") => prefix is " USEION " followed by value of name2
#       <name3>("::,")    => prefix is empty, every variable (except last) of name3 will be
#                            separated by comma, no suffix
#
# Consider function definition which has arguments as vector. Typically we will define '(' as prfix
# and ')' as suffix for the argument node. But if there are no arguments to function then we have to
# still print '()' i.e. prefix and suffix must be printed. This is not desirable in all cases but few.
# And not only for function call arguments but for reaction statements etc.
# To enforce this rule we prepend '!' to the prefix or suffix. For example:
#
#       Expression:FunctionCall => Name<name> *Expression<arguments>("!(:!):,")
#
# This was so naive! But we have removed with YAML specification!
#
# REFERENCES:
#
# 1] Writing Your Own Toy Compiler Using Flex, Bison and LLVM
#       http://gnuu.org/2009/09/18/writing-your-own-toy-compiler/
#
# 2] Use of abstract language: https://github.com/jazariethach/project6_CS160.git
#       Github repository is not available anymore. You cab look at
#       /Users/kumbhar/workarena/repos/personal/git_compiler_projects/project6_CS160
#       or bitbucket fork)
#
# Some projects [1] use AstNode as a base class for all node types. The main base class AstNode
# is defined by in python code itself and rest are derived from it.
#
# Abstract base classes for AST specification:
#
# AST:Expression =>
# AST:Statement =>
# Expression:Identifier =>
# Expression:Block =>
# Expression:Number =>
#
# Every node which can have "name" is of type String:
#
# Expression:String => std::string<value>
#
# Basic data types like int, float and double. Note that NMODL supprts macro where users
# usually define flags or integer. Hence Integer can have associated macro name:
#
# Number:Integer => int<value> ?Name<macroname>
# Number:Float => float<value>
# Number:Double => double<value>
# Number:Boolean => int<value>
#
# 'Name' and 'name' is used differently in the NMODL grammar specification. 'Name' could be
# just string whereas 'name' could be PRIME. 'Name' and 'NAME' are same in AST context:
#
# Identifier:Name => String<value>
#
# Prime has name and order. Note that the variable  name "order" is checked
# in the ast generator. It's hardcoded in node_types.py as PRIME_ORDER_VAR:
#
# Identifier:PrimeName => String<value> Integer<order>
#
# VarName could have name and Index as an Expression.
# Pair of Name, Expression could be represented by Indexname and hence Identifier
# is added as a member variable:
#
# Identifier:VarName => Identifier<name> ?Integer<at_index>("@:")
#
# Todo : Verify this is correctly working with IndexedName and being handled correctly
#
# IndexedName has Name and integer index but for 'matchname' grammar we need index as
# 'Name'. Hence 'index' is now Expression to take generic form:
#
# Identifier:IndexedName => Identifier<name> Expression<index>("[:]")
#
# Units is none or single Unit:
#
# Expression:Unit => String<name>("(:)")
#
# UNITON and UNITOFF statements are represented by TRUE or FALSE. UnitStateType
# is enum to represent this state:
#
# Statement:UnitState => UnitStateType<value>
#
# Unit definition has double value and unit name:
#
# Expression:DoubleUnit => Double<values> ?Unit<unit>
#
# Argument coule be name with units or 'name' that could be prime. Hence
# adding Identifier as a member variable:
#
# Identifier:Argument => Identifier<name> ?Unit<unit>
#
# Local variable:
#
# Expression:LocalVar => Identifier<name>
#
# Local statement in NMODL to represent the list of local variables:
#
# Statement:LocalListStatement("LOCAL") => *LocalVar<variables>("::,")
#
#
# Limits is the range of double value:
#
# Expression:Limits => Double<min>("<:,") Double<max>(":>")
#
# Number range variable could int or double range:
#
# Expression:NumberRange => Number<min>("<:,") Number<max>(":>")
#
# Program represents entire NMODL file or module. This could have one or more
# blocks (like INITIAL, STATE), methods and statements like include, define:
#
# Program => *Statement<+statements> *Block<+blocks>
#
# Title, Macro definition and include statement:
#
# Statement:Model("TITLE") => String<title>
# Statement:Define("DEFINE") => Name<name> Integer<value>
# Statement:Include("INCLUDE") => String<filename>
#
# Parameter block and statement within this block:
#
# Block:ParamBlock("PARAMETER") => *ParamAssign<statements>
# Statement:ParamAssign => Identifier<name> ?Number<value>("=:") ?Unit<unit> ?Limits<limit>
#
# Step block and statement within this block:
#
# Block:StepBlock("STEPPED") => *Stepped<statements>
# Statement:Stepped => Name<name> *Number<values>("=::,") Unit<unit>
#
#
# Independent block and statement within this block. Note that SWEEP is not part
# of IndependentDef but will be set from bison action:
#
# Block:IndependentBlock("INDEPENDENT") => *IndependentDef<definitions>
# Statement:IndependentDef => ?Boolean<sweep>
#                             Name<name>
#                             Number<from>(" FROM :")
#                             Number<to>(" TO :")
#                             Integer<with>(" WITH :")
#                             ?Number<opstart>(" START :")
#                             Unit<unit>
#
# Dependent block and statement within this block. The 'name' could be Name or
# PrimeName and hence using Identifier. DependentDef is also used in State
# block and hence except name everything needs to be optional:
#
# Statement:DependentDef => Identifier<name>(": ")
#                           ?Integer<index>("[:]")
#                           ?Number<from>(" FROM :")
#                           ?Number<to>(" TO :")
#                           ?Number<opstart>(" START : ")
#                           ?Unit<unit>
#                           ?Double<abstol>(" <:> ")
# Block:DependentBlock("ASSIGNED") => *DependentDef<definitions>
# Block:StateBlock("STATE") => *DependentDef<definitions>
#
# Plot declaration. PlotVar is 'name' and hence could just IndexedName or Name or prime:
# Todo : check if existing variable could be used
#
# Block:PlotBlock => PlotDeclaration<plot>
# Statement:PlotDeclaration("PLOT ") => *PlotVar<pvlist>("::,") PlotVar<name>(" VS :")
# Expression:PlotVar => Identifier<name>(" :") ?Integer<index>("[:]")
#
# Initial block:
#
# Block:InitialBlock("INITIAL") => StatementBlock<statementblock>
#
# Constructor block:
#
# Block:ConstructorBlock("CONSTRUCTOR") => StatementBlock<statementblock>
#
# Destructor block:
#
# Block:DestructorBlock("DESTRUCTOR") => StatementBlock<statementblock>
#
# Condustance staement added for CoreNeuronmoptimizations:
#
# Statement:ConductanceHint("CONDUCTANCE") => Name<conductance> ?Name<ion>(" USEION :")
#
# 1] is using ExpressionStatement class which holds Expression and used for may blocks in bison grammar :
#
# Statement:ExpressionStatement => Expression<expression>
#
# Protect statement:
#
# Statement:ProtectStatement("PROTECT") => Expression<expression>
#
# List of statements enclosed by opening and closing curly braces.
# Todo: One of the production of ostmt has stmtlist and check how to handle this:
#
# Block:StatementBlock => *Statement<statements>
#
# To translate AST back to NMODL, we need method to print operators and hence adding classes
# for binary operators:
#
# Expression:BinaryOperator => BinaryOp<value>
# Expression:UnaryOperator => UnaryOp<value>
# Expression:ReactionOperator => ReactionOp<value>
#
# Binary or Uniary expressions:
#
# Expression:BinaryExpression => Expression<lhs> BinaryOperator<op> Expression<rhs>
# Expression:UnaryExpression => UnaryOperator<op> Expression<expression>
#
# After reading all bison productions it is clear that two basic classes derived from Expression
# are needed : LinEquation and NonLinEquation:
# Todo : add more NMODL tests for validation
#
# Expression:NonLinEquation("~") => Expression<lhs>(":=") Expression<rhs>
# Expression:LinEquation("~") => Expression<leftlinexpr>(":=") Expression<linexpr>
#
# Function call (must be expression because it could be called in expression definition):
#
# Expression:FunctionCall => Name<name> *Expression<arguments>("!(:!):,")
#
# From statement:
#
# Statement:FromStatement("FROM") => Name<name>(" : ")
#                                    Expression<from>("=:")
#                                    Expression<to>(" TO :")
#                                    ?Expression<opinc>(" BY :")
#                                    StatementBlock<statementblock>
#
# Forall statement:
#
# Statement:ForAllStatement("FORALL") => Name<name>(" : ") StatementBlock<statementblock>
#
# While statement:
#
# Statement:WhileStatement("WHILE") => Expression<condition>("(:)") StatementBlock<statementblock>
#
# If statement:
#
# Statement:IfStatement("IF") => Expression<condition>("(:)")
#                                StatementBlock<statementblock>
#                                *ElseIfStatement<elseifs>
#                                ?ElseStatement<elses>
#
# Else if statement:
#
# Statement:ElseIfStatement("ELSE IF") => Expression<condition>("(:)") StatementBlock<statementblock>
#
# Else statement:
#
# Statement:ElseStatement("ELSE") => StatementBlock<statementblock>
#
# Derivative block:
#
# Block:DerivativeBlock("DERIVATIVE") => Name<name> StatementBlock<statementblock>
#
# Linear block:
#
# Block:LinearBlock("LINEAR") => Name<name> *Name<solvefor>(" SOLVEFOR :") StatementBlock<statementblock>
#
# Non-linear block:
#
# Block:NonLinearBlock("NONLINEAR") => Name<name> *Name<solvefor>(" SOLVEFOR :") StatementBlock<statementblock>
#
# Discrete block:
#
# Block:DiscreteBlock("DISCRETE") => Name<name> StatementBlock<statementblock>
#
# Partial block:
#
# Block:PartialBlock("PARTIAL") => Name<name> StatementBlock<statementblock>
#
# Partial equation:
#
# Statement:PartialEquation => PrimeName<prime> Name<name1> Name<name2> Name<name3>
#
# FirstLastType could be just an enum but added for convenience for printing NMODL:
#
# Expression:FirstLastTypeIndex => FirstLastType<value>
# Statement:PartialBoundary("~") => ?Name<del>(": ")
#                                   Identifier<name>
#                                   ?FirstLastTypeIndex<index>("[:]")
#                                   ?Expression<expression>("=:")
#                                   ?Name<name1>("=:*")
#                                   ?Name<del2>(":(")
#                                   ?Name<name2>(":)")
#                                   ?Name<name3>("+:")
#
# Function and Function table. Note that argument is pair of <name, unit> for function table:
#
# Block:FunctionTableBlock("FUNCTION_TABLE") => Name<name> *Argument<arguments>("!(:!):,") ?Unit<unit>
# Block:FunctionBlock("FUNCTION") => Name<name> *Argument<arguments>("!(:!):,")
#                                    ?Unit<unit> StatementBlock<statementblock>
#
# Procedure and NetReceive functions:
#
# Block:ProcedureBlock("PROCEDURE") => Name<name>
#                                      *Argument<arguments>("!(:!):,")
#                                      ?Unit<unit> StatementBlock<statementblock>
# Block:NetReceiveBlock("NET_RECEIVE") => *Argument<arguments>("!(:!):,")
#                                         StatementBlock<statementblock>
#
# Usually solve block is a single statement but 'iferr' could be also a block
# and hence it is appropriate to define it as a Block like original bison
# specification:
#
# Block:SolveBlock("SOLVE") => Name<name>
#                              ?Name<method>(" METHOD :")
#                              StatementBlock<ifsolerr>("IFERROR:")
#
# Breakpoint block:
#
# Block:BreakpointBlock("BREAKPOINT") => StatementBlock<statementblock>
#
# Terminal block:
#
# Block:TerminalBlock("TERMINAL") => StatementBlock<statementblock>
#
# Before/After block could be of any type and hence added enum for BAType:
#
# Block:BeforeBlock("BEFORE") => BABlock<block>
# Block:AfterBlock("AFTER") => BABlock<block>
# Expression:BABlockType => BAType<value>
# Block:BABlock => BABlockType<type> StatementBlock<statementblock>
#
# WatchStatement has the form : WATCH (v < vh) down, (v > vth) up
# which is actually an expression. From current tests this seems sufficient.
# Watch statement usually use macro as an integer value (which is now handled by integer) :
#
# Statement:WatchStatement("WATCH") => *Watch<+statements>("::,")
# Expression:Watch => Expression<expression> Expression<value>(" :")
#
# ForNetcon is also a function but without name or units:
#
# Block:ForNetcon("FOR_NETCONS") => *Argument<arguments>("!(:!):,") StatementBlock<statementblock>
#
# Mutex lock / unlock and and Reset statement:
#
# Statement:MutexLock("MUTEXLOCK") =>
# Statement:MutexUnlock("MUTEXUNLOCK") =>
# Statement:Reset("RESET") =>
#
# Sens statement:
# Todo: No test case added yet
#
# Statement:Sens("SENS") => *VarName<senslist>("::,")
#
# Conserve statement which is assignment expression with lhs and rhs:
#
# Statement:Conserve("CONSERVE") => Expression<react> Expression<expr>("=:")
#
# Compartment statement:
#
# Statement:Compartment("COMPARTMENT") => ?Name<name>(":,")
#                                         Expression<expression>
#                                         *Name<names>("{:}: ")
#
# Diffusion statement:
#
# Statement:LonDifuse("LONGITUDINAL_DIFFUSION") => ?Name<name>(":,")
#                                                Expression<expression>
#                                                *Name<names>("{:}: ")
# Kinetic block:
#
# Block:KineticBlock("KINETIC") => Name<name> *Name<solvefor> StatementBlock<statementblock>
#
# Reaction statement:
# Todo: check test cases and discuss with Michael
#
# Statement:ReactionStatement("~") => Expression<react1>(": ")
#                                     ReactionOperator<op>(" : ")
#                                     ?Expression<react2>(" : ")
#                                     Expression<expr1>("(:")
#                                     ?Expression<expr2>(",:!)")
#
# Variable used in react production:
#
# Identifier:ReactVarName => ?Integer<value>(" :") VarName<name>
#
# Lag statement:
#
# Statement:LagStatement("LAG") => Identifier<name> Name<byname>(" BY :")
#
# Put or Get queue statement:
#
# Statement:QueueStatement => QueueExpressionType<qype> Identifier<name>
# Expression:QueueExpressionType => QueueType<value>
#
# Match block and match statements:
# Todo: Expression lhs has parenthesis and its better to represent lhs and rhs
#       separately rather than binary expression (for printing)
#
# Block:MatchBlock("MATCH") => *Match<matchs>
# Expression:Match => Identifier<name> ?Expression<expression>
#
# Unit block and statements within this block
#
# Block:UnitBlock("UNITS") => *Expression<definitions>
# Expression:UnitDef => Unit<unit1> Unit<unit2>("=:")
#
# Factordef statement (boolean variable gt to decide if '->' symbol exist in expression)
# This is the only case where "gt" member needs a "nmodl name" as "->"
#
# Expression:FactorDef => Name<name>(":=") ?Double<value> Unit<unit1> ?Boolean<gt>("->") ?Unit<unit2>
#
# Constant blocks and statements within this block:
#
# Statement:ConstantStatement => Name<name> Number<value>("=:") ?Unit<unit>
# Block:ConstantBlock("CONSTANT") => *ConstantStatement<statements>
#
# Table statement:
#
# Statement:TableStatement("TABLE") => *Name<tablst>("::,")
#                                      *Name<dependlst>(" DEPEND ::,")
#                                      Expression<from>(" FROM :")
#                                      Expression<to>(" TO :")
#                                      Integer<with>(" WITH :")
#
# Neuron block and Various statement within this block:
#
# Initial design confusion was whether we need separate class for every
# statement type. This is required because when we construct AST, every node
# need to be interpreted differently. This could be though separate class or
# some enum property. It might be straightforward to generate code with different
# classes.
#
# Block:NeuronBlock("NEURON") => StatementBlock<statementblock>
#
# Identifier:ReadIonVar => Name<name>
# Identifier:WriteIonVar => Name<name>
# Identifier:NonspeCurVar => Name<name>
# Identifier:ElectrodeCurVar => Name<name>
# Identifier:SectionVar => Name<name>
# Identifier:RangeVar => Name<name>
# Identifier:GlobalVar => Name<name>
# Identifier:PointerVar => Name<name>
# Identifier:BbcorePointerVar => Name<name>
# Identifier:ExternVar => Name<name>
# Identifier:ThreadsafeVar => Name<name>
#
# Statement types
# Statement:Suffix => Name<type>(": ") Name<name>
# Statement:Useion("USEION") => Name<name>
#                                  *ReadIonVar<readlist>(" READ ::,")
#                                  *WriteIonVar<writelist>(" WRITE ::,")
#                                  ?Valence<valence>
# Statement:Nonspecific("NONSPECIFIC_CURRENT") => *NonspeCurVar<currents>("::,")
# Statement:ElctrodeCurrent("ELECTRODE_CURRENT") => *ElectrodeCurVar<ecurrents>("::,")
# Statement:Section("SECTION") => *SectionVar<sections>("::,")
# Statement:Range("RANGE") => *RangeVar<range_vars>("::,")
# Statement:Global("GLOBAL") => *GlobalVar<global_vars>("::,")
# Statement:Pointer("POINTER") => *PointerVar<pointers>("::,")
# Statement:BbcorePtr("BBCOREPOINTER") => *BbcorePointerVar<bbcore_pointers>("::,")
# Statement:External("EXTERNAL") => *ExternVar<externals>("::,")
# Statement:ThreadSafe("THREADSAFE") => *ThreadsafeVar<threadsafe>("::,")
#
# Verbatim and Comment statements
# Todo : Need a way to distinguish inline comment and block comment
#
# Statement:Verbatim("VERBATIM") => String<statement>(":ENDVERBATIM")
# Statement:Comment("COMMENT") => String<comment>(":ENDCOMMENT")
#
# Valence expression for use ion statement
#
# Expression:Valence => Name<type>(" : ") Double<value>
#
#
#
# YAML BASED RULE SPECIFICATION
# =============================
#
# Text based specification described above is very limiting in terms adding extra properties.
# YAML based specification allows easy addition of new properties. Below are some comments
# about the properties and specification :
#
# 1.  Every key in YAML specification is AST node
# 2.  The hierarchy defines parent-child class relationship
# 3.  members is an array of member variables of the class
# 4.  optional : indicates if variable is optional in bison specification (i.e. pointer)
# 5.  type : type of the member
# 6.  vector : if member variable is std::vector type
# 7.  prefix/suffix :
#         value  : indicates the value (i.e. string here) of prefix/suffix itself
#         force  : print value always even if member if null pointer itself (e.g. arguments)
# 8.  separator : for the vector data type, the separator for prinitng elements
# 9.  getname : add getName() method to class and return corresponding value as name
# 10. add : need to have addMemberType method for corresponding variable (todo : remove this)
# 11. order of the members is important and determines how constructors/nmodl visitor get
#     defined from python code generators.
#
# TODO : Add detailed information about YAML specification by porting old text based rule
# specification

- AST:
  - Node:
    - Expression:
      - String:
          members:
            - value:
                type: std::string
      - Number:
        - Integer:
            members:
              - value:
                  type: int
                  getter: {name: get_value}
              - macroname:
                  type: Name
                  optional: true
                  getter: {name: get_macro_name}
        - Float:
            members:
              - value:
                  type: float
        - Double:
            members:
              - value:
                  type: double
        - Boolean:
            members:
              - value:
                  type: int
      - Identifier:
        - Name:
            members:
              - value:
                  type: String
                  getname: true
                  getter: {name: get_value}
        - PrimeName:
            members:
              - value:
                  type: String
                  getname: true
              - order:
                  type: Integer
        - VarName:
            members:
              - name:
                  type: Identifier
                  getname: true
              - at_index:
                  type: Integer
                  optional: true
                  prefix: {value: "@"}
              - index:
                  type: Expression
                  optional: true
                  prefix: {value: "["}
                  suffix: {value: "]"}
        - IndexedName:
            members:
              - name:
                  type: Identifier
                  getname: true
              - length:
                  type: Expression
                  prefix: {value: "["}
                  suffix: {value: "]"}
                  getter: {name: get_length}
        - Argument:
            members:
              - name:
                  type: Identifier
                  getname: true
              - unit:
                  type: Unit
                  optional: true
        - ReactVarName:
            members:
              - value:
                  type: Integer
                  optional: true
                  prefix: {value: " "}
              - name:
                  type: VarName
                  getname: true
        - ReadIonVar:
            members:
              - name:
                  type: Name
                  getname: true
        - WriteIonVar:
            members:
              - name:
                  type: Name
                  getname: true
        - NonspeCurVar:
            members:
              - name:
                  type: Name
                  getname: true
        - ElectrodeCurVar:
            members:
              - name:
                  type: Name
                  getname: true
        - SectionVar:
            members:
              - name:
                  type: Name
                  getname: true
        - RangeVar:
            members:
              - name:
                  type: Name
                  getname: true
        - GlobalVar:
            members:
              - name:
                  type: Name
                  getname: true
        - PointerVar:
            members:
              - name:
                  type: Name
                  getname: true
        - BbcorePointerVar:
            members:
              - name:
                  type: Name
                  getname: true
        - ExternVar:
            members:
              - name:
                  type: Name
                  getname: true
        - ThreadsafeVar:
            members:
              - name:
                  type: Name
                  getname: true
      - Block:
        - ParamBlock:
            nmodl: "PARAMETER "
            members:
              - statements:
                  type: ParamAssign
                  vector: true
        - StepBlock:
            nmodl: "STEPPED "
            members:
              - statements:
                  type: Stepped
                  vector: true
        - IndependentBlock:
            nmodl: "INDEPENDENT "
            members:
              - definitions:
                  type: IndependentDef
                  vector: true
        - DependentBlock:
            nmodl: "ASSIGNED "
            members:
              - definitions:
                  type: DependentDef
                  vector: true
        - StateBlock:
            nmodl: "STATE "
            members:
              - definitions:
                  type: DependentDef
                  vector: true
        - PlotBlock:
            members:
              - plot:
                  type: PlotDeclaration
        - InitialBlock:
            nmodl: "INITIAL "
            members:
              - statementblock:
                  type: StatementBlock
                  getter: {name: get_statement_block, override: true}
        - ConstructorBlock:
            nmodl: "CONSTRUCTOR "
            members:
              - statementblock:
                  type: StatementBlock
                  getter: {name: get_statement_block, override: true}
        - DestructorBlock:
            nmodl: "DESTRUCTOR "
            members:
              - statementblock:
                  type: StatementBlock
                  getter: {name: get_statement_block, override: true}
        - StatementBlock:
            members:
              - statements:
                  type: Statement
                  vector: true
                  getter: {name: get_statements}
        - DerivativeBlock:
            nmodl: "DERIVATIVE "
            members:
              - name:
                  type: Name
                  getname: true
                  suffix: {value: " "}
              - statementblock:
                  type: StatementBlock
                  getter: {name: get_statement_block, override: true}
        - LinearBlock:
            nmodl: "LINEAR "
            members:
              - name:
                  type: Name
                  getname: true
                  suffix: {value: " "}
              - solvefor:
                  type: Name
                  vector: true
                  separator: ","
                  prefix: {value: " SOLVEFOR "}
              - statementblock:
                  type: StatementBlock
                  getter: {name: get_statement_block, override: true}
        - NonLinearBlock:
            nmodl: "NONLINEAR "
            members:
              - name:
                  type: Name
                  getname: true
              - solvefor:
                  type: Name
                  vector: true
                  separator: ","
                  prefix: {value: " SOLVEFOR "}
                  suffix: {value: " ", force: true}
              - statementblock:
                  type: StatementBlock
                  getter: {name: get_statement_block, override: true}
        - DiscreteBlock:
            nmodl: "DISCRETE "
            members:
              - name:
                  type: Name
                  getname: true
                  suffix: {value: " "}
              - statementblock:
                  type: StatementBlock
                  getter: {name: get_statement_block, override: true}
        - PartialBlock:
            nmodl: "PARTIAL "
            members:
              - name:
                  type: Name
                  getname: true
                  suffix: {value: " "}
              - statementblock:
                  type: StatementBlock
                  getter: {name: get_statement_block, override: true}
        - FunctionTableBlock:
            nmodl: "FUNCTION_TABLE "
            members:
              - name:
                  type: Name
                  getname: true
              - arguments:
                  type: Argument
                  vector: true
                  prefix: {value: "(", force: true}
                  suffix: {value: ")", force: true}
                  separator: ", "
              - unit:
                  type: Unit
                  optional: true
                  prefix: {value: " "}
        - FunctionBlock:
            nmodl: "FUNCTION "
            members:
              - name:
                  type: Name
                  getname: true
              - arguments:
                  type: Argument
                  vector: true
                  prefix: {value: "(", force: true}
                  suffix: {value: ")", force: true}
                  separator: ", "
                  getter: {name: get_arguments, override: true}
              - unit:
                  type: Unit
                  optional: true
                  prefix: {value: " "}
                  suffix: {value: " ", force: true}
              - statementblock:
                  type: StatementBlock
                  getter: {name: get_statement_block, override: true}
        - ProcedureBlock:
            nmodl: "PROCEDURE "
            members:
              - name:
                  type: Name
                  getname: true
              - arguments:
                  type: Argument
                  vector: true
                  prefix: {value: "(", force: true}
                  suffix: {value: ") ", force: true}
                  separator: ", "
                  getter: {name: get_arguments, override: true}
              - unit:
                  type: Unit
                  optional: true
              - statementblock:
                  type: StatementBlock
                  getter: {name: get_statement_block, override: true}
        - NetReceiveBlock:
            nmodl: "NET_RECEIVE "
            members:
              - arguments:
                  type: Argument
                  vector: true
                  prefix: {value: "(", force: true}
                  suffix: {value: ") ", force: true}
                  separator: ", "
                  getter: {name: get_arguments, override: true}
              - statementblock:
                  type: StatementBlock
                  getter: {name: get_statement_block, override: true}
        - SolveBlock:
            nmodl: SOLVE
            members:
              - name:
                  type: Name
                  prefix: {value: " "}
                  getter: {name: get_solve_block}
              - method:
                  type: Name
                  optional: true
                  prefix: {value: " METHOD "}
                  getter: {name: get_method}
              - ifsolerr:
                  type: StatementBlock
                  optional: true
                  prefix: {value: " IFERROR "}
        - BreakpointBlock:
            nmodl: "BREAKPOINT "
            members:
              - statementblock:
                  type: StatementBlock
                  getter: {name: get_statement_block, override: true}
        - TerminalBlock:
            nmodl: "TERMINAL "
            members:
              - statementblock:
                  type: StatementBlock
                  getter: {name: get_statement_block, override: true}
        - BeforeBlock:
            nmodl: "BEFORE "
            members:
              - block:
                  type: BABlock
        - AfterBlock:
            nmodl: "AFTER "
            members:
              - block:
                  type: BABlock
        - BABlock:
            members:
              - type:
                  type: BABlockType
                  suffix: {value: " "}
              - statementblock:
                  type: StatementBlock
                  getter: {name: get_statement_block, override: true}
        - ForNetcon:
            nmodl: "FOR_NETCONS "
            members:
              - arguments:
                  type: Argument
                  vector: true
                  prefix: {value: "(", force: true}
                  suffix: {value: ") ", force: true}
                  separator: ", "
              - statementblock:
                  type: StatementBlock
                  getter: {name: get_statement_block, override: true}
        - KineticBlock:
            nmodl: "KINETIC "
            members:
              - name:
                  type: Name
                  getname: true
                  suffix: {value: " "}
              - solvefor:
                  type: Name
                  vector: true
                  separator: ","
              - statementblock:
                  type: StatementBlock
                  getter: {name: get_statement_block, override: true}
        - MatchBlock:
            nmodl: MATCH
            members:
              - matchs:
                  type: Match
                  vector: true
                  separator: " "
                  prefix: {value: " { "}
                  suffix: {value: " }"}
        - UnitBlock:
            nmodl: "UNITS "
            members:
              - definitions:
                  type: Expression
                  vector: true
        - ConstantBlock:
            nmodl: "CONSTANT "
            members:
              - statements:
                  type: ConstantStatement
                  vector: true
        - NeuronBlock:
            nmodl: "NEURON "
            members:
              - statementblock:
                  type: StatementBlock
      - Unit:
          members:
            - name:
                type: String
                getname: true
                prefix: {value: "("}
                suffix: {value: ")"}
      - DoubleUnit:
          members:
            - values:
                type: Double
            - unit:
                type: Unit
                optional: true
      - LocalVar:
          members:
            - name:
                type: Identifier
                getname: true
      - Limits:
          members:
            - min:
                type: Double
                prefix: {value: "<"}
                suffix: {value: ","}
            - max:
                type: Double
                suffix: {value: ">"}
      - NumberRange:
          members:
            - min:
                type: Number
                prefix: {value: "<"}
                suffix: {value: ","}
            - max:
                type: Number
                suffix: {value: ">"}

      - PlotVar:
          members:
            - name:
                type: Identifier
            - index:
                type: Integer
                optional: true
                prefix: {value: "["}
                suffix: {value: "]"}
      - ConstantVar:
          members:
            - name:
                type: Name
                getname: true
            - value:
                type: Number
                prefix: {value: " = "}
            - unit:
                type: Unit
                optional: true
                prefix: {value: " "}
      - BinaryOperator:
          members:
            - value:
                type: BinaryOp
      - UnaryOperator:
          members:
            - value:
                type: UnaryOp
      - ReactionOperator:
          members:
            - value:
                type: ReactionOp
      - WrappedExpression:
          members:
            - expression:
                type: Expression
      - ParenExpression:
          members:
            - expr:
                type: Expression
                prefix: {value: "("}
                suffix: {value: ")"}
      - BinaryExpression:
          members:
            - lhs:
                type: Expression
                getter: {name: get_lhs}
            - op:
                type: BinaryOperator
                getter: {name: get_op}
            - rhs:
                type: Expression
                getter: {name: get_rhs}
      - UnaryExpression:
          members:
            - op:
                type: UnaryOperator
            - expression:
                type: Expression
      - NonLinEquation:
          nmodl: "~ "
          members:
            - lhs:
                type: Expression
                suffix: {value: " = "}
            - rhs:
                type: Expression
      - LinEquation:
          nmodl: "~ "
          members:
            - leftlinexpr:
                type: Expression
                suffix: {value: " = "}
            - linexpr:
                type: Expression
      - FunctionCall:
          members:
            - name:
                type: Name
                getter: {name: get_function_name}
            - arguments:
                type: Expression
                vector: true
                separator: ", "
                prefix: {value: "(", force: true}
                suffix: {value: ")", force: true}
                getter: {name: get_arguments}
      - FirstLastTypeIndex:
          members:
            - value:
                type: FirstLastType
      - Watch:
          members:
            - expression:
                type: Expression
                prefix: {value: "("}
                suffix: {value: ")"}
            - value:
                type: Expression
                prefix: {value: " "}
      - QueueExpressionType:
          members:
            - value:
                type: QueueType
      - Match:
          members:
            - name:
                type: Identifier
            - expression:
                type: Expression
                optional: true
      - BABlockType:
          members:
            - value:
                type: BAType
      - UnitDef:
          members:
            - unit1:
                type: Unit
                getname: true
            - unit2:
                type: Unit
                prefix: {value: " = "}
      - FactorDef:
          members:
            - name:
                type: Name
                getname: true
                suffix: {value: " ="}
            - value:
                type: Double
                optional: true
                prefix: {value: " "}
            - unit1:
                type: Unit
                prefix: {value: " "}
            - gt:
                type: Boolean
                nmodl: " ->"
                optional: true
            - unit2:
                type: Unit
                optional: true
                prefix: {value: " "}
      - Valence:
          members:
            - type:
                type: Name
                prefix: {value: " "}
                suffix: {value: " "}
            - value:
                type: Double

    - Statement:
      - UnitState:
          members:
            - value:
                type: UnitStateType
      - LocalListStatement:
          nmodl: "LOCAL "
          members:
            - variables:
                type: LocalVar
                vector: true
                separator: ", "
      - Model:
          nmodl: TITLE
          members:
            - title:
                type: String
      - Define:
          nmodl: "DEFINE "
          members:
            - name:
                type: Name
            - value:
                type: Integer
                prefix: {value: " "}
      - Include:
          nmodl: "INCLUDE "
          members:
            - filename:
                type: String
      - ParamAssign:
          members:
            - name:
                type: Identifier
                getname: true
            - value:
                type: Number
                optional: true
                prefix: {value: " = "}
            - unit:
                type: Unit
                optional: true
                prefix: {value: " "}
            - limit:
                type: Limits
                optional: true
                prefix: {value: " "}
      - Stepped:
          members:
            - name:
                type: Name
            - values:
                type: Number
                vector: true
                prefix: {value: " = "}
                separator: ", "
            - unit:
                type: Unit
                optional: true
                prefix: {value: " "}
      - IndependentDef:
          members:
            - sweep:
                type: Boolean
                optional: true
                nmodl: "SWEEP "
            - name:
                type: Name
            - from:
                type: Number
                prefix: {value: " FROM "}
            - to:
                type: Number
                prefix: {value: " TO "}
            - with:
                type: Integer
                prefix: {value: " WITH "}
            - opstart:
                type: Number
                prefix: {value: " START "}
                optional: true
            - unit:
                type: Unit
                optional: true
                prefix: {value: " "}
      - DependentDef:
          members:
            - name:
                type: Identifier
                getname: true
            - length:
                type: Integer
                optional: true
                prefix: {value: "["}
                suffix: {value: "]"}
                getter: {name: get_length}
            - from:
                type: Number
                prefix: {value: " FROM "}
                optional: true
            - to:
                type: Number
                prefix: {value: " TO "}
                optional: true
            - opstart:
                type: Number
                prefix: {value: " START "}
                optional: true
            - unit:
                type: Unit
                optional: true
                prefix: {value: " "}
            - abstol:
                type: Double
                prefix: {value: " <"}
                suffix: {value: ">"}
                optional: true
      - PlotDeclaration:
          nmodl: "PLOT "
          members:
            - pvlist:
                type: PlotVar
                vector: true
                separator: ", "
            - name:
                type: PlotVar
                prefix: {value: " VS "}
      - ConductanceHint:
          nmodl: "CONDUCTANCE "
          members:
            - conductance:
                type: Name
                getter: {name: get_variable}
            - ion:
                type: Name
                optional: true
                prefix: {value: " USEION "}
                getter: {name: get_ion}
      - ExpressionStatement:
          members:
            - expression:
                type: Expression
                getter: {name: get_expression}
      - ProtectStatement:
          nmodl: "PROTECT "
          members:
            - expression:
                type: Expression
      - FromStatement:
          nmodl: "FROM "
          members:
            - name:
                type: Name
                getter: {name: get_from_name}
            - from:
                type: Expression
                prefix: {value: " = "}
                getter: {name: get_from_expression}
            - to:
                type: Expression
                prefix: {value: " TO "}
                getter: {name: get_to_expression}
            - opinc:
                type: Expression
                prefix: {value: " BY "}
                suffix: {value: " ", force: true}
                optional: true
                getter: {name: get_inc_expression}
            - statementblock:
                type: StatementBlock
                getter: {name: get_block}
      - ForAllStatement:
          nmodl: "FORALL "
          members:
            - name:
                type: Name
                suffix: {value: " "}
            - statementblock:
                type: StatementBlock
      - WhileStatement:
          nmodl: "WHILE "
          members:
            - condition:
                type: Expression
                prefix: {value: "("}
                suffix: {value: ") "}
            - statementblock:
                type: StatementBlock
      - IfStatement:
          nmodl: "IF "
          members:
            - condition:
                type: Expression
                prefix: {value: "("}
                suffix: {value: ") "}
            - statementblock:
                type: StatementBlock
            - elseifs:
                type: ElseIfStatement
                vector: true
            - elses:
                type: ElseStatement
                optional: true
      - ElseIfStatement:
          nmodl: " ELSE IF "
          members:
            - condition:
                type: Expression
                prefix: {value: "("}
                suffix: {value: ") "}
            - statementblock:
                type: StatementBlock
      - ElseStatement:
          nmodl: " ELSE "
          members:
            - statementblock:
                type: StatementBlock
      - PartialEquation:
          members:
            - prime:
                type: PrimeName
            - name1:
                type: Name
            - name2:
                type: Name
            - name3:
                type: Name
      - PartialBoundary:
          nmodl: "~ "
          members:
            - del:
                type: Name
                optional: true
                suffix: {value: " "}
            - name:
                type: Identifier
            - index:
                type: FirstLastTypeIndex
                optional: true
                prefix: {value: "["}
                suffix: {value: "]"}
            - expression:
                type: Expression
                optional: true
                prefix: {value: " = "}
            - name1:
                type: Name
                optional: true
                prefix: {value: " = "}
                suffix: {value: "*"}
            - del2:
                type: Name
                optional: true
                suffix: {value: "("}
            - name2:
                type: Name
                optional: true
                suffix: {value: ")"}
            - name3:
                type: Name
                optional: true
                prefix: {value: "+"}
      - WatchStatement:
          nmodl: "WATCH "
          members:
            - statements:
                type: Watch
                vector: true
                separator: ","
                add: true
      - MutexLock:
          nmodl: MUTEXLOCK
      - MutexUnlock:
          nmodl: MUTEXUNLOCK
      - Reset:
          nmodl: RESET
      - Sens:
          nmodl: "SENS "
          members:
            - senslist:
                type: VarName
                vector: true
                separator: ", "
      - Conserve:
          nmodl: CONSERVE
          members:
            - react:
                type: Expression
                prefix: {value: " "}
            - expr:
                type: Expression
                prefix: {value: " = "}
      - Compartment:
          nmodl: COMPARTMENT
          members:
            - name:
                type: Name
                optional: true
                prefix: {value: " "}
                suffix: {value: ","}
            - expression:
                type: Expression
                prefix: {value: " "}
            - names:
                type: Name
                vector: true
                prefix: {value: " {"}
                suffix: {value: "}"}
                separator: " "
      - LonDifuse:
          nmodl: LONGITUDINAL_DIFFUSION
          members:
            - name:
                type: Name
                optional: true
                prefix: {value: " "}
                suffix: {value: ","}
            - expression:
                type: Expression
                prefix: {value: " "}
            - names:
                type: Name
                vector: true
                prefix: {value: " {"}
                suffix: {value: "}"}
                separator: " "
      - ReactionStatement:
          nmodl: "~ "
          members:
            - react1:
                type: Expression
            - op:
                type: ReactionOperator
                prefix: {value: " "}
            - react2:
                type: Expression
                prefix: {value: " "}
                optional: true
            - expr1:
                type: Expression
                prefix: {value: " ("}
            - expr2:
                type: Expression
                prefix: {value: ", "}
                suffix: {value: ")", force: true}
                optional: true
      - LagStatement:
          nmodl: "LAG "
          members:
            - name:
                type: Identifier
            - byname:
                type: Name
                prefix: {value: " BY "}
      - QueueStatement:
          members:
            - qype:
                type: QueueExpressionType
            - name:
                type: Identifier
                prefix: {value: " "}
      - ConstantStatement:
          members:
            - constant:
                type: ConstantVar
      - TableStatement:
          nmodl: "TABLE "
          members:
            - table_vars:
                type: Name
                vector: true
                separator: ","
            - depend_vars:
                type: Name
                vector: true
                prefix: {value: " DEPEND "}
                separator: ","
            - from:
                type: Expression
                prefix: {value: " FROM "}
            - to:
                type: Expression
                prefix: {value: " TO "}
            - with:
                type: Integer
                prefix: {value: " WITH "}
      - Suffix:
          members:
            - type:
                type: Name
                suffix: {value: " "}
                getter: {name: get_suffix_type}
            - name:
                type: Name
                getter: {name: get_suffix_name}
      - Useion:
          nmodl: "USEION "
          members:
            - name:
                type: Name
                getname: true
            - readlist:
                type: ReadIonVar
                vector: true
                prefix: {value: " READ "}
                separator: ", "
            - writelist:
                type: WriteIonVar
                vector: true
                prefix: {value: " WRITE "}
                separator: ", "
            - valence:
                type: Valence
                optional: true
      - Nonspecific:
          nmodl: "NONSPECIFIC_CURRENT "
          members:
            - currents:
                type: NonspeCurVar
                vector: true
                separator: ", "
      - ElctrodeCurrent:
          nmodl: "ELECTRODE_CURRENT "
          members:
            - ecurrents:
                type: ElectrodeCurVar
                vector: true
                separator: ", "
      - Section:
          nmodl: "SECTION "
          members:
            - sections:
                type: SectionVar
                vector: true
                separator: ", "
      - Range:
          nmodl: "RANGE "
          members:
            - range_vars:
                type: RangeVar
                vector: true
                separator: ", "
      - Global:
          nmodl: "GLOBAL "
          members:
            - global_vars:
                type: GlobalVar
                vector: true
                separator: ", "
      - Pointer:
          nmodl: "POINTER "
          members:
            - pointers:
                type: PointerVar
                vector: true
                separator: ", "
      - BbcorePtr:
          nmodl: "BBCOREPOINTER "
          members:
            - bbcore_pointers:
                type: BbcorePointerVar
                vector: true
                separator: ", "
      - External:
          nmodl: "EXTERNAL "
          members:
            - externals:
                type: ExternVar
                vector: true
                separator: ", "
      - ThreadSafe:
          nmodl: THREADSAFE
          members:
            - threadsafe:
                type: ThreadsafeVar
                vector: true
                separator: ", "
                prefix: {value: " "}
      - Verbatim:
          nmodl: VERBATIM
          members:
            - statements:
                type: String
                getter: {name: get_statement}
                suffix: {value: "ENDVERBATIM"}
      - Comment:
          members:
            - block_comment:
                type: String
                prefix: {value: "COMMENT"}
                suffix: {value: "ENDCOMMENT"}
                optional: true
            - line_comment:
                type: String
                optional: true

- Program:
    members:
    - blocks:
        type: Node
        vector: true
        add: true
        getter: {name: get_blocks}
