# *********************************************************************
# Copyright (C) 2018-2019 Blue Brain Project
#
# This file is part of NMODL distributed under the terms of the GNU
# Lesser General Public License. See top-level LICENSE file for details.
# *********************************************************************

######################### NMODL Abstract Language Definition ##############################
#
# PURPOSE
# =======
#
# NMODL language specification in nmod.yaml takes care of representing NMODL language
# AST generation. This AST is sufficient for NMODL level analysis and optimizations.
# In order to perform code generation transformations, we need to perform various
# transoformations on AST and add new node types. For example, PROCEDURE and FUNCTION
# nodes in NMODL doesn't have return type (double by default).  Also, we can't represent
# code generation specific information (e.g. variable or function qualifiers) with the
# existing AST nodes. This yaml specification describe additional node types that can
# be used for code generation purpose. Note that they are using same inheritance
# hierarchy because we would like to use single AST to represent the NMODL with and
# without code generation transformations.

- AST:
    children:
      - Node:
          children:
            - Expression:
                children:
                  - Number:
                  - Void:
                      nmodl: "VOID"
                      brief: "Represent void type in code generation"
                  - Identifier:
                      children:
                        - CodegenVarType:
                            brief: "Represent type of the variable"
                            members:
                              - type:
                                  brief: "Type of the ast node"
                                  type: AstNodeType
                        - CodegenVar:
                            brief: "Represent variable used for code generation"
                            members:
                              - pointer:
                                  brief: "If variable is pointer type"
                                  type: int
                              - name:
                                  brief: "Name of the variable"
                                  type: Identifier
                                  node_name: true
                        - CodegenArgument:
                            brief: "Represent argument to a function"
                            members:
                              - type:
                                  brief: "Type of the argument"
                                  type: CodegenVarType
                                  suffix: {value: " "}
                              - name:
                                  brief: "Name of the argument"
                                  type: Identifier
                                  node_name: true
                  - Block:
                      children:
                        - NrnStateBlock:
                            nmodl: "NRN_STATE "
                            brief: "Represents the coreneuron nrn_state callback function"
                            members:
                              - solve_statements:
                                  brief: "solve blocks to be called or generated"
                                  type: Statement
                                  vector: true
                        - EigenNewtonSolverBlock:
                            brief: "Represent newton solver solution block based on Eigen"
                            nmodl: "EIGEN_NEWTON_SOLVE"
                            members:
                              - n_state_vars:
                                  brief: "number of state vars used in solve"
                                  type: Integer
                                  prefix: {value: "["}
                                  suffix: {value: "]"}
                              - variable_block:
                                  brief: "Statements to be declared in the functor"
                                  type: StatementBlock
                              - initialize_block:
                                  brief: "Statement block to be executed before calling newton solver"
                                  type: StatementBlock
                              - setup_x_block:
                                  brief: "update X from states"
                                  type: StatementBlock
                              - functor_block:
                                  brief: "odes as functor for eigen"
                                  type: StatementBlock
                              - update_states_block:
                                  brief: "update back states from X"
                                  type: StatementBlock
                              - finalize_block:
                                  brief: "Statement block to be executed after calling newton solver"
                                  type: StatementBlock
                        - EigenLinearSolverBlock:
                            brief: "Represent linear solver solution block based on Eigen"
                            nmodl: "EIGEN_LINEAR_SOLVE"
                            members:
                              - n_state_vars:
                                  brief: "number of state vars used in solve"
                                  type: Integer
                                  prefix: {value: "["}
                                  suffix: {value: "]"}
                              - variable_block:
                                  brief: "Statements to be declared in the functor"
                                  type: StatementBlock
                              - initialize_block:
                                  brief: "Statement block to be executed before calling linear solver"
                                  type: StatementBlock
                              - setup_x_block:
                                  brief: "update X from states"
                                  type: StatementBlock
                              - update_states_block:
                                  brief: "update back states from X"
                                  type: StatementBlock
                              - finalize_block:
                                  brief: "Statement block to be executed after calling linear solver"
                                  type: StatementBlock
                        - CodegenFunction:
                            brief: "Function generated from FUNCTION or PROCEDURE block"
                            members:
                              - return_type:
                                  brief: "Return type of the function"
                                  type: CodegenVarType
                                  suffix: {value: " "}
                              - name:
                                  brief: "Name of the function"
                                  type: Name
                                  node_name: true
                              - arguments:
                                  brief: "Vector of the parameters to the function"
                                  type: CodegenArgument
                                  vector: true
                                  prefix: {value: "(", force: true}
                                  suffix: {value: ")", force: true}
                                  separator: ", "
                              - statement_block:
                                  brief: "Body of the function"
                                  type: StatementBlock
                                  getter: {override: true}
                  - WrappedExpression:
                      brief: "Wrap any other expression type"
                      members:
                        - expression:
                            brief: "Expression that is being wrapped"
                            type: Expression
                  - DerivimplicitCallback:
                      brief: "Represent a callback to NEURON's derivimplicit solver"
                      members:
                        - node_to_solve:
                            brief: "Block to be solved (typically derivative)"
                            type: Block
                  - SolutionExpression:
                      brief: "Represent solution of a block in the AST"
                      members:
                        - solve_block:
                            type: SolveBlock
                        - node_to_solve:
                            brief: "Block to be solved (callback node or solution node itself)"
                            type: Expression
                  - CodegenStruct:
                      brief: "Represent a struct or class for code generation"
                      members:
                        - variable_statements:
                            brief: "member variables of the class/struct"
                            type: CodegenVarListStatement
                            vector: true
                        - functions:
                            brief: "member functions of the class/struct"
                            type: CodegenFunction
                            vector: true
            - Statement:
                children:
                  - CodegenForStatement:
                      brief: "Represent for loop used for code generation"
                      nmodl: "for("
                      members:
                        - initialization:
                            brief: "initialization expression for the loop"
                            type: Expression
                            optional: true
                        - condition:
                            brief: "condition expression for the loop"
                            type: Expression
                            optional: true
                            prefix: {value: "; "}
                            suffix: {value: "; "}
                        - increment:
                            brief: "increment or decrement expression for the loop"
                            type: Expression
                            optional: true
                            suffix: {value: ") "}
                        - statement_block:
                            brief: "body of the loop"
                            type: StatementBlock
                            getter: {override: true}
                  - CodegenReturnStatement:
                      brief: "Represent return statement for code generation"
                      nmodl: "return "
                      members:
                        - statement:
                            brief: "return statement"
                            type: Expression
                            optional: true
                  - CodegenVarListStatement:
                      brief: "Represent list of variables used for code generation"
                      members:
                        - var_type:
                            brief: "Type of the variables"
                            type: CodegenVarType
                            suffix: {value: " "}
                        - variables:
                            brief: "List of the variables to define"
                            type: CodegenVar
                            vector: true
                            separator: ", "
                            add: true
                  - CodegenAtomicStatement:
                      brief: "Represent atomic operation"
                      description: |
                        During code generation certain operations like ion updates, vec_rhs or
                        vec_d updates (for synapse) needs to be atomic operations if executed by
                        multiple threads. In case of SIMD, there are conflicts for `vec_d` and
                        `vec_rhs` for synapse types. Here are some statements from C++ backend:

                        \code{.cpp}
                            vec_d[node_id] += g
                            vec_rhs[node_id] -= rhs
                            ion_ina[indexes[some_index]] += ina[id]
                            ion_cai[indexes[some_index]] = cai[id]  // cai here is state variable
                        \endcode

                        These operations will be represented by atomic statement node type:
                        * `vec_d[node_id]` : lhs
                        * `+=` : atomic_op
                        * `g` : rhs

                      members:
                        - lhs:
                            brief: "Variable to be updated atomically"
                            type: Identifier
                        - atomic_op:
                            brief: "Operator"
                            type: BinaryOperator
                            prefix: {value: " "}
                            suffix: {value: " "}
                        - rhs:
                            brief: "Expression for atomic operation"
                            type: Expression
