/*
 * Copyright 2023 Blue Brain Project, EPFL.
 * See the top-level LICENSE file for details.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include "config/config.h"

#include <cstdlib>
#include <filesystem>
#include <fstream>
#include <sstream>

namespace fs = std::filesystem;

/// Git version of the project
const std::string nmodl::Version::GIT_REVISION = "@NMODL_GIT_REVISION@";

/// NMODL version
const std::string nmodl::Version::NMODL_VERSION = "@PROJECT_VERSION@";

/**
 * \brief Path of nrnutils.lib file
 *
 * nrnunits.lib need to be loaded at runtime. Before project is
 * installed it needs to be read from NMODL_PROJECT_BINARY_DIR and later
 * from CMAKE_INSTALL_PREFIX. Note that this use of NMODL_PROJECT_BINARY_DIR
 * will cause ccache misses when the build prefix is changed.
 */
const std::vector<std::string> nmodl::PathHelper::BASE_SEARCH_PATHS =
    {"@CMAKE_INSTALL_PREFIX@", "@NMODL_PROJECT_BINARY_DIR@"};

const std::string nmodl::PathHelper::SHARED_LIBRARY_SUFFIX = "@CMAKE_SHARED_LIBRARY_SUFFIX@";

namespace {

std::string maybe_from_env(const std::string& varname) {
    const auto value = std::getenv(varname.c_str());
    if (value != nullptr) {
        return value;
    }
    return "";
}

}

std::string nmodl::PathHelper::nmodl_home = maybe_from_env("NMODL_HOME");

std::string nmodl::PathHelper::get_path(const std::string& what, bool add_library_suffix) {
    std::vector<std::string> search_paths = BASE_SEARCH_PATHS;
    if (!get_home().empty()) {
        search_paths.emplace(search_paths.begin(), get_home());
    }

    // check paths in order and return if found
    for (const auto& path: search_paths) {
        auto full_path = fs::path(path) / fs::path(what);
        if (add_library_suffix) {
            full_path += SHARED_LIBRARY_SUFFIX;
        }
        std::ifstream f(full_path);
        if (f.good()) {
            return full_path;
        }
    }
    std::ostringstream err_msg;
    err_msg << "Could not find '" << what << "' in any of:\n";
    for (const auto& path: search_paths) {
        err_msg << "\t" << path << "\n";
    }
    err_msg << "Please try setting the NMODLHOME environment variable\n";
    throw std::runtime_error(err_msg.str());
}

void nmodl::PathHelper::setup(const std::string& executable) {
    // We give precedence to NMODLHOME - don't override if the home is already defined
    if (nmodl_home.empty()) {
        auto executable_dir = fs::canonical(fs::path(executable)).parent_path();
        if (executable_dir.filename() == "bin") {
            nmodl_home = executable_dir.parent_path();
        } else {
            // On Windows, we may find ourselves in the top-level directory without a bin/
            nmodl_home = executable_dir;
        }
    }
}
