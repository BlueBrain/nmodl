/*************************************************************************
 * Copyright (C) 2018-2019 Blue Brain Project
 *
 * This file is part of NMODL distributed under the terms of the GNU
 * Lesser General Public License. See top-level LICENSE file for details.
 *************************************************************************/

#pragma once

#include "parser/c/c11_parser.hpp"

/** Flex expects the declaration of yylex to be defined in the macro YY_DECL
 * and C++ parser class expects it to be declared. */
#ifndef YY_DECL
#define YY_DECL nmodl::parser::CParser::symbol_type nmodl::parser::CLexer::next_token()
#endif

/** For creating multiple (different) lexer classes, we can use '-P' flag
 * (or prefix option) to rename each yyFlexLexer to some other name like
 * ‘xxFlexLexer’. And then include <FlexLexer.h> in other sources once per
 * lexer class, first renaming yyFlexLexer as shown below. */
#ifndef __FLEX_LEXER_H
#define yyFlexLexer CFlexLexer
#include "FlexLexer.h"
#endif

namespace nmodl {
namespace parser {

/**
 * \class CLexer
 * \brief Represent Lexer/Scanner class for C (11) language parsing
 *
 * Lexer defined to add some extra function to the scanner class from flex.
 * Flex itself creates yyFlexLexer class, which we renamed using macros to
 * C11FlexLexer. But we change the context of the generated yylex() function
 * because the yylex() defined in C11FlexLexer has no parameters. Also, note
 * that implementation of the member functions are in c11.ll file due to use
 * of macros. */
class CLexer: public CFlexLexer {
  public:
    /** Reference to driver object which contains this lexer instance. This is
     * used for error reporting and checking macro definitions. */
    CDriver& driver;

    /// For tracking location of the tokens
    location loc;

    /** The streams in and out default to cin and cout, but that assignment
     * is only made when initializing in yylex(). */
    explicit CLexer(CDriver& drv, std::istream* in = nullptr, std::ostream* out = nullptr)
        : CFlexLexer(in, out)
        , driver(drv) {}

    ~CLexer() override = default;
    ;

    /** Main lexing function generated by flex according to the macro declaration
     * YY_DECL above. The generated bison parser then calls this virtual function
     * to fetch new tokens. Note that yylex() has different declaration and hence
     * it can't be used for new lexer. */
    virtual CParser::symbol_type next_token();

    /** Return type of the word : could be typedef, identifier or enum constant */
    CParser::symbol_type check_type();

    /// consume comment
    std::string input_comment();
};

}  // namespace parser
}  // namespace nmodl