/*************************************************************************
 * Copyright (C) 2018-2020 Blue Brain Project
 *
 * This file is part of NMODL distributed under the terms of the GNU
 * Lesser General Public License. See top-level LICENSE file for details.
 *************************************************************************/

#pragma once

/**
 * \file
 * \brief \copybrief nmodl::visitor::SympyReplaceSolutionsVisitor
 */

#include "visitors/ast_visitor.hpp"

#include <algorithm>
#include <set>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <vector>

namespace nmodl {
namespace visitor {

/**
 * @addtogroup visitor_classes
 * @{
 */


/**
 * \class SympyReplaceSolutionsVisitor
 * \brief Replace statements in \p node with pre_solve_statements, tmp_statements, and solutions
 *
 * The goal is to replace statements with \ref solutions_ in place. In this way we can allow (to
 * some extent) the use of control flow blocks and assignments. \ref pre_solve_statements are added
 * in front of the replaced statements in case their variable needs updating. \ref SolutionSorter
 * keeps track of what needs updating. Let's start with some nomenclature:
 *
 * - statement: a line in the .mod file. It can be a diff_eq_expression, binary_expression, or
 * linEquation
 * - old_Statement: line in the staementBlock that must be replaced with the solution
 * - solution/ new_statement: a nmodl-statement (always binary expression) provided by sympy that
 * assigns a variable
 * - pre_solve_Statements: statements that update the variables (i.e. x = old_x)
 * - tmp_solutions: assignment of temporary variables in the solution generated by sympy in case
 * --cse. (i.e. \f tmp = f
 * (...) \f
 *
 * We employ a multi-step approach:
 *
 * - try to replace the old_statements (not binary_expressions) and in "assignment form: \f x =
 * f(...) \f" with the corresponding solution matching by variable (i.e. x in \f x = f(...) \f)
 * - try to replace the old_Statements with a greedy approach. When we find a
 * diff_eq_expression/linEquation that needs replacing we take the next solution that was not yet
 * used
 * - add all the remaining solutions at the end
 */
class SympyReplaceSolutionsVisitor: public AstVisitor {
  public:
    enum class ReplacePolicy {
        VALUE = 0,   //!< Replace statements matching by lhs varName
        GREEDY = 1,  //!< Replace statements greedily
    };
    /// Empty ctor
    SympyReplaceSolutionsVisitor() = delete;

    /// Default constructor
    SympyReplaceSolutionsVisitor(const std::vector<std::string>& pre_solve_statements,
                                 const std::vector<std::string>& solutions,
                                 const std::unordered_set<ast::Statement*>& to_be_removed,
                                 const ReplacePolicy policy,
                                 size_t n_next_equations);

    /// idx (in the new statementVector) of the first statement that was added. -1 if nothing was
    /// added
    inline int replaced_statements_begin() const {
        return replaced_statements_begin_;
    }
    /// idx (in the new statementVector) of the last statement that was added. -1 if nothing was
    /// added
    inline int replaced_statements_end() const {
        return replaced_statements_end_;
    }

    void visit_statement_block(ast::StatementBlock& node) override;
    void visit_diff_eq_expression(ast::DiffEqExpression& node) override;
    void visit_lin_equation(ast::LinEquation& node) override;
    void visit_non_lin_equation(ast::NonLinEquation& node) override;
    void visit_binary_expression(ast::BinaryExpression& node) override;


  private:
    /** \brief Try to replace a statement
     *
     * @param node it can be Diff_Eq_Expression/LinEquation/NonLinEquation
     * @param get_lhs method with witch we may get the lhs (in case we need it)
     * @param get_rhs method with witch we may get the rhs (in case we need it)
     */
    void try_replace_tagged_statement(
        const ast::Node& node,
        const std::shared_ptr<ast::Expression>& get_lhs(const ast::Node& node),
        const std::shared_ptr<ast::Expression>& get_rhs(const ast::Node& node));

    /**
     * \struct InterleavesCounter
     * \brief Count interleaves of assignment statement inside the system of equations
     */
    struct InterleavesCounter {
        /// Count an interleave if \ref in_system_ switches false -> true
        void new_equation(const bool is_in_system);

        /// Number of interleaves. We need to remove the first activation of the switch
        inline size_t n() const {
            return n_ == 0 ? 0 : n_ - 1;
        }

      private:
        /**
         * \brief Number of interleaves of assignment statements in between equations of the system
         * of equations
         *
         * This is equivalent to the number of switches false -> true of \ref in_system_ minus the
         * very first one (if the system exists).
         */
        size_t n_ = 0;

        /// Bool that keeps track if just wrote an equation of the system of equations (true) or not
        /// (false)
        bool in_system_ = false;
    };


    /**
     * \struct SolutionSorter
     * \brief Sorts and maps statements to variables keeping track of what needs updating
     *
     * This is a multi-purpose object that:
     *
     * - keeps track of what was already updated
     * - decides what statements need updating in case there was a variable assignment (i.e. \f a =
     * 3 \f)
     * - builds the statements from a vector of strings
     *
     */
    struct SolutionSorter {
        /// Empty ctor
        SolutionSorter() = default;

        /// Standard ctor
        SolutionSorter(const std::vector<std::string>::const_iterator& statements_str_beg,
                       const std::vector<std::string>::const_iterator& statements_str_end,
                       const int error_on_n_flushes);

        /**
         * /brief Construct the maps for easy access and classification of the statements
         *
         * Here we construct a map variable -> affected equations. In other words this map tells me
         * what equations need to be updated when I change a particular variable. To do that we
         * build a a graph of dependencies var -> vars and in the mean time we reduce it to the root
         * variables. This is ensured by the fact that the tmp variables are sorted so that the next
         * tmp variable may depend on the previous one. Since it is a relation of equivalence (if an
         * equation depends on a variable, it needs to be updated if the variable changes), we build
         * the two maps at the same time.
         *
         * An example:
         *
         *  - \f tmp0 = x + a \f
         *  - \f tmp1 = tmp0 + b \f
         *  - \f tmp2 = y \f
         *
         * dependency_map_ should be (the order of the equation is unimportant since we are building
         * a map):
         *
         * - tmp0 : x, a
         * - tmp1 : x, a, b
         * - tmp2 : y
         *
         * and the var2statement_ map should be (the order of the following equations is unimportant
         * since we are building a map. The number represents the index of the original equations):
         *
         * - x : 0, 1
         * - y : 2
         * - a : 0, 1
         * - b : 1
         */
        void build_maps();

        /// Check if one of the statements assigns this variable (i.e. \f x' = f(x, y, x) \f) and is
        /// still tagged
        inline bool is_var_assigned_here(const std::string& var) const {
            const auto it = var2statement_.find(var);
            return it != var2statement_.end() && tags_.find(it->second) != tags_.end();
        }

        /**
         * \brief Look for \p var in \ref var2statement_ and emplace back that statement in \p
         * new_statements
         *
         * If there is no \p var key in \ref var2statement_, return false
         */
        bool try_emplace_back_tagged_statement(ast::StatementVector& new_statements,
                                               const std::string& var);


        /// Emplace back the next \p n_next_statements solutions in \ref statements that is marked
        /// for updating in \ref tags_
        size_t emplace_back_next_tagged_statements(ast::StatementVector& new_statements,
                                                   const size_t n_next_statements);

        /// Emplace back all the statements that are marked for updating in \ref tags_
        size_t emplace_back_all_tagged_statements(ast::StatementVector& new_statements);

        /**
         * \brief Tag all the statements that depend on \p var for updating
         *
         * This is necessary when an assignment has invalidated this variable
         */
        size_t tag_dependant_statements(const std::string& var);

        /// Mark that all the statements need updating (probably unused)
        void tag_all_statements();

        /**
         * \brief var -> (depends on) vars
         *
         * The statements are assignments. Thus, in general, an assigned variable depends on
         * the variables in the rhs of the assignment operator. This map keeps track of this
         * dependency
         */
        std::unordered_map<std::string, std::unordered_set<std::string>> dependency_map_;

        /**
         * \brief var -> (statements that depend on) statements
         *
         * This the "reverse" of \ref dependency_map_. Given a certain variable it provides
         * the statements that depend on it. It is a set because we want to print them in
         * order and we do not want duplicates. The value is the index in \ref statements_ or \ref
         * tags_
         */
        std::unordered_map<std::string, std::set<size_t>> var2dependants_;

        /**
         * \brief var -> statement that sets that var
         *
         * Given a certain variable we get the statement that sets that variable as index in \ref
         * statements_ or \ref tags_
         */
        std::unordered_map<std::string, size_t> var2statement_;

        /// Vector of statements
        std::vector<std::shared_ptr<ast::Statement>> statements_;

        /**
         * \brief Keeps track of what statements need updating
         *
         * The elements of this set are the indexes of the \ref statements_ vector that need
         * updating. It is a set because we need to be able to easily find them by value and we need
         * them ordered to pick "the next one"
         */
        std::set<size_t> tags_;

        /**
         * \brief Max number of times a statement was printed using an \ref
         * emplace_all_back_statement command
         *
         * This is useful to check if, during updates, a variable was assigned.
         *
         * For example:
         *
         * \f x' = a \f
         * \f x = a + 1 \f
         * \f y' = b \f
         *
         * In this sequence of statements \f x \f was assigned within variable updates. This
         * sequence of statements could lead to instability/wrong results for derivimplicit methods.
         * Better to prevent this entirely. It can still be assigned at the end/beginning
         */
        size_t n_flushes_ = 0;

        /// Emit error when \ref n_flushes_ reaches this number. -1 disables the error entirely
        int error_on_n_flushes_;
    };

    /// Update state variable statements (i.e. \f old_x = x \f)
    SolutionSorter pre_solve_statements_;

    /// tmp statements that appear with --cse (i.e. \f tmp0 = a \f)
    SolutionSorter tmp_statements_;

    /// solutions that we want to replace
    SolutionSorter solutions_;

    /**
     * \brief Replacements found by the visitor
     *
     * The keys are the old_statements that need replacing with the new ones (the
     * value). Since there are \ref pre_solve_statements_ and \ref tmp_statements_; it is in general
     * a replacement of 1 : n statements
     */
    std::unordered_map<std::shared_ptr<ast::Statement>, ast::StatementVector> replacements_;

    /// Used to notify to visit_statement_block was called by the user (or another visitor) or
    /// re-called in a nested block
    bool is_statement_block_root_ = true;

    /// Replacement policy used by the various visitors
    ReplacePolicy policy_;

    /// Number of solutions that match each old_statement with the greedy policy
    size_t n_next_equations_;

    /// group of old statements that need replacing
    const std::unordered_set<ast::Statement*>* to_be_removed_;

    /// counts how many times the solution statements are interleaved with assignment expressions
    InterleavesCounter interleaves_counter_;

    /// first added statement index
    int replaced_statements_begin_ = -1;

    /// idx of the element after the last added statement (for cpp ranges)
    int replaced_statements_end_ = -1;
};

/** @} */  // end of visitor_classes

}  // namespace visitor
}  // namespace nmodl
