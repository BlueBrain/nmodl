<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>User Guide: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_nmodl.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">User Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('todo.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Todo List </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt><a class="anchor" id="_todo000025"></a>File <a class="el" href="modl_8h.html">modl.h</a>  </dt>
<dd>Add these bit masks as enum-flags and remove this legacy header  </dd>
<dt><a class="anchor" id="_todo000065"></a>Class <a class="el" href="structnmodl_1_1ast_1_1_ast.html">nmodl::ast::Ast</a>  </dt>
<dd>With the <a class="el" href="classnmodl_1_1ast_1_1_node.html" title="Base class for all AST node. ">ast::Node</a> as another top level node, this can be removed in the future.  </dd>
<dt><a class="anchor" id="_todo000066"></a>Class <a class="el" href="classnmodl_1_1ast_1_1_constant_statement.html">nmodl::ast::ConstantStatement</a>  </dt>
<dd>As <a class="el" href="classnmodl_1_1ast_1_1_constant_statement.html" title="Represent statement in CONSTANT block of NMODL. ">ConstantStatement</a> wraps a single <a class="el" href="classnmodl_1_1ast_1_1_constant_var.html" title="Represents a variable in the ast::ConstantBlock. ">ConstantVar</a>, this or <a class="el" href="classnmodl_1_1ast_1_1_constant_var.html" title="Represents a variable in the ast::ConstantBlock. ">ast::ConstantVar</a> can be redundant in the future. </dd>
<dt><a class="anchor" id="_todo000067"></a>Class <a class="el" href="classnmodl_1_1ast_1_1_plot_block.html">nmodl::ast::PlotBlock</a>  </dt>
<dd>Check ModelDB and other databse for example of channel. </dd>
<dt><a class="anchor" id="_todo000068"></a>Class <a class="el" href="classnmodl_1_1ast_1_1_step_block.html">nmodl::ast::StepBlock</a>  </dt>
<dd>Check ModelDB and other databse for example of channel. </dd>
<dt><a class="anchor" id="_todo000001"></a>Member <a class="el" href="classnmodl_1_1codegen_1_1_codegen_acc_visitor.html#a0afbe91263bad633cba874fd9c7b5af6">nmodl::codegen::CodegenAccVisitor::print_abort_routine</a>  () const override</dt>
<dd>: we need to implement proper error handling mechanism to propogate errors from GPU to CPU. For example, error code can be returned like original neuron implementation. For now we use <code>assert(0==1)</code> pattern which is used for OpenACC/CUDA.  </dd>
<dt><a class="anchor" id="_todo000002"></a>Member <a class="el" href="classnmodl_1_1codegen_1_1_codegen_acc_visitor.html#a532e903a7bb7f8c3dfeac467f53e111d">nmodl::codegen::CodegenAccVisitor::print_net_init_acc_serial_annotation_block_begin</a>  () override</dt>
<dd>: With the current code structure for NMODL and MOD2C, we use <code>serial</code> construct to launch serial kernels. This is during initialization but still inefficient. This should be improved when we drop MOD2C.  </dd>
<dt><a class="anchor" id="_todo000018"></a>Class <a class="el" href="classnmodl_1_1codegen_1_1_codegen_c_visitor.html">nmodl::codegen::CodegenCVisitor</a>  </dt>
<dd><ul>
<li>Handle define statement (i.e. macros)</li>
<li>If there is a return statement in the verbatim block of inlined function then it will be error. Need better error checking. For example, see netstim.mod where we have removed return from verbatim block.  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000019"></a>Member <a class="el" href="classnmodl_1_1codegen_1_1_codegen_c_visitor.html#a9a8bf6fbd963e10396c0915e792aaec2">nmodl::codegen::CodegenCVisitor::codegen_global_variables</a>  </dt>
<dd>: this has become different than <a class="el" href="structnmodl_1_1codegen_1_1_codegen_info.html" title="Represent information collected from AST for code generation. ">CodegenInfo</a>  </dd>
<dt><a class="anchor" id="_todo000006"></a>Member <a class="el" href="classnmodl_1_1codegen_1_1_codegen_c_visitor.html#a8b5f03d4eb3ca7c7d42fa53f13d187ff">nmodl::codegen::CodegenCVisitor::get_shadow_variables</a>  ()</dt>
<dd>If conductances are specified, we don't need all below variables  </dd>
<dt><a class="anchor" id="_todo000009"></a>Member <a class="el" href="classnmodl_1_1codegen_1_1_codegen_c_visitor.html#a663d2f8fd8896237c2fe4e2129c2d41c">nmodl::codegen::CodegenCVisitor::internal_method_parameters</a>  ()</dt>
<dd>: figure out how to correctly handle qualifiers  </dd>
<dt><a class="anchor" id="_todo000004"></a>Member <a class="el" href="classnmodl_1_1codegen_1_1_codegen_c_visitor.html#a7670101a559b4d526b25f13196cfa408">nmodl::codegen::CodegenCVisitor::ion_read_statements</a>  (BlockType type)</dt>
<dd>After looking into mod2c and neuron implementation, it seems like Ode block type is not used (?). Need to look into implementation details.  </dd>
<dt><a class="anchor" id="_todo000005"></a>Member <a class="el" href="classnmodl_1_1codegen_1_1_codegen_c_visitor.html#a2c1de208a3367e4c4d5f64539ec0266d">nmodl::codegen::CodegenCVisitor::ion_write_statements</a>  (BlockType type)</dt>
<dd>Unhandled case in neuron implementation  </dd>
<dt><a class="anchor" id="_todo000008"></a>Member <a class="el" href="classnmodl_1_1codegen_1_1_codegen_c_visitor.html#ac959bf153ca7a5b0626168dc695b8925">nmodl::codegen::CodegenCVisitor::print_check_table_thread_function</a>  ()</dt>
<dd><code>check_table_thread</code> is called multiple times from coreneuron including after <code>finitialize</code>. If we cleaup the instance then it will result in segfault but if we don't then there is memory leak  </dd>
<dt><a class="anchor" id="_todo000014"></a>Member <a class="el" href="classnmodl_1_1codegen_1_1_codegen_c_visitor.html#a737b67ce688bf96673476412b7b9c700">nmodl::codegen::CodegenCVisitor::print_derivimplicit_kernel</a>  (<a class="el" href="classnmodl_1_1ast_1_1_block.html" title="Base class for all block scoped nodes. ">ast::Block</a> *block)</dt>
<dd><p class="startdd">Data is not derived.</p>
<p class="enddd">To be backward compatible with mod2c we have to generate below comment marker in the generated cpp file for kinderiv.py to process it and generate correct _kinderiv.h  </p>
</dd>
<dt><a class="anchor" id="_todo000016"></a>Member <a class="el" href="classnmodl_1_1codegen_1_1_codegen_c_visitor.html#a70f1e7264b4d6c34f360bf1090f02762">nmodl::codegen::CodegenCVisitor::print_nrn_state</a>  ()</dt>
<dd>Eigen solver node also emits IonCurVar variable in the functor but that shouldn't update ions in derivative block  </dd>
<dt><a class="anchor" id="_todo000011"></a>Member <a class="el" href="classnmodl_1_1codegen_1_1_codegen_c_visitor.html#a15b0fe5be3be21ef57230f75179d1668">nmodl::codegen::CodegenCVisitor::print_watch_activate</a>  ()</dt>
<dd><p class="startdd">Number of watch could be more than number of statements according to grammar.</p>
<p class="enddd">Similar to neuron/coreneuron we are using first watch and ignoring rest.  </p>
</dd>
<dt><a class="anchor" id="_todo000013"></a>Member <a class="el" href="classnmodl_1_1codegen_1_1_codegen_c_visitor.html#ad88e5cd8f4605308d18e0fa9dd8c135d">nmodl::codegen::CodegenCVisitor::print_watch_check</a>  ()</dt>
<dd>Similar to print_watch_activate, we are using only first watch. </dd>
<dt><a class="anchor" id="_todo000010"></a>Member <a class="el" href="classnmodl_1_1codegen_1_1_codegen_c_visitor.html#ab81c255c3616a2c95c74cc4ebcb27be2">nmodl::codegen::CodegenCVisitor::process_verbatim_text</a>  (std::string text)</dt>
<dd>: this is still ad-hoc and requires re-implementation to handle it more elegantly.  </dd>
<dt><a class="anchor" id="_todo000007"></a>Member <a class="el" href="classnmodl_1_1codegen_1_1_codegen_c_visitor.html#a649ccf2ba93cc50a6dc86450e7ca064c">nmodl::codegen::CodegenCVisitor::rename_function_arguments</a>  ()</dt>
<dd>Issue with verbatim renaming. </dd>
<dt><a class="anchor" id="_todo000003"></a>Member <a class="el" href="classnmodl_1_1codegen_1_1_codegen_c_visitor.html#a17a43644435290b1a799b97571ff45a8">nmodl::codegen::CodegenCVisitor::visit_var_name</a>  (const <a class="el" href="classnmodl_1_1ast_1_1_var_name.html" title="Represents a variable. ">ast::VarName</a> &amp;node) override</dt>
<dd>: Validate how @ is being handled in neuron implementation  </dd>
<dt><a class="anchor" id="_todo000022"></a>Class <a class="el" href="classnmodl_1_1codegen_1_1_codegen_helper_visitor.html">nmodl::codegen::CodegenHelperVisitor</a>  </dt>
<dd><ul>
<li>Determine <code>vectorize</code> as part of the pass</li>
<li>Determine <code>threadsafe</code> as part of the pass</li>
<li>Global variable order is not preserved, for example, below gives different order:<ul>
<li>NEURON block: GLOBAL gq, gp</li>
<li>PARAMETER block: gp = 11, gq[2]</li>
</ul>
</li>
<li>POINTER rng and if it's also assigned rng[4] then it is printed as one value. Need to check what is correct value.  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000020"></a>Member <a class="el" href="classnmodl_1_1codegen_1_1_codegen_helper_visitor.html#adaa15452418bc8a98d8a205e8fcfb110">nmodl::codegen::CodegenHelperVisitor::find_non_range_variables</a>  ()</dt>
<dd>Below we calculate thread related id and sizes. This will need to do from global analysis pass as here we are handling top local variables, global variables, derivimplicit method. There might be more use cases with other solver methods.  </dd>
<dt><a class="anchor" id="_todo000021"></a>Member <a class="el" href="classnmodl_1_1codegen_1_1_codegen_helper_visitor.html#ab0efef492595d0e818b6ad5ab50ea595">nmodl::codegen::CodegenHelperVisitor::visit_statement_block</a>  (const <a class="el" href="classnmodl_1_1ast_1_1_statement_block.html" title="Represents block encapsulating list of statements. ">ast::StatementBlock</a> &amp;node) override</dt>
<dd>AST can have duplicate DERIVATIVE blocks if a mod file uses SOLVE statements in its INITIAL block (e.g. in case of kinetic schemes using <code>STEADYSTATE sparse</code> solver). Such duplicated DERIVATIVE blocks could be removed by <code>SolveBlockVisitor</code>, or we have to avoid visiting them here. See e.g. SH_na8st.mod test and original reduced_dentate .mod.  </dd>
<dt><a class="anchor" id="_todo000023"></a>Class <a class="el" href="structnmodl_1_1codegen_1_1_codegen_info.html">nmodl::codegen::CodegenInfo</a>  </dt>
<dd>Need to store all Define i.e. macro definitions?  </dd>
<dt><a class="anchor" id="_todo000024"></a>Member <a class="el" href="namespacenmodl_1_1codegen_1_1naming.html#a86a9d3a0e50e4b2647e45c1ea5fd2e07">nmodl::codegen::naming::NMODL_VERSION</a>  []</dt>
<dd>: should be moved from codegen to global scope  </dd>
<dt><a class="anchor" id="_todo000017"></a>Class <a class="el" href="structnmodl_1_1codegen_1_1_shadow_use_statement.html">nmodl::codegen::ShadowUseStatement</a>  </dt>
<dd>If shadow_lhs is empty then we assume shadow statement not required  </dd>
<dt><a class="anchor" id="_todo000028"></a>Member <a class="el" href="namespacenmodl_1_1details.html#af8848d52bfe6c5128bb476ac5c604563">nmodl::details::keywords</a>  </dt>
<dd>Some keywords have different token names, e.g. TITLE keyword has MODEL as a keyword. These token names are used in multiple context and hence we are keeping original names. Once we finish code generation part then we change this.  </dd>
<dt><a class="anchor" id="_todo000029"></a>Member <a class="el" href="namespacenmodl_1_1details.html#a7f29649995b2bc1d04ba4314e71afcb4">nmodl::details::methods</a>  </dt>
<dd><a class="el" href="structnmodl_1_1details_1_1_method_info.html#aeab10f5665538150a35f61b30b71e64b" title="block types where this method will work with ">MethodInfo::subtype</a> should be changed from integer flag to proper type  </dd>
<dt><a class="anchor" id="_todo000026"></a>Class <a class="el" href="classnmodl_1_1_mod_token.html">nmodl::ModToken</a>  </dt>
<dd><ul>
<li><a class="el" href="classnmodl_1_1_mod_token.html#a5edc9d18c2001be5017e2e2afc484ae1">LocationType</a> object is copyable except if we specify the stream name. It would be good to track filename when we go for multi-channel optimization and code generation. </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000027"></a>Member <a class="el" href="namespacenmodl.html#aa7c0916e51ccaf5779b7db1d1cd9fd8d">nmodl::name_symbol</a>  (const std::string &amp;text, PositionType &amp;pos, TokenType type)</dt>
<dd>In addition to keywords and methods, there are also external definitions for math and neuron specific functions/variables. In the token we should mark those as external.  </dd>
<dt><a class="anchor" id="_todo000034"></a>Namespace <a class="el" href="namespacenmodl_1_1parser_1_1diffeq.html">nmodl::parser::diffeq</a>  </dt>
<dd>The implementations here are verbose and has duplicate code. Need to revisit this, may be using better library like symengine altogether.  </dd>
<dt><a class="anchor" id="_todo000032"></a>Member <a class="el" href="classnmodl_1_1parser_1_1diffeq_1_1_diff_eq_context.html#ae54e71ef0da95411bf97f69e456da2d7">nmodl::parser::diffeq::DiffEqContext::cvode_deriv</a>  () const</dt>
<dd>Methods inherited neuron implementation  </dd>
<dt><a class="anchor" id="_todo000030"></a>Member <a class="el" href="classnmodl_1_1parser_1_1diffeq_1_1_diff_eq_context.html#a8c0e2e1e95d94888911b16a94c5c1421">nmodl::parser::diffeq::DiffEqContext::get_solution</a>  (bool &amp;cnexp_possible)</dt>
<dd>Currently we have tested cnexp, euler and derivimplicit methods with all equations from BBP models. Need to test this against various other mod files, especially kinetic schemes, reaction-diffusion etc.  </dd>
<dt><a class="anchor" id="_todo000031"></a>Member <a class="el" href="structnmodl_1_1parser_1_1diffeq_1_1_term.html#a405c13be238d68f836a1f118f6407991">nmodl::parser::diffeq::Term::a</a>  </dt>
<dd>Need to check in neuron implementation?  </dd>
<dt><a class="anchor" id="_todo000033"></a>Member <a class="el" href="classnmodl_1_1parser_1_1_diffeq_driver.html#ab89e4d42c0781358310684a3d5fc59ae">nmodl::parser::DiffeqDriver::cnexp_possible</a>  (const std::string &amp;equation, std::string &amp;solution)</dt>
<dd>Instead of using neuron like api, we need to refactor  </dd>
<dt><a class="anchor" id="_todo000035"></a>Class <a class="el" href="classnmodl_1_1parser_1_1_nmodl_driver.html">nmodl::parser::NmodlDriver</a>  </dt>
<dd><p class="startdd">Lexer, parser and ast member variables are used inside lexer/ parser instances. The local instaces are created inside parse_stream and hence the pointers are no longer valid except ast. Need better way to handle this.</p>
<p class="enddd">Stream name is not used as it will need better support as location object used in scanner takes string pointer which could be invalid when we copy location object.  </p>
</dd>
<dt><a class="anchor" id="_todo000037"></a>Class <a class="el" href="classnmodl_1_1printer_1_1_j_s_o_n_printer.html">nmodl::printer::JSONPrinter</a>  </dt>
<dd>We need to explicitly call <code><a class="el" href="classnmodl_1_1printer_1_1_j_s_o_n_printer.html#a0fafa2042d3c4868e7571614702b9d00" title="Dump json object to stream (typically at the end) nspaces is number of spaces used for indentation...">flush()</a></code> in order to get write/return results. We simply can't dump block in <code>popBlock()</code> because block itself will be part of other parent elements. Also we are writing results to file, <code>stringstream</code> and <code>cout</code>. And hence we can't simply reset/clear previously written text.  </dd>
<dt><a class="anchor" id="_todo000038"></a>Class <a class="el" href="classnmodl_1_1printer_1_1_n_m_o_d_l_printer.html">nmodl::printer::NMODLPrinter</a>  </dt>
<dd>Implement Printer as base class to avoid duplication code between <a class="el" href="classnmodl_1_1printer_1_1_j_s_o_n_printer.html" title="Helper class for printing AST in JSON form. ">JSONPrinter</a> and <a class="el" href="classnmodl_1_1printer_1_1_n_m_o_d_l_printer.html" title="Helper class for printing AST back to NMDOL test. ">NMODLPrinter</a>.  </dd>
<dt><a class="anchor" id="_todo000045"></a>Class <a class="el" href="classnmodl_1_1symtab_1_1_model_symbol_table.html">nmodl::symtab::ModelSymbolTable</a>  </dt>
<dd>Unique name should be based on location. Use <a class="el" href="classnmodl_1_1_mod_token.html" title="Represent token returned by scanner. ">ModToken</a> to get position.  </dd>
<dt><a class="anchor" id="_todo000043"></a>Member <a class="el" href="classnmodl_1_1symtab_1_1_model_symbol_table.html#a830dc2c0db6cba986b58d977996d0b3e">nmodl::symtab::ModelSymbolTable::get_unique_name</a>  (const std::string &amp;name, <a class="el" href="structnmodl_1_1ast_1_1_ast.html" title="Base class for all Abstract Syntax Tree node types. ">ast::Ast</a> *node, bool is_global)</dt>
<dd>We should add position information to make name unique  </dd>
<dt><a class="anchor" id="_todo000039"></a>Class <a class="el" href="classnmodl_1_1symtab_1_1_symbol.html">nmodl::symtab::Symbol</a>  </dt>
<dd><ul>
<li>Multiple tokens (i.e. location information) for symbol should be tracked</li>
<li>Scope information should be more than just string</li>
<li>Perf block should track information about all usage of the symbol (would be helpful for perf modeling)</li>
<li>Need to keep track of all renaming information, currently only we keep last state  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000040"></a>Member <a class="el" href="classnmodl_1_1symtab_1_1_symbol.html#aea4355d4eb499282cfcad1b29372efd3">nmodl::symtab::Symbol::is_external_variable</a>  () const noexcept</dt>
<dd>Need to check if we should check two properties using has_any_property instead of exact comparison </dd>
<dt><a class="anchor" id="_todo000044"></a>Class <a class="el" href="classnmodl_1_1symtab_1_1_symbol_table.html">nmodl::symtab::SymbolTable</a>  </dt>
<dd><ul>
<li>Revisit when clone method is used and implementation of copy constructor</li>
<li>Name may not require as we have added AST node  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000047"></a>Member <a class="el" href="classnmodl_1_1symtab_1_1_symbol_table.html#ae49ad8e70534f29f561207e43ff201b5">nmodl::symtab::SymbolTable::clone</a>  ()</dt>
<dd>Revisit the usage as tokens will be pointing to old nodes  </dd>
<dt><a class="anchor" id="_todo000046"></a>Class <a class="el" href="classnmodl_1_1symtab_1_1_symbol_table_1_1_table.html">nmodl::symtab::SymbolTable::Table</a>  </dt>
<dd>Re-implement pretty printing  </dd>
<dt><a class="anchor" id="_todo000041"></a>Member <a class="el" href="namespacenmodl_1_1symtab_1_1syminfo.html#ae05efbc3da8258a5240bcb2d605efaef">nmodl::symtab::syminfo::enum_type</a>  </dt>
<dd>Error with pybind if std::underlying_typ is used  </dd>
<dt><a class="anchor" id="_todo000042"></a>Member <a class="el" href="namespacenmodl_1_1symtab_1_1syminfo.html#ad9b6b8559b36d0a500ef5110badcc4db">nmodl::symtab::syminfo::NmodlType</a>  </dt>
<dd><ul>
<li>Rename param_assign to parameter_var  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000064"></a>Member <a class="el" href="structnmodl_1_1test__utils_1_1_nmodl_test_case.html#a50cbab8eb69dbd5808d7da31e983dfde">nmodl::test_utils::NmodlTestCase::NmodlTestCase</a>  ()=delete</dt>
<dd>: add associated json (to use in visitor test)  </dd>
<dt><a class="anchor" id="_todo000062"></a>Member <a class="el" href="namespacenmodl_1_1visitor.html#a93218c244f2658370e096935410f2c42">nmodl::visitor::create_statement</a>  (const std::string &amp;code_statement)</dt>
<dd>Need to revisit this during code generation passes to make sure if all statements can be part of procedure block.  </dd>
<dt><a class="anchor" id="_todo000048"></a>Member <a class="el" href="classnmodl_1_1visitor_1_1_def_use_analyze_visitor.html#a9c55e7d17ed48d0d64b8acb1dd4cc060">nmodl::visitor::DefUseAnalyzeVisitor::visit_verbatim</a>  (const <a class="el" href="classnmodl_1_1ast_1_1_verbatim.html" title="Represents a C code block. ">ast::Verbatim</a> &amp;node) override</dt>
<dd>One simple way would be to look for p_name in the string of verbatim block to find the variable usage.  </dd>
<dt><a class="anchor" id="_todo000051"></a>Class <a class="el" href="classnmodl_1_1visitor_1_1_inline_visitor.html">nmodl::visitor::InlineVisitor</a>  </dt>
<dd><ul>
<li>Recursive function calls are not supported and need to add checks to avoid stack explosion</li>
<li>Currently we rename variables more than necessary, this could be improved [low priority]</li>
<li>Function calls as part of an argument of function call itself are not completely inlined [low priority]</li>
<li>Symbol table pass needs to be re-run in order to update the definitions/usage</li>
<li>Location of symbol/nodes after inlining still points to old nodes  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000049"></a>Member <a class="el" href="classnmodl_1_1visitor_1_1_inline_visitor.html#aec884c3dd17991a7fb6a4ae7e2d19eb4">nmodl::visitor::InlineVisitor::can_replace_statement</a>  (const std::shared_ptr&lt; ast::Statement &gt; &amp;statement)</dt>
<dd>Add method to ast itself to simplify this implementation  </dd>
<dt><a class="anchor" id="_todo000050"></a>Member <a class="el" href="classnmodl_1_1visitor_1_1_inline_visitor.html#a3ee1887842a2e1379f0510971f4c3933">nmodl::visitor::InlineVisitor::inline_function_call</a>  (<a class="el" href="classnmodl_1_1ast_1_1_block.html" title="Base class for all block scoped nodes. ">ast::Block</a> &amp;callee, <a class="el" href="classnmodl_1_1ast_1_1_function_call.html" title="TODO. ">ast::FunctionCall</a> &amp;node, <a class="el" href="classnmodl_1_1ast_1_1_statement_block.html" title="Represents block encapsulating list of statements. ">ast::StatementBlock</a> &amp;caller)</dt>
<dd>Have to re-run symtab visitor pass to update symbol table  </dd>
<dt><a class="anchor" id="_todo000056"></a>Class <a class="el" href="classnmodl_1_1visitor_1_1_localize_visitor.html">nmodl::visitor::LocalizeVisitor</a>  </dt>
<dd><ul>
<li>We are excluding procedures/functions because they will be still using global variables. We need to have dead-code removal pass to eliminate unused procedures/ functions before localizer pass.  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000054"></a>Member <a class="el" href="classnmodl_1_1visitor_1_1_localize_visitor.html#ad865a0eb75ee7212520bfc092162f188">nmodl::visitor::LocalizeVisitor::variables_to_optimize</a>  () const</dt>
<dd><p class="startdd">Voltage v can be global variable as well as external. In order to avoid optimizations, we need to handle this case properly </p>
<p class="enddd">Instead of ast node, use symbol properties to check variable type  </p>
</dd>
<dt><a class="anchor" id="_todo000052"></a>Class <a class="el" href="classnmodl_1_1visitor_1_1_local_to_assigned_visitor.html">nmodl::visitor::LocalToAssignedVisitor</a>  </dt>
<dd><ul>
<li>Variables like qt are often constant. As long as INITIAL block is executed serially or qt is updated in atomic way then we don't have a problem.  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000053"></a>Class <a class="el" href="classnmodl_1_1visitor_1_1_local_var_rename_visitor.html">nmodl::visitor::LocalVarRenameVisitor</a>  </dt>
<dd><ul>
<li>Currently we are renaming variables even if there is no inlining candidates. In this case ideally we should not rename.  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000057"></a>Class <a class="el" href="classnmodl_1_1visitor_1_1_perf_visitor.html">nmodl::visitor::PerfVisitor</a>  </dt>
<dd><ul>
<li>To measure the performance of statements like if, elseif and else, we have to find maximum performance from if,elseif,else and then use it to calculate total performance. In the current implementation we are doing sum of all blocks. We need to override IfStatement (which has all sub-blocks) and get maximum performance of all statements recursively. </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000058"></a>Class <a class="el" href="classnmodl_1_1visitor_1_1_rename_visitor.html">nmodl::visitor::RenameVisitor</a>  </dt>
<dd>Add log/warning messages.  </dd>
<dt><a class="anchor" id="_todo000059"></a>Member <a class="el" href="classnmodl_1_1visitor_1_1_symtab_visitor.html#acecb22d0c928ea76b67abef5e83b989d">nmodl::visitor::SymtabVisitor::visit_table_statement</a>  (<a class="el" href="classnmodl_1_1ast_1_1_table_statement.html" title="Represents TABLE statement in NMODL. ">ast::TableStatement</a> &amp;node) override</dt>
<dd>we assume table statement follows variable declaration  </dd>
<dt><a class="anchor" id="_todo000060"></a>Class <a class="el" href="classnmodl_1_1visitor_1_1_var_usage_visitor.html">nmodl::visitor::VarUsageVisitor</a>  </dt>
<dd>Check if macro is considered as variable  </dd>
<dt><a class="anchor" id="_todo000061"></a>Class <a class="el" href="classnmodl_1_1visitor_1_1_verbatim_var_rename_visitor.html">nmodl::visitor::VerbatimVarRenameVisitor</a>  </dt>
<dd>Check if symbol table lookup is ok or there are cases where this could be error prone.  </dd>
<dt><a class="anchor" id="_todo000063"></a>Member <a class="el" href="test_2unit_2symtab_2symbol__table_8cpp.html#a780700b9cd74cc6da7faa0250d3e64d5">SCENARIO</a>  ("Global symbol table (ModelSymbol) allows scope based operations")</dt>
<dd>: not sure how to capture std::cout </dd>
</dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<div id="nav-path" class="navpath">
  <ul>
  </ul>
</div>
<hr class="footer"/>
<address class="footer">
    <small>
    </small>
</address>
<!--END !GENERATE_TREEVIEW-->
</body>
</html>
