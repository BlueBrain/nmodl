<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>User Guide: nmodl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_nmodl.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">User Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacenmodl.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">nmodl Namespace Reference<div class="ingroups"><a class="el" href="group__visitor.html">Visitor Implementation</a> &raquo; <a class="el" href="group__visitor__classes.html">Visitors</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>encapsulates everything related to NMODL code generation framework  
<a href="namespacenmodl.html#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>encapsulates everything related to NMODL code generation framework </p>
<p>THIS FILE IS GENERATED AT BUILD TIME AND SHALL NOT BE EDITED. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacenmodl_1_1ast"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl_1_1ast.html">ast</a></td></tr>
<tr class="memdesc:namespacenmodl_1_1ast"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract Syntax Tree (AST) related implementations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacenmodl_1_1codegen"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl_1_1codegen.html">codegen</a></td></tr>
<tr class="memdesc:namespacenmodl_1_1codegen"><td class="mdescLeft">&#160;</td><td class="mdescRight">encapsulates code generation backend implementations <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacenmodl_1_1details"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl_1_1details.html">details</a></td></tr>
<tr class="memdesc:namespacenmodl_1_1details"><td class="mdescLeft">&#160;</td><td class="mdescRight">details of lexer tokens <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacenmodl_1_1docstring"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl_1_1docstring.html">docstring</a></td></tr>
<tr class="memdesc:namespacenmodl_1_1docstring"><td class="mdescLeft">&#160;</td><td class="mdescRight">docstring of Python exposed API <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacenmodl_1_1fast__math"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl_1_1fast__math.html">fast_math</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacenmodl_1_1newton"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl_1_1newton.html">newton</a></td></tr>
<tr class="memdesc:namespacenmodl_1_1newton"><td class="mdescLeft">&#160;</td><td class="mdescRight">newton solver implementations <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacenmodl_1_1parser"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl_1_1parser.html">parser</a></td></tr>
<tr class="memdesc:namespacenmodl_1_1parser"><td class="mdescLeft">&#160;</td><td class="mdescRight">encapsulate lexer and parsers implementations <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacenmodl_1_1printer"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl_1_1printer.html">printer</a></td></tr>
<tr class="memdesc:namespacenmodl_1_1printer"><td class="mdescLeft">&#160;</td><td class="mdescRight">implementation of various printers <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacenmodl_1_1pybind__wrappers"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl_1_1pybind__wrappers.html">pybind_wrappers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacenmodl_1_1stringutils"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl_1_1stringutils.html">stringutils</a></td></tr>
<tr class="memdesc:namespacenmodl_1_1stringutils"><td class="mdescLeft">&#160;</td><td class="mdescRight">string utility functions <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacenmodl_1_1symtab"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl_1_1symtab.html">symtab</a></td></tr>
<tr class="memdesc:namespacenmodl_1_1symtab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol table related implementations <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacenmodl_1_1test__utils"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl_1_1test__utils.html">test_utils</a></td></tr>
<tr class="memdesc:namespacenmodl_1_1test__utils"><td class="mdescLeft">&#160;</td><td class="mdescRight">custom type to represent nmodl construct for testing <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacenmodl_1_1units"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl_1_1units.html">units</a></td></tr>
<tr class="memdesc:namespacenmodl_1_1units"><td class="mdescLeft">&#160;</td><td class="mdescRight">encapsulates unit database and tables implementation <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacenmodl_1_1utils"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl_1_1utils.html">utils</a></td></tr>
<tr class="memdesc:namespacenmodl_1_1utils"><td class="mdescLeft">&#160;</td><td class="mdescRight">file/string manipulation functions <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacenmodl_1_1visitor"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl_1_1visitor.html">visitor</a></td></tr>
<tr class="memdesc:namespacenmodl_1_1visitor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of different AST visitors. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnmodl_1_1_file_library.html">FileLibrary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manage search path.  <a href="classnmodl_1_1_file_library.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnmodl_1_1_logger.html">Logger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structnmodl_1_1_logger.html" title="Logger implementation based on spdlog.">Logger</a> implementation based on spdlog.  <a href="structnmodl_1_1_logger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnmodl_1_1_mod_token.html">ModToken</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent token returned by scanner.  <a href="classnmodl_1_1_mod_token.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnmodl_1_1_nrn_units_lib.html">NrnUnitsLib</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information of units database i.e.  <a href="structnmodl_1_1_nrn_units_lib.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnmodl_1_1_py_nmodl_driver.html">PyNmodlDriver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to bridge C++ NmodlDriver with Python world using pybind11.  <a href="classnmodl_1_1_py_nmodl_driver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnmodl_1_1_version.html">Version</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project version information.  <a href="structnmodl_1_1_version.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0c663295fbb20d83eced620b438408e1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl.html#a0c663295fbb20d83eced620b438408e1">LocationType</a> = nmodl::parser::location</td></tr>
<tr class="separator:a0c663295fbb20d83eced620b438408e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f67a7446a31513983f9ada8596296ab"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl.html#a7f67a7446a31513983f9ada8596296ab">Parser</a> = parser::NmodlParser</td></tr>
<tr class="separator:a7f67a7446a31513983f9ada8596296ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1d0349c5a29bed1dd6bb012345c0e4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl.html#add1d0349c5a29bed1dd6bb012345c0e4">PositionType</a> = parser::location</td></tr>
<tr class="separator:add1d0349c5a29bed1dd6bb012345c0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21403ee2d75755a88023abc4ca9bc9a9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl.html#a21403ee2d75755a88023abc4ca9bc9a9">SymbolType</a> = <a class="el" href="group__token__test.html#ga752aa45201ab43cc2d13b3ce5a5f1144">parser::NmodlParser::symbol_type</a></td></tr>
<tr class="separator:a21403ee2d75755a88023abc4ca9bc9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4247bc09fd496e5015912ef0382a5e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl.html#a5f4247bc09fd496e5015912ef0382a5e">Token</a> = parser::NmodlParser::token</td></tr>
<tr class="separator:a5f4247bc09fd496e5015912ef0382a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a18ff49e1535de813a7f86968f6ae5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl.html#a84a18ff49e1535de813a7f86968f6ae5">TokenType</a> = parser::NmodlParser::token_type</td></tr>
<tr class="separator:a84a18ff49e1535de813a7f86968f6ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e6b3d1235030c67add793cc98ab7b3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl.html#a55e6b3d1235030c67add793cc98ab7b3">logger_type</a> = std::shared_ptr&lt; spdlog::logger &gt;</td></tr>
<tr class="separator:a55e6b3d1235030c67add793cc98ab7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4aedc321d8c19da4f629ebc04ffc877d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl.html#a4aedc321d8c19da4f629ebc04ffc877d">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="classnmodl_1_1_mod_token.html">ModToken</a> &amp;mt)</td></tr>
<tr class="separator:a4aedc321d8c19da4f629ebc04ffc877d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf4c8aaed9573bc39d71c41957f9bf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnmodl_1_1_mod_token.html">ModToken</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl.html#a0cf4c8aaed9573bc39d71c41957f9bf6">operator+</a> (<a class="el" href="classnmodl_1_1_mod_token.html">ModToken</a> adder1, <a class="el" href="classnmodl_1_1_mod_token.html">ModToken</a> adder2)</td></tr>
<tr class="separator:a0cf4c8aaed9573bc39d71c41957f9bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d9bcd28e4833ee993affb599e070ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenmodl.html#a21403ee2d75755a88023abc4ca9bc9a9">SymbolType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl.html#ab5d9bcd28e4833ee993affb599e070ca">double_symbol</a> (const std::string &amp;value, <a class="el" href="namespacenmodl.html#add1d0349c5a29bed1dd6bb012345c0e4">PositionType</a> &amp;pos)</td></tr>
<tr class="memdesc:ab5d9bcd28e4833ee993affb599e070ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a symbol for <a class="el" href="classnmodl_1_1ast_1_1_double.html" title="Represents a double variable.">ast::Double</a> AST class.  <a href="namespacenmodl.html#ab5d9bcd28e4833ee993affb599e070ca">More...</a><br /></td></tr>
<tr class="separator:ab5d9bcd28e4833ee993affb599e070ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1bae1bfa39b1ff514d3a894b9513eb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenmodl.html#a21403ee2d75755a88023abc4ca9bc9a9">SymbolType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl.html#ae1bae1bfa39b1ff514d3a894b9513eb4">integer_symbol</a> (int value, <a class="el" href="namespacenmodl.html#add1d0349c5a29bed1dd6bb012345c0e4">PositionType</a> &amp;pos, const char *text)</td></tr>
<tr class="memdesc:ae1bae1bfa39b1ff514d3a894b9513eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a symbol for <a class="el" href="classnmodl_1_1ast_1_1_integer.html" title="Represents an integer variable.">ast::Integer</a> AST.  <a href="namespacenmodl.html#ae1bae1bfa39b1ff514d3a894b9513eb4">More...</a><br /></td></tr>
<tr class="separator:ae1bae1bfa39b1ff514d3a894b9513eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c0916e51ccaf5779b7db1d1cd9fd8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenmodl.html#a21403ee2d75755a88023abc4ca9bc9a9">SymbolType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl.html#aa7c0916e51ccaf5779b7db1d1cd9fd8d">name_symbol</a> (const std::string &amp;text, <a class="el" href="namespacenmodl.html#add1d0349c5a29bed1dd6bb012345c0e4">PositionType</a> &amp;pos, <a class="el" href="namespacenmodl.html#a84a18ff49e1535de813a7f86968f6ae5">TokenType</a> type)</td></tr>
<tr class="memdesc:aa7c0916e51ccaf5779b7db1d1cd9fd8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create symbol for <a class="el" href="classnmodl_1_1ast_1_1_name.html" title="Represents a name.">ast::Name</a> AST class.  <a href="namespacenmodl.html#aa7c0916e51ccaf5779b7db1d1cd9fd8d">More...</a><br /></td></tr>
<tr class="separator:aa7c0916e51ccaf5779b7db1d1cd9fd8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08cfce6611cb5d2f80356e40a720fdf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenmodl.html#a21403ee2d75755a88023abc4ca9bc9a9">SymbolType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl.html#a08cfce6611cb5d2f80356e40a720fdf0">prime_symbol</a> (std::string text, <a class="el" href="namespacenmodl.html#add1d0349c5a29bed1dd6bb012345c0e4">PositionType</a> &amp;pos)</td></tr>
<tr class="memdesc:a08cfce6611cb5d2f80356e40a720fdf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create symbol for ast::Prime AST class.  <a href="namespacenmodl.html#a08cfce6611cb5d2f80356e40a720fdf0">More...</a><br /></td></tr>
<tr class="separator:a08cfce6611cb5d2f80356e40a720fdf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3f7ab91ca790e74f4d3196de33cc09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenmodl.html#a21403ee2d75755a88023abc4ca9bc9a9">SymbolType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl.html#ade3f7ab91ca790e74f4d3196de33cc09">string_symbol</a> (const std::string &amp;text, <a class="el" href="namespacenmodl.html#add1d0349c5a29bed1dd6bb012345c0e4">PositionType</a> &amp;pos)</td></tr>
<tr class="memdesc:ade3f7ab91ca790e74f4d3196de33cc09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create symbol for <a class="el" href="classnmodl_1_1ast_1_1_string.html" title="Represents a string.">ast::String</a> AST class.  <a href="namespacenmodl.html#ade3f7ab91ca790e74f4d3196de33cc09">More...</a><br /></td></tr>
<tr class="separator:ade3f7ab91ca790e74f4d3196de33cc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ac813a4b0304bdef3c4ab70ec37130"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenmodl.html#a21403ee2d75755a88023abc4ca9bc9a9">SymbolType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl.html#ae7ac813a4b0304bdef3c4ab70ec37130">token_symbol</a> (const std::string &amp;key, <a class="el" href="namespacenmodl.html#add1d0349c5a29bed1dd6bb012345c0e4">PositionType</a> &amp;pos, <a class="el" href="namespacenmodl.html#a84a18ff49e1535de813a7f86968f6ae5">TokenType</a> type)</td></tr>
<tr class="memdesc:ae7ac813a4b0304bdef3c4ab70ec37130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create symbol for AST class.  <a href="namespacenmodl.html#ae7ac813a4b0304bdef3c4ab70ec37130">More...</a><br /></td></tr>
<tr class="separator:ae7ac813a4b0304bdef3c4ab70ec37130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c6fbb1722584c4990afd054942b365"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl.html#ab8c6fbb1722584c4990afd054942b365">is_keyword</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ab8c6fbb1722584c4990afd054942b365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if given name is a keyword in NMODL.  <a href="namespacenmodl.html#ab8c6fbb1722584c4990afd054942b365">More...</a><br /></td></tr>
<tr class="separator:ab8c6fbb1722584c4990afd054942b365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1b1903ca3f4f531b67406da6b62ae6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl.html#a2d1b1903ca3f4f531b67406da6b62ae6">is_method</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a2d1b1903ca3f4f531b67406da6b62ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if given name is an integration method in NMODL.  <a href="namespacenmodl.html#a2d1b1903ca3f4f531b67406da6b62ae6">More...</a><br /></td></tr>
<tr class="separator:a2d1b1903ca3f4f531b67406da6b62ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1932dc8f598d068751391d892d439400"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenmodl.html#a84a18ff49e1535de813a7f86968f6ae5">TokenType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl.html#a1932dc8f598d068751391d892d439400">token_type</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a1932dc8f598d068751391d892d439400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return token type for given token name.  <a href="namespacenmodl.html#a1932dc8f598d068751391d892d439400">More...</a><br /></td></tr>
<tr class="separator:a1932dc8f598d068751391d892d439400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c6954ec1bd73d2f75c54d000d6aa85"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl.html#a14c6954ec1bd73d2f75c54d000d6aa85">get_external_variables</a> ()</td></tr>
<tr class="memdesc:a14c6954ec1bd73d2f75c54d000d6aa85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return variables declared in NEURON that are available to NMODL.  <a href="namespacenmodl.html#a14c6954ec1bd73d2f75c54d000d6aa85">More...</a><br /></td></tr>
<tr class="separator:a14c6954ec1bd73d2f75c54d000d6aa85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7711df7469359fc31a262c8c15dff311"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl.html#a7711df7469359fc31a262c8c15dff311">get_external_functions</a> ()</td></tr>
<tr class="memdesc:a7711df7469359fc31a262c8c15dff311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return functions that can be used in the NMODL.  <a href="namespacenmodl.html#a7711df7469359fc31a262c8c15dff311">More...</a><br /></td></tr>
<tr class="separator:a7711df7469359fc31a262c8c15dff311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d49270a6c751e2e1a0e2c2db0012e4d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; const <a class="el" href="structnmodl_1_1ast_1_1_ast.html">ast::Ast</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl.html#a0d49270a6c751e2e1a0e2c2db0012e4d">collect_nodes</a> (const <a class="el" href="structnmodl_1_1ast_1_1_ast.html">ast::Ast</a> &amp;node, const std::vector&lt; <a class="el" href="group__ast__type.html#gac392e49849e60c05e42ea02c7b445033">ast::AstNodeType</a> &gt; &amp;types={})</td></tr>
<tr class="memdesc:a0d49270a6c751e2e1a0e2c2db0012e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">traverse <em>node</em> recursively and collect nodes of given <em>types</em>  <a href="namespacenmodl.html#a0d49270a6c751e2e1a0e2c2db0012e4d">More...</a><br /></td></tr>
<tr class="separator:a0d49270a6c751e2e1a0e2c2db0012e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46adf69ad60da4329e7fa16b4c6df26b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="structnmodl_1_1ast_1_1_ast.html">ast::Ast</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl.html#a46adf69ad60da4329e7fa16b4c6df26b">collect_nodes</a> (<a class="el" href="structnmodl_1_1ast_1_1_ast.html">ast::Ast</a> &amp;node, const std::vector&lt; <a class="el" href="group__ast__type.html#gac392e49849e60c05e42ea02c7b445033">ast::AstNodeType</a> &gt; &amp;types={})</td></tr>
<tr class="memdesc:a46adf69ad60da4329e7fa16b4c6df26b"><td class="mdescLeft">&#160;</td><td class="mdescRight">traverse <em>node</em> recursively and collect nodes of given <em>types</em>  <a href="namespacenmodl.html#a46adf69ad60da4329e7fa16b4c6df26b">More...</a><br /></td></tr>
<tr class="separator:a46adf69ad60da4329e7fa16b4c6df26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21160c42746b7846b552e45572d8e083"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl.html#a21160c42746b7846b552e45572d8e083">sparse_solver_exists</a> (const <a class="el" href="structnmodl_1_1ast_1_1_ast.html">ast::Ast</a> &amp;node)</td></tr>
<tr class="separator:a21160c42746b7846b552e45572d8e083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f3383905bcc82c616483bc5c9f8c21"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl.html#a60f3383905bcc82c616483bc5c9f8c21">to_nmodl</a> (const <a class="el" href="structnmodl_1_1ast_1_1_ast.html">ast::Ast</a> &amp;node, const std::set&lt; <a class="el" href="group__ast__type.html#gac392e49849e60c05e42ea02c7b445033">ast::AstNodeType</a> &gt; &amp;exclude_types={})</td></tr>
<tr class="memdesc:a60f3383905bcc82c616483bc5c9f8c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given AST node, return the NMODL string representation.  <a href="namespacenmodl.html#a60f3383905bcc82c616483bc5c9f8c21">More...</a><br /></td></tr>
<tr class="separator:a60f3383905bcc82c616483bc5c9f8c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4004b62c9ab28101181960aefda0d8e7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl.html#a4004b62c9ab28101181960aefda0d8e7">to_json</a> (const <a class="el" href="structnmodl_1_1ast_1_1_ast.html">ast::Ast</a> &amp;node, bool compact=false, bool expand=false, bool add_nmodl=false)</td></tr>
<tr class="memdesc:a4004b62c9ab28101181960aefda0d8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given AST node, return the JSON string representation.  <a href="namespacenmodl.html#a4004b62c9ab28101181960aefda0d8e7">More...</a><br /></td></tr>
<tr class="separator:a4004b62c9ab28101181960aefda0d8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf829797d75f00f7307a89776d9d735"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, std::unordered_set&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl.html#a1cf829797d75f00f7307a89776d9d735">statement_dependencies</a> (const std::shared_ptr&lt; <a class="el" href="classnmodl_1_1ast_1_1_expression.html">ast::Expression</a> &gt; &amp;lhs, const std::shared_ptr&lt; <a class="el" href="classnmodl_1_1ast_1_1_expression.html">ast::Expression</a> &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a1cf829797d75f00f7307a89776d9d735"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>lhs</code> and <code>rhs</code> combined represent an assignment (we assume to have an "=" in between them) we extract the variables on which the assigned variable depends on.  <a href="namespacenmodl.html#a1cf829797d75f00f7307a89776d9d735">More...</a><br /></td></tr>
<tr class="separator:a1cf829797d75f00f7307a89776d9d735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b20bd823506ecccb7c2c79d5b153f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl.html#a63b20bd823506ecccb7c2c79d5b153f2">get_indexed_name</a> (const <a class="el" href="classnmodl_1_1ast_1_1_indexed_name.html">ast::IndexedName</a> &amp;node)</td></tr>
<tr class="memdesc:a63b20bd823506ecccb7c2c79d5b153f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a Indexed node, return the name with index.  <a href="namespacenmodl.html#a63b20bd823506ecccb7c2c79d5b153f2">More...</a><br /></td></tr>
<tr class="separator:a63b20bd823506ecccb7c2c79d5b153f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f5a4e348e6aae405a2087dc9b003cb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl.html#a65f5a4e348e6aae405a2087dc9b003cb">get_full_var_name</a> (const <a class="el" href="classnmodl_1_1ast_1_1_var_name.html">ast::VarName</a> &amp;node)</td></tr>
<tr class="memdesc:a65f5a4e348e6aae405a2087dc9b003cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a VarName node, return the full var name including index.  <a href="namespacenmodl.html#a65f5a4e348e6aae405a2087dc9b003cb">More...</a><br /></td></tr>
<tr class="separator:a65f5a4e348e6aae405a2087dc9b003cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457c69d76cbb7d9318af1fc030946326"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a457c69d76cbb7d9318af1fc030946326"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="structnmodl_1_1ast_1_1_ast.html">ast::Ast</a>, T &gt;::value, std::string &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenmodl.html#a457c69d76cbb7d9318af1fc030946326">to_nmodl</a> (const std::shared_ptr&lt; T &gt; &amp;node, const std::set&lt; <a class="el" href="group__ast__type.html#gac392e49849e60c05e42ea02c7b445033">ast::AstNodeType</a> &gt; &amp;exclude_types={})</td></tr>
<tr class="memdesc:a457c69d76cbb7d9318af1fc030946326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a shared pointer to an AST node, return the NMODL string representation.  <a href="namespacenmodl.html#a457c69d76cbb7d9318af1fc030946326">More...</a><br /></td></tr>
<tr class="separator:a457c69d76cbb7d9318af1fc030946326"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a447a341fe15e3ab162b9651c64c3ef09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnmodl_1_1_logger.html">Logger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl.html#a447a341fe15e3ab162b9651c64c3ef09">nmodl_logger</a> (&quot;NMODL&quot;, &quot;[%n] [%^%l%$] :: %v&quot;)</td></tr>
<tr class="separator:a447a341fe15e3ab162b9651c64c3ef09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f087e40d0134fa62ba1dbc48dc2462b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenmodl.html#a55e6b3d1235030c67add793cc98ab7b3">logger_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenmodl.html#a6f087e40d0134fa62ba1dbc48dc2462b">logger</a> = nmodl_logger.logger</td></tr>
<tr class="separator:a6f087e40d0134fa62ba1dbc48dc2462b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a0c663295fbb20d83eced620b438408e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c663295fbb20d83eced620b438408e1">&#9670;&nbsp;</a></span>LocationType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenmodl.html#a0c663295fbb20d83eced620b438408e1">nmodl::LocationType</a> = typedef nmodl::parser::location</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="src_2lexer_2modtoken_8cpp_source.html#l00017">17</a> of file <a class="el" href="src_2lexer_2modtoken_8cpp_source.html">modtoken.cpp</a>.</p>

</div>
</div>
<a id="a55e6b3d1235030c67add793cc98ab7b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e6b3d1235030c67add793cc98ab7b3">&#9670;&nbsp;</a></span>logger_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt; spdlog::logger &gt; <a class="el" href="namespacenmodl.html#a55e6b3d1235030c67add793cc98ab7b3">nmodl::logger_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="logger_8cpp_source.html#l00019">19</a> of file <a class="el" href="logger_8cpp_source.html">logger.cpp</a>.</p>

</div>
</div>
<a id="a7f67a7446a31513983f9ada8596296ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f67a7446a31513983f9ada8596296ab">&#9670;&nbsp;</a></span>Parser</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef parser::NmodlParser <a class="el" href="namespacenmodl.html#a7f67a7446a31513983f9ada8596296ab">nmodl::Parser</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="nmodl__utils_8cpp_source.html#l00024">24</a> of file <a class="el" href="nmodl__utils_8cpp_source.html">nmodl_utils.cpp</a>.</p>

</div>
</div>
<a id="add1d0349c5a29bed1dd6bb012345c0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add1d0349c5a29bed1dd6bb012345c0e4">&#9670;&nbsp;</a></span>PositionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenmodl.html#add1d0349c5a29bed1dd6bb012345c0e4">nmodl::PositionType</a> = typedef parser::location</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="nmodl__utils_8hpp_source.html#l00025">25</a> of file <a class="el" href="nmodl__utils_8hpp_source.html">nmodl_utils.hpp</a>.</p>

</div>
</div>
<a id="a21403ee2d75755a88023abc4ca9bc9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21403ee2d75755a88023abc4ca9bc9a9">&#9670;&nbsp;</a></span>SymbolType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenmodl.html#a21403ee2d75755a88023abc4ca9bc9a9">nmodl::SymbolType</a> = typedef <a class="el" href="group__token__test.html#ga752aa45201ab43cc2d13b3ce5a5f1144">parser::NmodlParser::symbol_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="nmodl__utils_8hpp_source.html#l00026">26</a> of file <a class="el" href="nmodl__utils_8hpp_source.html">nmodl_utils.hpp</a>.</p>

</div>
</div>
<a id="a5f4247bc09fd496e5015912ef0382a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f4247bc09fd496e5015912ef0382a5e">&#9670;&nbsp;</a></span>Token</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef parser::NmodlParser::token <a class="el" href="namespacenmodl.html#a5f4247bc09fd496e5015912ef0382a5e">nmodl::Token</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="nmodl__utils_8hpp_source.html#l00027">27</a> of file <a class="el" href="nmodl__utils_8hpp_source.html">nmodl_utils.hpp</a>.</p>

</div>
</div>
<a id="a84a18ff49e1535de813a7f86968f6ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a18ff49e1535de813a7f86968f6ae5">&#9670;&nbsp;</a></span>TokenType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef parser::NmodlParser::token_type <a class="el" href="namespacenmodl.html#a84a18ff49e1535de813a7f86968f6ae5">nmodl::TokenType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="nmodl__utils_8hpp_source.html#l00028">28</a> of file <a class="el" href="nmodl__utils_8hpp_source.html">nmodl_utils.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a46adf69ad60da4329e7fa16b4c6df26b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46adf69ad60da4329e7fa16b4c6df26b">&#9670;&nbsp;</a></span>collect_nodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::shared_ptr&lt; <a class="el" href="structnmodl_1_1ast_1_1_ast.html">ast::Ast</a> &gt; &gt; nmodl::collect_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnmodl_1_1ast_1_1_ast.html">ast::Ast</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__ast__type.html#gac392e49849e60c05e42ea02c7b445033">ast::AstNodeType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>traverse <em>node</em> recursively and collect nodes of given <em>types</em> </p>

<p class="definition">Definition at line <a class="el" href="visitor__utils_8cpp_source.html#l00217">217</a> of file <a class="el" href="visitor__utils_8cpp_source.html">visitor_utils.cpp</a>.</p>

</div>
</div>
<a id="a0d49270a6c751e2e1a0e2c2db0012e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d49270a6c751e2e1a0e2c2db0012e4d">&#9670;&nbsp;</a></span>collect_nodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::shared_ptr&lt; const <a class="el" href="structnmodl_1_1ast_1_1_ast.html">ast::Ast</a> &gt; &gt; nmodl::collect_nodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnmodl_1_1ast_1_1_ast.html">ast::Ast</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__ast__type.html#gac392e49849e60c05e42ea02c7b445033">ast::AstNodeType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>traverse <em>node</em> recursively and collect nodes of given <em>types</em> </p>

<p class="definition">Definition at line <a class="el" href="visitor__utils_8cpp_source.html#l00210">210</a> of file <a class="el" href="visitor__utils_8cpp_source.html">visitor_utils.cpp</a>.</p>

</div>
</div>
<a id="ab5d9bcd28e4833ee993affb599e070ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d9bcd28e4833ee993affb599e070ca">&#9670;&nbsp;</a></span>double_symbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenmodl.html#a21403ee2d75755a88023abc4ca9bc9a9">SymbolType</a> nmodl::double_symbol </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenmodl.html#add1d0349c5a29bed1dd6bb012345c0e4">PositionType</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a symbol for <a class="el" href="classnmodl_1_1ast_1_1_double.html" title="Represents a double variable.">ast::Double</a> AST class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Double value parsed by lexer </td></tr>
    <tr><td class="paramname">pos</td><td>Position of value in the mod file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Symbol for double value </dd></dl>

<p class="definition">Definition at line <a class="el" href="nmodl__utils_8cpp_source.html#l00033">33</a> of file <a class="el" href="nmodl__utils_8cpp_source.html">nmodl_utils.cpp</a>.</p>

</div>
</div>
<a id="a7711df7469359fc31a262c8c15dff311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7711df7469359fc31a262c8c15dff311">&#9670;&nbsp;</a></span>get_external_functions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; nmodl::get_external_functions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return functions that can be used in the NMODL. </p>
<dl class="section return"><dt>Returns</dt><dd>vector of function names used in NMODL </dd></dl>

<p class="definition">Definition at line <a class="el" href="token__mapping_8cpp_source.html#l00392">392</a> of file <a class="el" href="token__mapping_8cpp_source.html">token_mapping.cpp</a>.</p>

</div>
</div>
<a id="a14c6954ec1bd73d2f75c54d000d6aa85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c6954ec1bd73d2f75c54d000d6aa85">&#9670;&nbsp;</a></span>get_external_variables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; nmodl::get_external_variables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return variables declared in NEURON that are available to NMODL. </p>
<dl class="section return"><dt>Returns</dt><dd>vector of NEURON variables </dd></dl>

<p class="definition">Definition at line <a class="el" href="token__mapping_8cpp_source.html#l00381">381</a> of file <a class="el" href="token__mapping_8cpp_source.html">token_mapping.cpp</a>.</p>

</div>
</div>
<a id="a65f5a4e348e6aae405a2087dc9b003cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65f5a4e348e6aae405a2087dc9b003cb">&#9670;&nbsp;</a></span>get_full_var_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string nmodl::get_full_var_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnmodl_1_1ast_1_1_var_name.html">ast::VarName</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a VarName node, return the full var name including index. </p>

<p class="definition">Definition at line <a class="el" href="visitor__utils_8cpp_source.html#l00281">281</a> of file <a class="el" href="visitor__utils_8cpp_source.html">visitor_utils.cpp</a>.</p>

</div>
</div>
<a id="a63b20bd823506ecccb7c2c79d5b153f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b20bd823506ecccb7c2c79d5b153f2">&#9670;&nbsp;</a></span>get_indexed_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string nmodl::get_indexed_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnmodl_1_1ast_1_1_indexed_name.html">ast::IndexedName</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a Indexed node, return the name with index. </p>

<p class="definition">Definition at line <a class="el" href="visitor__utils_8cpp_source.html#l00277">277</a> of file <a class="el" href="visitor__utils_8cpp_source.html">visitor_utils.cpp</a>.</p>

</div>
</div>
<a id="ae1bae1bfa39b1ff514d3a894b9513eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1bae1bfa39b1ff514d3a894b9513eb4">&#9670;&nbsp;</a></span>integer_symbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenmodl.html#a21403ee2d75755a88023abc4ca9bc9a9">SymbolType</a> nmodl::integer_symbol </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenmodl.html#add1d0349c5a29bed1dd6bb012345c0e4">PositionType</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a symbol for <a class="el" href="classnmodl_1_1ast_1_1_integer.html" title="Represents an integer variable.">ast::Integer</a> AST. </p>
<p><a class="el" href="classnmodl_1_1ast_1_1_integer.html" title="Represents an integer variable.">ast::Integer</a> class also represent macro definition and hence could have associated text.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Integer value parsed by lexer </td></tr>
    <tr><td class="paramname">pos</td><td>Position of value in the mod file </td></tr>
    <tr><td class="paramname">text</td><td>associated macro for the value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Symbol for integer value </dd></dl>

<p class="definition">Definition at line <a class="el" href="nmodl__utils_8cpp_source.html#l00052">52</a> of file <a class="el" href="nmodl__utils_8cpp_source.html">nmodl_utils.cpp</a>.</p>

</div>
</div>
<a id="ab8c6fbb1722584c4990afd054942b365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c6fbb1722584c4990afd054942b365">&#9670;&nbsp;</a></span>is_keyword()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nmodl::is_keyword </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if given name is a keyword in NMODL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>token name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if name is a keyword </dd></dl>

<p class="definition">Definition at line <a class="el" href="token__mapping_8cpp_source.html#l00346">346</a> of file <a class="el" href="token__mapping_8cpp_source.html">token_mapping.cpp</a>.</p>

</div>
</div>
<a id="a2d1b1903ca3f4f531b67406da6b62ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d1b1903ca3f4f531b67406da6b62ae6">&#9670;&nbsp;</a></span>is_method()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nmodl::is_method </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if given name is an integration method in NMODL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the integration method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if name is an integration method in NMODL </dd></dl>

<p class="definition">Definition at line <a class="el" href="token__mapping_8cpp_source.html#l00356">356</a> of file <a class="el" href="token__mapping_8cpp_source.html">token_mapping.cpp</a>.</p>

</div>
</div>
<a id="aa7c0916e51ccaf5779b7db1d1cd9fd8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7c0916e51ccaf5779b7db1d1cd9fd8d">&#9670;&nbsp;</a></span>name_symbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenmodl.html#a21403ee2d75755a88023abc4ca9bc9a9">SymbolType</a> nmodl::name_symbol </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenmodl.html#add1d0349c5a29bed1dd6bb012345c0e4">PositionType</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenmodl.html#a84a18ff49e1535de813a7f86968f6ae5">TokenType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create symbol for <a class="el" href="classnmodl_1_1ast_1_1_name.html" title="Represents a name.">ast::Name</a> AST class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>Text value parsed by lexer </td></tr>
    <tr><td class="paramname">pos</td><td>Position of value in the mod file </td></tr>
    <tr><td class="paramname">type</td><td>Token type returned by lexer (see parser::NmodlParser::token::yytokentype) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Symbol for name value</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000026">Todo:</a></b></dt><dd>In addition to keywords and methods, there are also external definitions for math and neuron specific functions/variables. In the token we should mark those as external. </dd></dl>

<p class="definition">Definition at line <a class="el" href="nmodl__utils_8cpp_source.html#l00080">80</a> of file <a class="el" href="nmodl__utils_8cpp_source.html">nmodl_utils.cpp</a>.</p>

</div>
</div>
<a id="a0cf4c8aaed9573bc39d71c41957f9bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf4c8aaed9573bc39d71c41957f9bf6">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnmodl_1_1_mod_token.html">ModToken</a> nmodl::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnmodl_1_1_mod_token.html">ModToken</a>&#160;</td>
          <td class="paramname"><em>adder1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnmodl_1_1_mod_token.html">ModToken</a>&#160;</td>
          <td class="paramname"><em>adder2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For example:</p>
<div class="fragment"><div class="line">a at [118.9-14]</div>
<div class="line">b at [121.4-5]</div>
</div><!-- fragment --><p>Output:</p>
<div class="fragment"><div class="line">(a + b) at [118.9-121.5]</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="src_2lexer_2modtoken_8cpp_source.html#l00036">36</a> of file <a class="el" href="src_2lexer_2modtoken_8cpp_source.html">modtoken.cpp</a>.</p>

</div>
</div>
<a id="a4aedc321d8c19da4f629ebc04ffc877d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aedc321d8c19da4f629ebc04ffc877d">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; nmodl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnmodl_1_1_mod_token.html">ModToken</a> &amp;&#160;</td>
          <td class="paramname"><em>mt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload ostream operator to print token in the form :</p>
<div class="fragment"><div class="line">token at [line.start_column-end_column] type token</div>
</div><!-- fragment --><p>For example:</p>
<div class="fragment"><div class="line">v at [118.9-14] type 376</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="src_2lexer_2modtoken_8cpp_source.html#l00031">31</a> of file <a class="el" href="src_2lexer_2modtoken_8cpp_source.html">modtoken.cpp</a>.</p>

</div>
</div>
<a id="a08cfce6611cb5d2f80356e40a720fdf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08cfce6611cb5d2f80356e40a720fdf0">&#9670;&nbsp;</a></span>prime_symbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenmodl.html#a21403ee2d75755a88023abc4ca9bc9a9">SymbolType</a> nmodl::prime_symbol </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenmodl.html#add1d0349c5a29bed1dd6bb012345c0e4">PositionType</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create symbol for ast::Prime AST class. </p>
<p>ast::Prime has name as well as order. Text returned by lexer has single quote (&lsquo;&rsquo;`) as an order. We count the order and remove quote from the text.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>Prime variable name parsed by lexer </td></tr>
    <tr><td class="paramname">pos</td><td>Position of text in the mod file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Symbol for prime variable </dd></dl>

<p class="definition">Definition at line <a class="el" href="nmodl__utils_8cpp_source.html#l00098">98</a> of file <a class="el" href="nmodl__utils_8cpp_source.html">nmodl_utils.cpp</a>.</p>

</div>
</div>
<a id="a21160c42746b7846b552e45572d8e083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21160c42746b7846b552e45572d8e083">&#9670;&nbsp;</a></span>sparse_solver_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nmodl::sparse_solver_exists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnmodl_1_1ast_1_1_ast.html">ast::Ast</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="visitor__utils_8cpp_source.html#l00223">223</a> of file <a class="el" href="visitor__utils_8cpp_source.html">visitor_utils.cpp</a>.</p>

</div>
</div>
<a id="a1cf829797d75f00f7307a89776d9d735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf829797d75f00f7307a89776d9d735">&#9670;&nbsp;</a></span>statement_dependencies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, std::unordered_set&lt; std::string &gt; &gt; nmodl::statement_dependencies </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classnmodl_1_1ast_1_1_expression.html">ast::Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classnmodl_1_1ast_1_1_expression.html">ast::Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>lhs</code> and <code>rhs</code> combined represent an assignment (we assume to have an "=" in between them) we extract the variables on which the assigned variable depends on. </p>
<p>We provide the input with lhs and rhs because there are a few nodes that have this similar structure but slightly different naming (binaryExpression, diff_eq_expression, linExpression) </p>

<p class="definition">Definition at line <a class="el" href="visitor__utils_8cpp_source.html#l00253">253</a> of file <a class="el" href="visitor__utils_8cpp_source.html">visitor_utils.cpp</a>.</p>

</div>
</div>
<a id="ade3f7ab91ca790e74f4d3196de33cc09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade3f7ab91ca790e74f4d3196de33cc09">&#9670;&nbsp;</a></span>string_symbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenmodl.html#a21403ee2d75755a88023abc4ca9bc9a9">SymbolType</a> nmodl::string_symbol </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenmodl.html#add1d0349c5a29bed1dd6bb012345c0e4">PositionType</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create symbol for <a class="el" href="classnmodl_1_1ast_1_1_string.html" title="Represents a string.">ast::String</a> AST class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>Text value parsed by lexer </td></tr>
    <tr><td class="paramname">pos</td><td>Position of value in the mod file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Symbol for string value </dd></dl>

<p class="definition">Definition at line <a class="el" href="nmodl__utils_8cpp_source.html#l00117">117</a> of file <a class="el" href="nmodl__utils_8cpp_source.html">nmodl_utils.cpp</a>.</p>

</div>
</div>
<a id="a4004b62c9ab28101181960aefda0d8e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4004b62c9ab28101181960aefda0d8e7">&#9670;&nbsp;</a></span>to_json()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string nmodl::to_json </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnmodl_1_1ast_1_1_ast.html">ast::Ast</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>expand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>add_nmodl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given AST node, return the JSON string representation. </p>

<p class="definition">Definition at line <a class="el" href="visitor__utils_8cpp_source.html#l00242">242</a> of file <a class="el" href="visitor__utils_8cpp_source.html">visitor_utils.cpp</a>.</p>

</div>
</div>
<a id="a60f3383905bcc82c616483bc5c9f8c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60f3383905bcc82c616483bc5c9f8c21">&#9670;&nbsp;</a></span>to_nmodl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string nmodl::to_nmodl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnmodl_1_1ast_1_1_ast.html">ast::Ast</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="group__ast__type.html#gac392e49849e60c05e42ea02c7b445033">ast::AstNodeType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>exclude_types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given AST node, return the NMODL string representation. </p>

<p class="definition">Definition at line <a class="el" href="visitor__utils_8cpp_source.html#l00234">234</a> of file <a class="el" href="visitor__utils_8cpp_source.html">visitor_utils.cpp</a>.</p>

</div>
</div>
<a id="a457c69d76cbb7d9318af1fc030946326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457c69d76cbb7d9318af1fc030946326">&#9670;&nbsp;</a></span>to_nmodl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_base_of&lt;<a class="el" href="structnmodl_1_1ast_1_1_ast.html">ast::Ast</a>, T&gt;::value, std::string&gt;::type nmodl::to_nmodl </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="group__ast__type.html#gac392e49849e60c05e42ea02c7b445033">ast::AstNodeType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>exclude_types</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a shared pointer to an AST node, return the NMODL string representation. </p>

<p class="definition">Definition at line <a class="el" href="visitor__utils_8hpp_source.html#l00116">116</a> of file <a class="el" href="visitor__utils_8hpp_source.html">visitor_utils.hpp</a>.</p>

</div>
</div>
<a id="ae7ac813a4b0304bdef3c4ab70ec37130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ac813a4b0304bdef3c4ab70ec37130">&#9670;&nbsp;</a></span>token_symbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenmodl.html#a21403ee2d75755a88023abc4ca9bc9a9">SymbolType</a> nmodl::token_symbol </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenmodl.html#add1d0349c5a29bed1dd6bb012345c0e4">PositionType</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenmodl.html#a84a18ff49e1535de813a7f86968f6ae5">TokenType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create symbol for AST class. </p>
<p>These tokens doesn't have specific value to pass to the parser. They are more part of grammar. Depending on the type of toke, we create appropriate symbol. From lexer we pass token type (which is optional). This is required for reaction parsing where we have "lexical context". Hence, if token type is passed then we don't check/search for the token type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Text parsed by lexer </td></tr>
    <tr><td class="paramname">pos</td><td>Position of value in the mod file </td></tr>
    <tr><td class="paramname">type</td><td>Token type returned by lexer (see parser::NmodlParser::token::yytokentype) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Symbol for given token </dd></dl>
<p>if token type is not passed, check if it is keyword or method</p>
<p>we hit default case for missing token type. This is more likely a bug in the implementation where we forgot to handle token type.</p>

<p class="definition">Definition at line <a class="el" href="nmodl__utils_8cpp_source.html#l00139">139</a> of file <a class="el" href="nmodl__utils_8cpp_source.html">nmodl_utils.cpp</a>.</p>

</div>
</div>
<a id="a1932dc8f598d068751391d892d439400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1932dc8f598d068751391d892d439400">&#9670;&nbsp;</a></span>token_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">parser::NmodlParser::token_type nmodl::token_type </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return token type for given token name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Token name from lexer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>type of NMODL token </dd></dl>

<p class="definition">Definition at line <a class="el" href="token__mapping_8cpp_source.html#l00366">366</a> of file <a class="el" href="token__mapping_8cpp_source.html">token_mapping.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a6f087e40d0134fa62ba1dbc48dc2462b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f087e40d0134fa62ba1dbc48dc2462b">&#9670;&nbsp;</a></span>logger</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenmodl.html#a55e6b3d1235030c67add793cc98ab7b3">logger_type</a> nmodl::logger = nmodl_logger.logger</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="logger_8cpp_source.html#l00033">33</a> of file <a class="el" href="logger_8cpp_source.html">logger.cpp</a>.</p>

</div>
</div>
<a id="a447a341fe15e3ab162b9651c64c3ef09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a447a341fe15e3ab162b9651c64c3ef09">&#9670;&nbsp;</a></span>nmodl_logger</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnmodl_1_1_logger.html">Logger</a> nmodl::nmodl_logger(&quot;NMODL&quot;, &quot;[%n] [%^%l%$] :: %v&quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<div id="nav-path" class="navpath">
  <ul>
    <li class="navelem"><a class="el" href="namespacenmodl.html">nmodl</a></li>
  </ul>
</div>
<hr class="footer"/>
<address class="footer">
    <small>
    </small>
</address>
<!--END !GENERATE_TREEVIEW-->
</body>
</html>
