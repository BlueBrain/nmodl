<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Module contents &mdash; NMODL 0.0 documentation</title><link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="C++ API" href="doxygen.html" />
    <link rel="prev" title="Python package" href="modules.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> NMODL
          </a>
              <div class="version">
                0.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p><span class="caption-text">Introduction:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="readme.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installing the NMODL Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="language.html">The NEURON MODeling language</a></li>
</ul>
<p><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="contents/visitors.html">Visitors</a></li>
</ul>
<p><span class="caption-text">Jupyter Notebooks:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="notebooks.html">The NMODL Jupyter notebooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="notebooks/nmodl-python-tutorial.html">NMODL Python Interface Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="notebooks/nmodl-odes-overview.html">NMODL integration of ODEs</a></li>
<li class="toctree-l1"><a class="reference internal" href="notebooks/nmodl-kinetic-schemes.html">NMODL Kinetic Scheme</a></li>
<li class="toctree-l1"><a class="reference internal" href="notebooks/nmodl-sympy-solver-cnexp.html">NMODL SympySolver - cnexp</a></li>
<li class="toctree-l1"><a class="reference internal" href="notebooks/nmodl-sympy-solver-sparse.html">NMODL SympySolver - sparse</a></li>
<li class="toctree-l1"><a class="reference internal" href="notebooks/nmodl-sympy-solver-derivimplicit.html">NMODL SympySolver - derivimplicit</a></li>
<li class="toctree-l1"><a class="reference internal" href="notebooks/nmodl-linear-solver.html">NMODL LINEAR solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="notebooks/nmodl-nonlinear-solver.html">NMODL NONLINEAR solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="notebooks/nmodl-sympy-conductance.html">NMODL CONDUCTANCE</a></li>
</ul>
<p><span class="caption-text">Contributing:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing to the NMODL Framework</a></li>
</ul>
<p><span class="caption-text">Reference:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">Python package</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Module contents</a></li>
<li class="toctree-l2"><a class="reference internal" href="#submodules">Submodules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-nmodl.ast">nmodl.ast module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-nmodl.dsl">nmodl.dsl module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-nmodl.ode">nmodl.ode module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-nmodl.symtab">nmodl.symtab module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-nmodl.visitor">nmodl.visitor module</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="doxygen.html">C++ API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">NMODL</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="modules.html">Python package</a> &raquo;</li>
      <li>Module contents</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/nmodl.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="module-nmodl">
<span id="module-contents"></span><h1>Module contents<a class="headerlink" href="#module-nmodl" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="nmodl.NmodlDriver">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.</code><code class="sig-name descname">NmodlDriver</code><a class="headerlink" href="#nmodl.NmodlDriver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_builtins.pybind11_object</span></code></p>
<p>This is the NmodlDriver class documentation</p>
<dl class="method">
<dt id="nmodl.NmodlDriver.get_ast">
<code class="sig-name descname">get_ast</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.NmodlDriver</em><span class="sig-paren">)</span> &#x2192; nmodl::ast::Program<a class="headerlink" href="#nmodl.NmodlDriver.get_ast" title="Permalink to this definition">¶</a></dt>
<dd><p>Get ast</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Program</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nmodl.NmodlDriver.parse_file">
<code class="sig-name descname">parse_file</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.NmodlDriver</em>, <em class="sig-param">filename: str</em><span class="sig-paren">)</span> &#x2192; nmodl::ast::Program<a class="headerlink" href="#nmodl.NmodlDriver.parse_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse NMODL provided as a file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>filename</strong> (<em>str</em>) – name of the C file</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>ast root node if success, throws an exception otherwise</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>AST</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nmodl.NmodlDriver.parse_stream">
<code class="sig-name descname">parse_stream</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.NmodlDriver</em>, <em class="sig-param">in: object</em><span class="sig-paren">)</span> &#x2192; nmodl::ast::Program<a class="headerlink" href="#nmodl.NmodlDriver.parse_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse NMODL file provided as istream</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>in</strong> (<em>file</em>) – ifstream object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>ast root node if success, throws an exception otherwise</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>AST</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nmodl.NmodlDriver.parse_string">
<code class="sig-name descname">parse_string</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.NmodlDriver</em>, <em class="sig-param">input: str</em><span class="sig-paren">)</span> &#x2192; nmodl::ast::Program<a class="headerlink" href="#nmodl.NmodlDriver.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse NMODL provided as a string</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>input</strong> (<em>str</em>) – C code as string</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>ast root node if success, throws an exception otherwise</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>AST</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ast</span> <span class="o">=</span> <span class="n">driver</span><span class="o">.</span><span class="n">parse_string</span><span class="p">(</span><span class="s2">&quot;DEFINE NSTEP 6&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nmodl.to_json">
<code class="sig-prename descclassname">nmodl.</code><code class="sig-name descname">to_json</code><span class="sig-paren">(</span><em class="sig-param">node: nmodl::ast::Ast</em>, <em class="sig-param">compact: bool = False</em>, <em class="sig-param">expand: bool = False</em>, <em class="sig-param">add_nmodl: bool = False</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Given AST node, return the JSON string representation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node</strong> (<em>AST</em>) – AST node</p></li>
<li><p><strong>compact</strong> (<em>bool</em>) – Compact node</p></li>
<li><p><strong>expand</strong> (<em>bool</em>) – Expand node</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>JSON string representation</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ast</span> <span class="o">=</span> <span class="n">driver</span><span class="o">.</span><span class="n">parse_string</span><span class="p">(</span><span class="s2">&quot;NEURON</span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nmodl</span><span class="o">.</span><span class="n">to_json</span><span class="p">(</span><span class="n">ast</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;{&quot;Program&quot;:[{&quot;NeuronBlock&quot;:[{&quot;StatementBlock&quot;:[]}]}]}&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="nmodl.to_nmodl">
<code class="sig-prename descclassname">nmodl.</code><code class="sig-name descname">to_nmodl</code><span class="sig-paren">(</span><em class="sig-param">node: nmodl::ast::Ast</em>, <em class="sig-param">exclude_types: Set[nmodl::ast::AstNodeType] = set()</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.to_nmodl" title="Permalink to this definition">¶</a></dt>
<dd><p>Given AST node, return the NMODL string representation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node</strong> (<em>AST</em>) – AST node</p></li>
<li><p><strong>excludeTypes</strong> (<em>set of AstNodeType</em>) – Excluded node types</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>NMODL string representation</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ast</span> <span class="o">=</span> <span class="n">driver</span><span class="o">.</span><span class="n">parse_string</span><span class="p">(</span><span class="s2">&quot;NEURON</span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nmodl</span><span class="o">.</span><span class="n">to_nmodl</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span>
<span class="go">&#39;NEURON {\n}\n&#39;</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="submodules">
<h1>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h1>
<section id="module-nmodl.ast">
<span id="nmodl-ast-module"></span><h2>nmodl.ast module<a class="headerlink" href="#module-nmodl.ast" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nmodl.ast.AfterBlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">AfterBlock</code><a class="headerlink" href="#nmodl.ast.AfterBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>Represents a <cite>AFTER</cite> block in NMODL</p>
<dl class="method">
<dt id="nmodl.ast.AfterBlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.AfterBlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.AfterBlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.AfterBlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.AfterBlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.AfterBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AfterBlock<a class="headerlink" href="#nmodl.ast.AfterBlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.AfterBlock.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.AfterBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.AfterBlock.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.AfterBlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.AfterBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.AfterBlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.AfterBlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.AfterBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.AfterBlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.AfterBlock.is_after_block">
<code class="sig-name descname">is_after_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.AfterBlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.AfterBlock.is_after_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.AfterBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.AfterBlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.AfterBlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.AfterBlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Argument">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Argument</code><a class="headerlink" href="#nmodl.ast.Argument" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Identifier</span></code></p>
<p>Represents an argument to functions and procedures</p>
<dl class="method">
<dt id="nmodl.ast.Argument.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Argument.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Argument, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Argument, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Argument.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Argument</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Argument<a class="headerlink" href="#nmodl.ast.Argument.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Argument.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Argument</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Argument.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Argument.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Argument</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Argument.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Argument.is_argument">
<code class="sig-name descname">is_argument</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Argument</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Argument.is_argument" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Argument</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Argument.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Argument</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Argument.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.AssignedBlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">AssignedBlock</code><a class="headerlink" href="#nmodl.ast.AssignedBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>Represents a <cite>ASSIGNED</cite> block in the NMODL</p>
<dl class="method">
<dt id="nmodl.ast.AssignedBlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.AssignedBlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.AssignedBlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.AssignedBlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.AssignedBlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.AssignedBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AssignedBlock<a class="headerlink" href="#nmodl.ast.AssignedBlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.AssignedBlock.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.AssignedBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.AssignedBlock.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.AssignedBlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.AssignedBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.AssignedBlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.AssignedBlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.AssignedBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.AssignedBlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.AssignedBlock.is_assigned_block">
<code class="sig-name descname">is_assigned_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.AssignedBlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.AssignedBlock.is_assigned_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.AssignedBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.AssignedBlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.AssignedBlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.AssignedBlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.AssignedDefinition">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">AssignedDefinition</code><a class="headerlink" href="#nmodl.ast.AssignedDefinition" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>Represents a statement in <cite>ASSIGNED</cite> or <cite>STATE</cite> block</p>
<dl class="method">
<dt id="nmodl.ast.AssignedDefinition.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.AssignedDefinition.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.AssignedDefinition, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.AssignedDefinition, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.AssignedDefinition.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.AssignedDefinition</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AssignedDefinition<a class="headerlink" href="#nmodl.ast.AssignedDefinition.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.AssignedDefinition.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.AssignedDefinition</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.AssignedDefinition.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.AssignedDefinition.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.AssignedDefinition</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.AssignedDefinition.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.AssignedDefinition.is_assigned_definition">
<code class="sig-name descname">is_assigned_definition</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.AssignedDefinition</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.AssignedDefinition.is_assigned_definition" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.AssignedDefinition</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.AssignedDefinition.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.AssignedDefinition</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.AssignedDefinition.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Ast">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Ast</code><a class="headerlink" href="#nmodl.ast.Ast" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_builtins.pybind11_object</span></code></p>
<p>Base class for all Abstract Syntax Tree node types</p>
<p>Every node in the Abstract Syntax Tree is inherited from base class
Ast. This class provides base properties and functions that are implemented
by base classes.</p>
<dl class="method">
<dt id="nmodl.ast.Ast.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Ast.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Ast, v: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Ast, v: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Ast<a class="headerlink" href="#nmodl.ast.Ast.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Ast.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.get_node_name">
<code class="sig-name descname">get_node_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Ast.get_node_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return name of the node</p>
<p>Some ast nodes have a member designated as node name. For example,
in case of ast.FunctionCall, name of the function is returned as a node
name. Note that this is different from ast node type name and not every
ast node has name.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Ast.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Ast.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.get_statement_block">
<code class="sig-name descname">get_statement_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; nmodl::ast::StatementBlock<a class="headerlink" href="#nmodl.ast.Ast.get_statement_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Return associated statement block for the AST node</p>
<p>Top level block nodes encloses all statements in the ast::StatementBlock.
For example, ast.BreakpointBlock has all statements in curly brace (<cite>{ }</cite>)
stored in ast.StatementBlock :</p>
<dl class="simple">
<dt>BREAKPOINT {</dt><dd><p>SOLVE states METHOD cnexp
gNaTs2_t = gNaTs2_tbar*m*m*m*h
ina = gNaTs2_t*(v-ena)</p>
</dd>
</dl>
<p>}</p>
<p>This method return enclosing statement block.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.get_symbol_table">
<code class="sig-name descname">get_symbol_table</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; nmodl::symtab::SymbolTable<a class="headerlink" href="#nmodl.ast.Ast.get_symbol_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Return associated symbol table for the AST node</p>
<p>Certain ast nodes (e.g. inherited from ast.Block) have associated
symbol table. These nodes have nmodl.symtab.SymbolTable as member
and it can be accessed using this method.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.get_token">
<code class="sig-name descname">get_token</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; nmodl::ModToken<a class="headerlink" href="#nmodl.ast.Ast.get_token" title="Permalink to this definition">¶</a></dt>
<dd><p>Return associated token for the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_after_block">
<code class="sig-name descname">is_after_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_after_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.AfterBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_argument">
<code class="sig-name descname">is_argument</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_argument" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Argument</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_assigned_block">
<code class="sig-name descname">is_assigned_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_assigned_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.AssignedBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_assigned_definition">
<code class="sig-name descname">is_assigned_definition</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_assigned_definition" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.AssignedDefinition</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_ast">
<code class="sig-name descname">is_ast</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_ast" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if current node is of type ast.Ast</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_ba_block">
<code class="sig-name descname">is_ba_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_ba_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.BABlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_ba_block_type">
<code class="sig-name descname">is_ba_block_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_ba_block_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.BABlockType</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_bbcore_pointer">
<code class="sig-name descname">is_bbcore_pointer</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_bbcore_pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.BbcorePointer</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_bbcore_pointer_var">
<code class="sig-name descname">is_bbcore_pointer_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_bbcore_pointer_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.BbcorePointerVar</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_before_block">
<code class="sig-name descname">is_before_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_before_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.BeforeBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_binary_expression">
<code class="sig-name descname">is_binary_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_binary_expression" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.BinaryExpression</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_binary_operator">
<code class="sig-name descname">is_binary_operator</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_binary_operator" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.BinaryOperator</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_block">
<code class="sig-name descname">is_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Block</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_block_comment">
<code class="sig-name descname">is_block_comment</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_block_comment" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.BlockComment</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_boolean">
<code class="sig-name descname">is_boolean</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Boolean</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_breakpoint_block">
<code class="sig-name descname">is_breakpoint_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_breakpoint_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.BreakpointBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_compartment">
<code class="sig-name descname">is_compartment</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_compartment" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Compartment</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_conductance_hint">
<code class="sig-name descname">is_conductance_hint</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_conductance_hint" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ConductanceHint</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_conserve">
<code class="sig-name descname">is_conserve</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_conserve" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Conserve</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_constant_block">
<code class="sig-name descname">is_constant_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_constant_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ConstantBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_constant_statement">
<code class="sig-name descname">is_constant_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_constant_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ConstantStatement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_constant_var">
<code class="sig-name descname">is_constant_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_constant_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ConstantVar</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_constructor_block">
<code class="sig-name descname">is_constructor_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_constructor_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ConstructorBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_define">
<code class="sig-name descname">is_define</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_define" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Define</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_derivative_block">
<code class="sig-name descname">is_derivative_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_derivative_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.DerivativeBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_derivimplicit_callback">
<code class="sig-name descname">is_derivimplicit_callback</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_derivimplicit_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.DerivimplicitCallback</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_destructor_block">
<code class="sig-name descname">is_destructor_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_destructor_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.DestructorBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_diff_eq_expression">
<code class="sig-name descname">is_diff_eq_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_diff_eq_expression" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.DiffEqExpression</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_discrete_block">
<code class="sig-name descname">is_discrete_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_discrete_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.DiscreteBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_double">
<code class="sig-name descname">is_double</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_double" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Double</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_double_unit">
<code class="sig-name descname">is_double_unit</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_double_unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.DoubleUnit</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_eigen_linear_solver_block">
<code class="sig-name descname">is_eigen_linear_solver_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_eigen_linear_solver_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.EigenLinearSolverBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_eigen_newton_solver_block">
<code class="sig-name descname">is_eigen_newton_solver_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_eigen_newton_solver_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.EigenNewtonSolverBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_electrode_cur_var">
<code class="sig-name descname">is_electrode_cur_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_electrode_cur_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ElectrodeCurVar</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_electrode_current">
<code class="sig-name descname">is_electrode_current</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_electrode_current" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ElectrodeCurrent</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_else_if_statement">
<code class="sig-name descname">is_else_if_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_else_if_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ElseIfStatement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_else_statement">
<code class="sig-name descname">is_else_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_else_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ElseStatement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_expression">
<code class="sig-name descname">is_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_expression" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Expression</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_expression_statement">
<code class="sig-name descname">is_expression_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_expression_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ExpressionStatement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_extern_var">
<code class="sig-name descname">is_extern_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_extern_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ExternVar</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_external">
<code class="sig-name descname">is_external</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_external" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.External</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_factor_def">
<code class="sig-name descname">is_factor_def</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_factor_def" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.FactorDef</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_first_last_type_index">
<code class="sig-name descname">is_first_last_type_index</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_first_last_type_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.FirstLastTypeIndex</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_float">
<code class="sig-name descname">is_float</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_float" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Float</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_for_all_statement">
<code class="sig-name descname">is_for_all_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_for_all_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ForAllStatement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_for_netcon">
<code class="sig-name descname">is_for_netcon</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_for_netcon" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ForNetcon</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_from_statement">
<code class="sig-name descname">is_from_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_from_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.FromStatement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_function_block">
<code class="sig-name descname">is_function_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_function_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.FunctionBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_function_call">
<code class="sig-name descname">is_function_call</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_function_call" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.FunctionCall</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_function_table_block">
<code class="sig-name descname">is_function_table_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_function_table_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.FunctionTableBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_global">
<code class="sig-name descname">is_global</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_global" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Global</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_global_var">
<code class="sig-name descname">is_global_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_global_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.GlobalVar</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_identifier">
<code class="sig-name descname">is_identifier</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_identifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Identifier</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_if_statement">
<code class="sig-name descname">is_if_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_if_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.IfStatement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_include">
<code class="sig-name descname">is_include</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_include" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Include</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_independent_block">
<code class="sig-name descname">is_independent_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_independent_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.IndependentBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_independent_definition">
<code class="sig-name descname">is_independent_definition</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_independent_definition" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.IndependentDefinition</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_indexed_name">
<code class="sig-name descname">is_indexed_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_indexed_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.IndexedName</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_initial_block">
<code class="sig-name descname">is_initial_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_initial_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.InitialBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_integer">
<code class="sig-name descname">is_integer</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Integer</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_kinetic_block">
<code class="sig-name descname">is_kinetic_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_kinetic_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.KineticBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_lag_statement">
<code class="sig-name descname">is_lag_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_lag_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.LagStatement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_limits">
<code class="sig-name descname">is_limits</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Limits</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_lin_equation">
<code class="sig-name descname">is_lin_equation</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_lin_equation" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.LinEquation</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_line_comment">
<code class="sig-name descname">is_line_comment</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_line_comment" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.LineComment</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_linear_block">
<code class="sig-name descname">is_linear_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_linear_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.LinearBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_local_list_statement">
<code class="sig-name descname">is_local_list_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_local_list_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.LocalListStatement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_local_var">
<code class="sig-name descname">is_local_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_local_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.LocalVar</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_lon_difuse">
<code class="sig-name descname">is_lon_difuse</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_lon_difuse" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.LonDifuse</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_match">
<code class="sig-name descname">is_match</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_match" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Match</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_match_block">
<code class="sig-name descname">is_match_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_match_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.MatchBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_model">
<code class="sig-name descname">is_model</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Model</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_mutex_lock">
<code class="sig-name descname">is_mutex_lock</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_mutex_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.MutexLock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_mutex_unlock">
<code class="sig-name descname">is_mutex_unlock</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_mutex_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.MutexUnlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_name">
<code class="sig-name descname">is_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Name</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_net_receive_block">
<code class="sig-name descname">is_net_receive_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_net_receive_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.NetReceiveBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_neuron_block">
<code class="sig-name descname">is_neuron_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_neuron_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.NeuronBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_node">
<code class="sig-name descname">is_node</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_non_lin_equation">
<code class="sig-name descname">is_non_lin_equation</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_non_lin_equation" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.NonLinEquation</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_non_linear_block">
<code class="sig-name descname">is_non_linear_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_non_linear_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.NonLinearBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_nonspecific">
<code class="sig-name descname">is_nonspecific</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_nonspecific" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Nonspecific</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_nonspecific_cur_var">
<code class="sig-name descname">is_nonspecific_cur_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_nonspecific_cur_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.NonspecificCurVar</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_nrn_state_block">
<code class="sig-name descname">is_nrn_state_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_nrn_state_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.NrnStateBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_number">
<code class="sig-name descname">is_number</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Number</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_number_range">
<code class="sig-name descname">is_number_range</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_number_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.NumberRange</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_ontology_statement">
<code class="sig-name descname">is_ontology_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_ontology_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.OntologyStatement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_param_assign">
<code class="sig-name descname">is_param_assign</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_param_assign" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ParamAssign</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_param_block">
<code class="sig-name descname">is_param_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_param_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ParamBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_paren_expression">
<code class="sig-name descname">is_paren_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_paren_expression" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ParenExpression</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_partial_block">
<code class="sig-name descname">is_partial_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_partial_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.PartialBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_partial_boundary">
<code class="sig-name descname">is_partial_boundary</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_partial_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.PartialBoundary</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_partial_equation">
<code class="sig-name descname">is_partial_equation</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_partial_equation" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.PartialEquation</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_plot_block">
<code class="sig-name descname">is_plot_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_plot_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.PlotBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_plot_declaration">
<code class="sig-name descname">is_plot_declaration</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_plot_declaration" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.PlotDeclaration</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_plot_var">
<code class="sig-name descname">is_plot_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_plot_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.PlotVar</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_pointer">
<code class="sig-name descname">is_pointer</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Pointer</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_pointer_var">
<code class="sig-name descname">is_pointer_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_pointer_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.PointerVar</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_prime_name">
<code class="sig-name descname">is_prime_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_prime_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.PrimeName</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_procedure_block">
<code class="sig-name descname">is_procedure_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_procedure_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ProcedureBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_program">
<code class="sig-name descname">is_program</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_program" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Program</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_protect_statement">
<code class="sig-name descname">is_protect_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_protect_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ProtectStatement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_queue_expression_type">
<code class="sig-name descname">is_queue_expression_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_queue_expression_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.QueueExpressionType</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_queue_statement">
<code class="sig-name descname">is_queue_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_queue_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.QueueStatement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_range">
<code class="sig-name descname">is_range</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Range</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_range_var">
<code class="sig-name descname">is_range_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_range_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.RangeVar</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_react_var_name">
<code class="sig-name descname">is_react_var_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_react_var_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ReactVarName</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_reaction_operator">
<code class="sig-name descname">is_reaction_operator</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_reaction_operator" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ReactionOperator</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_reaction_statement">
<code class="sig-name descname">is_reaction_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_reaction_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ReactionStatement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_read_ion_var">
<code class="sig-name descname">is_read_ion_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_read_ion_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ReadIonVar</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_reset">
<code class="sig-name descname">is_reset</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Reset</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_section">
<code class="sig-name descname">is_section</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_section" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Section</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_section_var">
<code class="sig-name descname">is_section_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_section_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.SectionVar</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_sens">
<code class="sig-name descname">is_sens</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_sens" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Sens</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_solution_expression">
<code class="sig-name descname">is_solution_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_solution_expression" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.SolutionExpression</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_solve_block">
<code class="sig-name descname">is_solve_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_solve_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.SolveBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_state_block">
<code class="sig-name descname">is_state_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_state_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.StateBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_statement">
<code class="sig-name descname">is_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Statement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_statement_block">
<code class="sig-name descname">is_statement_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_statement_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.StatementBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_step_block">
<code class="sig-name descname">is_step_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_step_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.StepBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_stepped">
<code class="sig-name descname">is_stepped</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_stepped" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Stepped</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_string">
<code class="sig-name descname">is_string</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.String</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_suffix">
<code class="sig-name descname">is_suffix</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_suffix" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Suffix</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_table_statement">
<code class="sig-name descname">is_table_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_table_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.TableStatement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_terminal_block">
<code class="sig-name descname">is_terminal_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_terminal_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.TerminalBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_thread_safe">
<code class="sig-name descname">is_thread_safe</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_thread_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ThreadSafe</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_threadsafe_var">
<code class="sig-name descname">is_threadsafe_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_threadsafe_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ThreadsafeVar</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_unary_expression">
<code class="sig-name descname">is_unary_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_unary_expression" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.UnaryExpression</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_unary_operator">
<code class="sig-name descname">is_unary_operator</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_unary_operator" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.UnaryOperator</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_unit">
<code class="sig-name descname">is_unit</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Unit</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_unit_block">
<code class="sig-name descname">is_unit_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_unit_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.UnitBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_unit_def">
<code class="sig-name descname">is_unit_def</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_unit_def" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.UnitDef</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_unit_state">
<code class="sig-name descname">is_unit_state</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_unit_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.UnitState</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_update_dt">
<code class="sig-name descname">is_update_dt</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_update_dt" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.UpdateDt</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_useion">
<code class="sig-name descname">is_useion</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_useion" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Useion</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_valence">
<code class="sig-name descname">is_valence</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_valence" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Valence</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_var_name">
<code class="sig-name descname">is_var_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_var_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.VarName</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_verbatim">
<code class="sig-name descname">is_verbatim</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_verbatim" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Verbatim</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_watch">
<code class="sig-name descname">is_watch</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_watch" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Watch</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_watch_statement">
<code class="sig-name descname">is_watch_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_watch_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.WatchStatement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_while_statement">
<code class="sig-name descname">is_while_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_while_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.WhileStatement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_wrapped_expression">
<code class="sig-name descname">is_wrapped_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_wrapped_expression" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.WrappedExpression</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.is_write_ion_var">
<code class="sig-name descname">is_write_ion_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Ast.is_write_ion_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.WriteIonVar</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.negate">
<code class="sig-name descname">negate</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Ast.negate" title="Permalink to this definition">¶</a></dt>
<dd><p>Negate the value of AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.set_name">
<code class="sig-name descname">set_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em>, <em class="sig-param">arg0: str</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Ast.set_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Set name for the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Ast.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Ast</em>, <em class="sig-param">v: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Ast.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.AstNodeType">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">AstNodeType</code><a class="headerlink" href="#nmodl.ast.AstNodeType" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_builtins.pybind11_object</span></code></p>
<blockquote>
<div><p>Enum type for every AST node type</p>
<p>Every node in the ast has associated type represented by
this enum class. See nmodl::ast::AstNodeType for details.</p>
</div></blockquote>
<p>Members:</p>
<blockquote>
<div><p>NODE : AST node of type ast.Node</p>
<p>STATEMENT : AST node of type ast.Statement</p>
<p>EXPRESSION : AST node of type ast.Expression</p>
<p>BLOCK : AST node of type ast.Block</p>
<p>IDENTIFIER : AST node of type ast.Identifier</p>
<p>NUMBER : AST node of type ast.Number</p>
<p>STRING : AST node of type ast.String</p>
<p>INTEGER : AST node of type ast.Integer</p>
<p>FLOAT : AST node of type ast.Float</p>
<p>DOUBLE : AST node of type ast.Double</p>
<p>BOOLEAN : AST node of type ast.Boolean</p>
<p>NAME : AST node of type ast.Name</p>
<p>PRIME_NAME : AST node of type ast.PrimeName</p>
<p>INDEXED_NAME : AST node of type ast.IndexedName</p>
<p>VAR_NAME : AST node of type ast.VarName</p>
<p>ARGUMENT : AST node of type ast.Argument</p>
<p>REACT_VAR_NAME : AST node of type ast.ReactVarName</p>
<p>READ_ION_VAR : AST node of type ast.ReadIonVar</p>
<p>WRITE_ION_VAR : AST node of type ast.WriteIonVar</p>
<p>NONSPECIFIC_CUR_VAR : AST node of type ast.NonspecificCurVar</p>
<p>ELECTRODE_CUR_VAR : AST node of type ast.ElectrodeCurVar</p>
<p>SECTION_VAR : AST node of type ast.SectionVar</p>
<p>RANGE_VAR : AST node of type ast.RangeVar</p>
<p>GLOBAL_VAR : AST node of type ast.GlobalVar</p>
<p>POINTER_VAR : AST node of type ast.PointerVar</p>
<p>BBCORE_POINTER_VAR : AST node of type ast.BbcorePointerVar</p>
<p>EXTERN_VAR : AST node of type ast.ExternVar</p>
<p>THREADSAFE_VAR : AST node of type ast.ThreadsafeVar</p>
<p>PARAM_BLOCK : AST node of type ast.ParamBlock</p>
<p>STEP_BLOCK : AST node of type ast.StepBlock</p>
<p>INDEPENDENT_BLOCK : AST node of type ast.IndependentBlock</p>
<p>ASSIGNED_BLOCK : AST node of type ast.AssignedBlock</p>
<p>STATE_BLOCK : AST node of type ast.StateBlock</p>
<p>PLOT_BLOCK : AST node of type ast.PlotBlock</p>
<p>INITIAL_BLOCK : AST node of type ast.InitialBlock</p>
<p>CONSTRUCTOR_BLOCK : AST node of type ast.ConstructorBlock</p>
<p>DESTRUCTOR_BLOCK : AST node of type ast.DestructorBlock</p>
<p>STATEMENT_BLOCK : AST node of type ast.StatementBlock</p>
<p>DERIVATIVE_BLOCK : AST node of type ast.DerivativeBlock</p>
<p>LINEAR_BLOCK : AST node of type ast.LinearBlock</p>
<p>NON_LINEAR_BLOCK : AST node of type ast.NonLinearBlock</p>
<p>DISCRETE_BLOCK : AST node of type ast.DiscreteBlock</p>
<p>PARTIAL_BLOCK : AST node of type ast.PartialBlock</p>
<p>FUNCTION_TABLE_BLOCK : AST node of type ast.FunctionTableBlock</p>
<p>FUNCTION_BLOCK : AST node of type ast.FunctionBlock</p>
<p>PROCEDURE_BLOCK : AST node of type ast.ProcedureBlock</p>
<p>NET_RECEIVE_BLOCK : AST node of type ast.NetReceiveBlock</p>
<p>SOLVE_BLOCK : AST node of type ast.SolveBlock</p>
<p>BREAKPOINT_BLOCK : AST node of type ast.BreakpointBlock</p>
<p>TERMINAL_BLOCK : AST node of type ast.TerminalBlock</p>
<p>BEFORE_BLOCK : AST node of type ast.BeforeBlock</p>
<p>AFTER_BLOCK : AST node of type ast.AfterBlock</p>
<p>BA_BLOCK : AST node of type ast.BABlock</p>
<p>FOR_NETCON : AST node of type ast.ForNetcon</p>
<p>KINETIC_BLOCK : AST node of type ast.KineticBlock</p>
<p>MATCH_BLOCK : AST node of type ast.MatchBlock</p>
<p>UNIT_BLOCK : AST node of type ast.UnitBlock</p>
<p>CONSTANT_BLOCK : AST node of type ast.ConstantBlock</p>
<p>NEURON_BLOCK : AST node of type ast.NeuronBlock</p>
<p>UNIT : AST node of type ast.Unit</p>
<p>DOUBLE_UNIT : AST node of type ast.DoubleUnit</p>
<p>LOCAL_VAR : AST node of type ast.LocalVar</p>
<p>LIMITS : AST node of type ast.Limits</p>
<p>NUMBER_RANGE : AST node of type ast.NumberRange</p>
<p>PLOT_VAR : AST node of type ast.PlotVar</p>
<p>CONSTANT_VAR : AST node of type ast.ConstantVar</p>
<p>BINARY_OPERATOR : AST node of type ast.BinaryOperator</p>
<p>UNARY_OPERATOR : AST node of type ast.UnaryOperator</p>
<p>REACTION_OPERATOR : AST node of type ast.ReactionOperator</p>
<p>PAREN_EXPRESSION : AST node of type ast.ParenExpression</p>
<p>BINARY_EXPRESSION : AST node of type ast.BinaryExpression</p>
<p>DIFF_EQ_EXPRESSION : AST node of type ast.DiffEqExpression</p>
<p>UNARY_EXPRESSION : AST node of type ast.UnaryExpression</p>
<p>NON_LIN_EQUATION : AST node of type ast.NonLinEquation</p>
<p>LIN_EQUATION : AST node of type ast.LinEquation</p>
<p>FUNCTION_CALL : AST node of type ast.FunctionCall</p>
<p>FIRST_LAST_TYPE_INDEX : AST node of type ast.FirstLastTypeIndex</p>
<p>WATCH : AST node of type ast.Watch</p>
<p>QUEUE_EXPRESSION_TYPE : AST node of type ast.QueueExpressionType</p>
<p>MATCH : AST node of type ast.Match</p>
<p>BA_BLOCK_TYPE : AST node of type ast.BABlockType</p>
<p>UNIT_DEF : AST node of type ast.UnitDef</p>
<p>FACTOR_DEF : AST node of type ast.FactorDef</p>
<p>VALENCE : AST node of type ast.Valence</p>
<p>UNIT_STATE : AST node of type ast.UnitState</p>
<p>LOCAL_LIST_STATEMENT : AST node of type ast.LocalListStatement</p>
<p>MODEL : AST node of type ast.Model</p>
<p>DEFINE : AST node of type ast.Define</p>
<p>INCLUDE : AST node of type ast.Include</p>
<p>PARAM_ASSIGN : AST node of type ast.ParamAssign</p>
<p>STEPPED : AST node of type ast.Stepped</p>
<p>INDEPENDENT_DEFINITION : AST node of type ast.IndependentDefinition</p>
<p>ASSIGNED_DEFINITION : AST node of type ast.AssignedDefinition</p>
<p>PLOT_DECLARATION : AST node of type ast.PlotDeclaration</p>
<p>CONDUCTANCE_HINT : AST node of type ast.ConductanceHint</p>
<p>EXPRESSION_STATEMENT : AST node of type ast.ExpressionStatement</p>
<p>PROTECT_STATEMENT : AST node of type ast.ProtectStatement</p>
<p>FROM_STATEMENT : AST node of type ast.FromStatement</p>
<p>FOR_ALL_STATEMENT : AST node of type ast.ForAllStatement</p>
<p>WHILE_STATEMENT : AST node of type ast.WhileStatement</p>
<p>IF_STATEMENT : AST node of type ast.IfStatement</p>
<p>ELSE_IF_STATEMENT : AST node of type ast.ElseIfStatement</p>
<p>ELSE_STATEMENT : AST node of type ast.ElseStatement</p>
<p>PARTIAL_EQUATION : AST node of type ast.PartialEquation</p>
<p>PARTIAL_BOUNDARY : AST node of type ast.PartialBoundary</p>
<p>WATCH_STATEMENT : AST node of type ast.WatchStatement</p>
<p>MUTEX_LOCK : AST node of type ast.MutexLock</p>
<p>MUTEX_UNLOCK : AST node of type ast.MutexUnlock</p>
<p>RESET : AST node of type ast.Reset</p>
<p>SENS : AST node of type ast.Sens</p>
<p>CONSERVE : AST node of type ast.Conserve</p>
<p>COMPARTMENT : AST node of type ast.Compartment</p>
<p>LON_DIFUSE : AST node of type ast.LonDifuse</p>
<p>REACTION_STATEMENT : AST node of type ast.ReactionStatement</p>
<p>LAG_STATEMENT : AST node of type ast.LagStatement</p>
<p>QUEUE_STATEMENT : AST node of type ast.QueueStatement</p>
<p>CONSTANT_STATEMENT : AST node of type ast.ConstantStatement</p>
<p>TABLE_STATEMENT : AST node of type ast.TableStatement</p>
<p>SUFFIX : AST node of type ast.Suffix</p>
<p>USEION : AST node of type ast.Useion</p>
<p>NONSPECIFIC : AST node of type ast.Nonspecific</p>
<p>ELECTRODE_CURRENT : AST node of type ast.ElectrodeCurrent</p>
<p>SECTION : AST node of type ast.Section</p>
<p>RANGE : AST node of type ast.Range</p>
<p>GLOBAL : AST node of type ast.Global</p>
<p>POINTER : AST node of type ast.Pointer</p>
<p>BBCORE_POINTER : AST node of type ast.BbcorePointer</p>
<p>EXTERNAL : AST node of type ast.External</p>
<p>THREAD_SAFE : AST node of type ast.ThreadSafe</p>
<p>VERBATIM : AST node of type ast.Verbatim</p>
<p>LINE_COMMENT : AST node of type ast.LineComment</p>
<p>BLOCK_COMMENT : AST node of type ast.BlockComment</p>
<p>ONTOLOGY_STATEMENT : AST node of type ast.OntologyStatement</p>
<p>PROGRAM : AST node of type ast.Program</p>
<p>NRN_STATE_BLOCK : AST node of type ast.NrnStateBlock</p>
<p>EIGEN_NEWTON_SOLVER_BLOCK : AST node of type ast.EigenNewtonSolverBlock</p>
<p>EIGEN_LINEAR_SOLVER_BLOCK : AST node of type ast.EigenLinearSolverBlock</p>
<p>WRAPPED_EXPRESSION : AST node of type ast.WrappedExpression</p>
<p>DERIVIMPLICIT_CALLBACK : AST node of type ast.DerivimplicitCallback</p>
<p>SOLUTION_EXPRESSION : AST node of type ast.SolutionExpression</p>
<p>UPDATE_DT : AST node of type ast.UpdateDt</p>
</div></blockquote>
<dl class="method">
<dt id="nmodl.ast.AstNodeType.name">
<em class="property">property </em><code class="sig-name descname">name</code><a class="headerlink" href="#nmodl.ast.AstNodeType.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="nmodl.ast.AvailableDistributions">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">AvailableDistributions</code><a class="headerlink" href="#nmodl.ast.AvailableDistributions" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">pkg_resources.Environment</span></code></p>
</dd></dl>

<dl class="class">
<dt id="nmodl.ast.BABlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">BABlock</code><a class="headerlink" href="#nmodl.ast.BABlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>Represents a block to be executed before or after another block</p>
<dl class="method">
<dt id="nmodl.ast.BABlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.BABlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.BABlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.BABlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BABlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BABlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.BABlock<a class="headerlink" href="#nmodl.ast.BABlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BABlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BABlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.BABlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BABlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BABlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.BABlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BABlock.is_ba_block">
<code class="sig-name descname">is_ba_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BABlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.BABlock.is_ba_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.BABlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BABlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BABlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.BABlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.BABlockType">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">BABlockType</code><a class="headerlink" href="#nmodl.ast.BABlockType" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Expression</span></code></p>
<p>Type to represent different block types for before/after block</p>
<dl class="method">
<dt id="nmodl.ast.BABlockType.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.BABlockType.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.BABlockType, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.BABlockType, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BABlockType.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BABlockType</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.BABlockType<a class="headerlink" href="#nmodl.ast.BABlockType.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BABlockType.eval">
<code class="sig-name descname">eval</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BABlockType</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.BABlockType.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Return value of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BABlockType.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BABlockType</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.BABlockType.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BABlockType.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BABlockType</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.BABlockType.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BABlockType.is_ba_block_type">
<code class="sig-name descname">is_ba_block_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BABlockType</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.BABlockType.is_ba_block_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.BABlockType</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BABlockType.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BABlockType</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.BABlockType.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.BbcorePointer">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">BbcorePointer</code><a class="headerlink" href="#nmodl.ast.BbcorePointer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>Represents BBCOREPOINTER statement in NMODL</p>
<dl class="method">
<dt id="nmodl.ast.BbcorePointer.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.BbcorePointer.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.BbcorePointer, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.BbcorePointer, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BbcorePointer.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BbcorePointer</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.BbcorePointer<a class="headerlink" href="#nmodl.ast.BbcorePointer.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BbcorePointer.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BbcorePointer</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.BbcorePointer.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BbcorePointer.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BbcorePointer</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.BbcorePointer.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BbcorePointer.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BbcorePointer</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.BbcorePointer.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BbcorePointer.is_bbcore_pointer">
<code class="sig-name descname">is_bbcore_pointer</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BbcorePointer</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.BbcorePointer.is_bbcore_pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.BbcorePointer</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BbcorePointer.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BbcorePointer</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.BbcorePointer.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.BbcorePointerVar">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">BbcorePointerVar</code><a class="headerlink" href="#nmodl.ast.BbcorePointerVar" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Identifier</span></code></p>
<p>Represent a single variable of type BBCOREPOINTER</p>
<dl class="method">
<dt id="nmodl.ast.BbcorePointerVar.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.BbcorePointerVar.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.BbcorePointerVar, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.BbcorePointerVar, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BbcorePointerVar.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BbcorePointerVar</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.BbcorePointerVar<a class="headerlink" href="#nmodl.ast.BbcorePointerVar.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BbcorePointerVar.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BbcorePointerVar</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.BbcorePointerVar.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BbcorePointerVar.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BbcorePointerVar</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.BbcorePointerVar.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BbcorePointerVar.is_bbcore_pointer_var">
<code class="sig-name descname">is_bbcore_pointer_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BbcorePointerVar</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.BbcorePointerVar.is_bbcore_pointer_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.BbcorePointerVar</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BbcorePointerVar.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BbcorePointerVar</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.BbcorePointerVar.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.BeforeBlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">BeforeBlock</code><a class="headerlink" href="#nmodl.ast.BeforeBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>Represents a <cite>BEFORE</cite> block in NMODL</p>
<dl class="method">
<dt id="nmodl.ast.BeforeBlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.BeforeBlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.BeforeBlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.BeforeBlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BeforeBlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BeforeBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.BeforeBlock<a class="headerlink" href="#nmodl.ast.BeforeBlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BeforeBlock.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BeforeBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.BeforeBlock.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BeforeBlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BeforeBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.BeforeBlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BeforeBlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BeforeBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.BeforeBlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BeforeBlock.is_before_block">
<code class="sig-name descname">is_before_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BeforeBlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.BeforeBlock.is_before_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.BeforeBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BeforeBlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BeforeBlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.BeforeBlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.BinaryExpression">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">BinaryExpression</code><a class="headerlink" href="#nmodl.ast.BinaryExpression" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Expression</span></code></p>
<p>Represents binary expression in the NMODL</p>
<dl class="method">
<dt id="nmodl.ast.BinaryExpression.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.BinaryExpression.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.BinaryExpression, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.BinaryExpression, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BinaryExpression.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BinaryExpression</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.BinaryExpression<a class="headerlink" href="#nmodl.ast.BinaryExpression.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BinaryExpression.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BinaryExpression</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.BinaryExpression.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BinaryExpression.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BinaryExpression</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.BinaryExpression.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BinaryExpression.is_binary_expression">
<code class="sig-name descname">is_binary_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BinaryExpression</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.BinaryExpression.is_binary_expression" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.BinaryExpression</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BinaryExpression.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BinaryExpression</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.BinaryExpression.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.BinaryOp">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">BinaryOp</code><a class="headerlink" href="#nmodl.ast.BinaryOp" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_builtins.pybind11_object</span></code></p>
<blockquote>
<div><p>Enum type for binary operators in NMODL</p>
<p>NMODL support different binary operators and this
type is used to store their value in the AST. See
nmodl::ast::Ast for details.</p>
</div></blockquote>
<p>Members:</p>
<blockquote>
<div><p>BOP_ADDITION</p>
<p>BOP_SUBTRACTION</p>
<p>BOP_MULTIPLICATION</p>
<p>BOP_DIVISION</p>
<p>BOP_POWER</p>
<p>BOP_AND</p>
<p>BOP_OR</p>
<p>BOP_GREATER</p>
<p>BOP_LESS</p>
<p>BOP_GREATER_EQUAL</p>
<p>BOP_LESS_EQUAL</p>
<p>BOP_ASSIGN</p>
<p>BOP_NOT_EQUAL</p>
<p>BOP_EXACT_EQUAL</p>
</div></blockquote>
<dl class="method">
<dt id="nmodl.ast.BinaryOp.name">
<em class="property">property </em><code class="sig-name descname">name</code><a class="headerlink" href="#nmodl.ast.BinaryOp.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.BinaryOperator">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">BinaryOperator</code><a class="headerlink" href="#nmodl.ast.BinaryOperator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Expression</span></code></p>
<p>Operator used in ast::BinaryExpression</p>
<dl class="method">
<dt id="nmodl.ast.BinaryOperator.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.BinaryOperator.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.BinaryOperator, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.BinaryOperator, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BinaryOperator.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BinaryOperator</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.BinaryOperator<a class="headerlink" href="#nmodl.ast.BinaryOperator.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BinaryOperator.eval">
<code class="sig-name descname">eval</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BinaryOperator</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.BinaryOperator.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Return value of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BinaryOperator.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BinaryOperator</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.BinaryOperator.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BinaryOperator.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BinaryOperator</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.BinaryOperator.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BinaryOperator.is_binary_operator">
<code class="sig-name descname">is_binary_operator</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BinaryOperator</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.BinaryOperator.is_binary_operator" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.BinaryOperator</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BinaryOperator.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BinaryOperator</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.BinaryOperator.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Block">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Block</code><a class="headerlink" href="#nmodl.ast.Block" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Expression</span></code></p>
<p>Base class for all block scoped nodes</p>
<dl class="method">
<dt id="nmodl.ast.Block.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Block.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Block, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Block, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Block.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Block</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Block<a class="headerlink" href="#nmodl.ast.Block.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Block.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Block</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Block.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Block.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Block</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Block.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Block.is_block">
<code class="sig-name descname">is_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Block</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Block.is_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Block</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Block.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Block</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Block.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.BlockComment">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">BlockComment</code><a class="headerlink" href="#nmodl.ast.BlockComment" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>Represents a multi-line comment in NMODL</p>
<dl class="method">
<dt id="nmodl.ast.BlockComment.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.BlockComment.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.BlockComment, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.BlockComment, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BlockComment.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BlockComment</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.BlockComment<a class="headerlink" href="#nmodl.ast.BlockComment.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BlockComment.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BlockComment</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.BlockComment.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BlockComment.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BlockComment</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.BlockComment.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BlockComment.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BlockComment</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.BlockComment.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BlockComment.is_block_comment">
<code class="sig-name descname">is_block_comment</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BlockComment</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.BlockComment.is_block_comment" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.BlockComment</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BlockComment.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BlockComment</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.BlockComment.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Boolean">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Boolean</code><a class="headerlink" href="#nmodl.ast.Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Number</span></code></p>
<p>Represents a boolean variable</p>
<dl class="method">
<dt id="nmodl.ast.Boolean.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Boolean.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Boolean, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Boolean, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Boolean.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Boolean</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Boolean<a class="headerlink" href="#nmodl.ast.Boolean.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Boolean.eval">
<code class="sig-name descname">eval</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Boolean</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Boolean.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Return value of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Boolean.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Boolean</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Boolean.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Boolean.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Boolean</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Boolean.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Boolean.is_boolean">
<code class="sig-name descname">is_boolean</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Boolean</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Boolean.is_boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Boolean</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Boolean.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Boolean</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Boolean.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.BreakpointBlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">BreakpointBlock</code><a class="headerlink" href="#nmodl.ast.BreakpointBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>Represents a <cite>BREAKPOINT</cite> block in NMODL</p>
<dl class="method">
<dt id="nmodl.ast.BreakpointBlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.BreakpointBlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.BreakpointBlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.BreakpointBlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BreakpointBlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BreakpointBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.BreakpointBlock<a class="headerlink" href="#nmodl.ast.BreakpointBlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BreakpointBlock.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BreakpointBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.BreakpointBlock.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BreakpointBlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BreakpointBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.BreakpointBlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BreakpointBlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BreakpointBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.BreakpointBlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BreakpointBlock.is_breakpoint_block">
<code class="sig-name descname">is_breakpoint_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BreakpointBlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.BreakpointBlock.is_breakpoint_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.BreakpointBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.BreakpointBlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.BreakpointBlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.BreakpointBlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Compartment">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Compartment</code><a class="headerlink" href="#nmodl.ast.Compartment" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>Represent COMPARTMENT statement in NMODL</p>
<dl class="method">
<dt id="nmodl.ast.Compartment.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Compartment.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Compartment, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Compartment, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Compartment.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Compartment</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Compartment<a class="headerlink" href="#nmodl.ast.Compartment.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Compartment.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Compartment</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Compartment.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Compartment.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Compartment</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Compartment.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Compartment.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Compartment</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Compartment.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Compartment.is_compartment">
<code class="sig-name descname">is_compartment</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Compartment</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Compartment.is_compartment" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Compartment</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Compartment.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Compartment</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Compartment.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.ConductanceHint">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">ConductanceHint</code><a class="headerlink" href="#nmodl.ast.ConductanceHint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>Represents <cite>CONDUCTANCE</cite> statement in NMODL</p>
<dl class="method">
<dt id="nmodl.ast.ConductanceHint.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.ConductanceHint.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.ConductanceHint, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.ConductanceHint, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ConductanceHint.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ConductanceHint</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.ConductanceHint<a class="headerlink" href="#nmodl.ast.ConductanceHint.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ConductanceHint.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ConductanceHint</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ConductanceHint.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ConductanceHint.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ConductanceHint</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.ConductanceHint.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ConductanceHint.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ConductanceHint</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ConductanceHint.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ConductanceHint.is_conductance_hint">
<code class="sig-name descname">is_conductance_hint</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ConductanceHint</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.ConductanceHint.is_conductance_hint" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ConductanceHint</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ConductanceHint.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ConductanceHint</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.ConductanceHint.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Conserve">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Conserve</code><a class="headerlink" href="#nmodl.ast.Conserve" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>Represent CONSERVE statement in NMODL</p>
<dl class="method">
<dt id="nmodl.ast.Conserve.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Conserve.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Conserve, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Conserve, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Conserve.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Conserve</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Conserve<a class="headerlink" href="#nmodl.ast.Conserve.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Conserve.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Conserve</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Conserve.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Conserve.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Conserve</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Conserve.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Conserve.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Conserve</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Conserve.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Conserve.is_conserve">
<code class="sig-name descname">is_conserve</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Conserve</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Conserve.is_conserve" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Conserve</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Conserve.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Conserve</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Conserve.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.ConstantBlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">ConstantBlock</code><a class="headerlink" href="#nmodl.ast.ConstantBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>Represent <cite>CONSTANT</cite> block in the mod file</p>
<dl class="method">
<dt id="nmodl.ast.ConstantBlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.ConstantBlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.ConstantBlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.ConstantBlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ConstantBlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ConstantBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.ConstantBlock<a class="headerlink" href="#nmodl.ast.ConstantBlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ConstantBlock.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ConstantBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ConstantBlock.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ConstantBlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ConstantBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.ConstantBlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ConstantBlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ConstantBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ConstantBlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ConstantBlock.is_constant_block">
<code class="sig-name descname">is_constant_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ConstantBlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.ConstantBlock.is_constant_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ConstantBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ConstantBlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ConstantBlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.ConstantBlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.ConstantStatement">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">ConstantStatement</code><a class="headerlink" href="#nmodl.ast.ConstantStatement" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>Represent statement in CONSTANT block of NMODL</p>
<dl class="method">
<dt id="nmodl.ast.ConstantStatement.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.ConstantStatement.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.ConstantStatement, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.ConstantStatement, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ConstantStatement.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ConstantStatement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.ConstantStatement<a class="headerlink" href="#nmodl.ast.ConstantStatement.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ConstantStatement.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ConstantStatement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.ConstantStatement.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ConstantStatement.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ConstantStatement</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ConstantStatement.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ConstantStatement.is_constant_statement">
<code class="sig-name descname">is_constant_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ConstantStatement</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.ConstantStatement.is_constant_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ConstantStatement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ConstantStatement.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ConstantStatement</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.ConstantStatement.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.ConstantVar">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">ConstantVar</code><a class="headerlink" href="#nmodl.ast.ConstantVar" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Expression</span></code></p>
<p>Represents a variable in the ast::ConstantBlock</p>
<dl class="method">
<dt id="nmodl.ast.ConstantVar.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.ConstantVar.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.ConstantVar, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.ConstantVar, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ConstantVar.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ConstantVar</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.ConstantVar<a class="headerlink" href="#nmodl.ast.ConstantVar.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ConstantVar.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ConstantVar</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.ConstantVar.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ConstantVar.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ConstantVar</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ConstantVar.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ConstantVar.is_constant_var">
<code class="sig-name descname">is_constant_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ConstantVar</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.ConstantVar.is_constant_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ConstantVar</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ConstantVar.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ConstantVar</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.ConstantVar.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.ConstructorBlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">ConstructorBlock</code><a class="headerlink" href="#nmodl.ast.ConstructorBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>Represents a <cite>CONSTRUCTOR</cite> block in the NMODL</p>
<dl class="method">
<dt id="nmodl.ast.ConstructorBlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.ConstructorBlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.ConstructorBlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.ConstructorBlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ConstructorBlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ConstructorBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.ConstructorBlock<a class="headerlink" href="#nmodl.ast.ConstructorBlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ConstructorBlock.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ConstructorBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ConstructorBlock.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ConstructorBlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ConstructorBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.ConstructorBlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ConstructorBlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ConstructorBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ConstructorBlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ConstructorBlock.is_constructor_block">
<code class="sig-name descname">is_constructor_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ConstructorBlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.ConstructorBlock.is_constructor_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ConstructorBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ConstructorBlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ConstructorBlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.ConstructorBlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.DefaultProvider">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">DefaultProvider</code><span class="sig-paren">(</span><em class="sig-param">module</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#DefaultProvider"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.DefaultProvider" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pkg_resources.EggProvider</span></code></p>
<p>Provides access to package resources in the filesystem</p>
</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Define">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Define</code><a class="headerlink" href="#nmodl.ast.Define" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>Represents a <cite>DEFINE</cite> statement in NMODL</p>
<dl class="method">
<dt id="nmodl.ast.Define.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Define.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Define, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Define, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Define.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Define</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Define<a class="headerlink" href="#nmodl.ast.Define.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Define.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Define</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Define.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Define.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Define</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Define.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Define.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Define</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Define.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Define.is_define">
<code class="sig-name descname">is_define</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Define</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Define.is_define" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Define</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Define.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Define</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Define.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.DerivativeBlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">DerivativeBlock</code><a class="headerlink" href="#nmodl.ast.DerivativeBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>Represents <cite>DERIVATIVE</cite> block in the NMODL</p>
<dl class="method">
<dt id="nmodl.ast.DerivativeBlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.DerivativeBlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.DerivativeBlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.DerivativeBlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.DerivativeBlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.DerivativeBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.DerivativeBlock<a class="headerlink" href="#nmodl.ast.DerivativeBlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.DerivativeBlock.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.DerivativeBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.DerivativeBlock.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.DerivativeBlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.DerivativeBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.DerivativeBlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.DerivativeBlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.DerivativeBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.DerivativeBlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.DerivativeBlock.is_derivative_block">
<code class="sig-name descname">is_derivative_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.DerivativeBlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.DerivativeBlock.is_derivative_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.DerivativeBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.DerivativeBlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.DerivativeBlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.DerivativeBlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.DerivimplicitCallback">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">DerivimplicitCallback</code><a class="headerlink" href="#nmodl.ast.DerivimplicitCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Expression</span></code></p>
<p>Represent a callback to NEURON’s derivimplicit solver</p>
<dl class="method">
<dt id="nmodl.ast.DerivimplicitCallback.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.DerivimplicitCallback.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.DerivimplicitCallback, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.DerivimplicitCallback, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.DerivimplicitCallback.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.DerivimplicitCallback</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.DerivimplicitCallback<a class="headerlink" href="#nmodl.ast.DerivimplicitCallback.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.DerivimplicitCallback.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.DerivimplicitCallback</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.DerivimplicitCallback.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.DerivimplicitCallback.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.DerivimplicitCallback</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.DerivimplicitCallback.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.DerivimplicitCallback.is_derivimplicit_callback">
<code class="sig-name descname">is_derivimplicit_callback</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.DerivimplicitCallback</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.DerivimplicitCallback.is_derivimplicit_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.DerivimplicitCallback</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.DerivimplicitCallback.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.DerivimplicitCallback</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.DerivimplicitCallback.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.DestructorBlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">DestructorBlock</code><a class="headerlink" href="#nmodl.ast.DestructorBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>Represents a <cite>DESTRUCTOR</cite> block in the NMODL</p>
<dl class="method">
<dt id="nmodl.ast.DestructorBlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.DestructorBlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.DestructorBlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.DestructorBlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.DestructorBlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.DestructorBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.DestructorBlock<a class="headerlink" href="#nmodl.ast.DestructorBlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.DestructorBlock.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.DestructorBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.DestructorBlock.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.DestructorBlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.DestructorBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.DestructorBlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.DestructorBlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.DestructorBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.DestructorBlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.DestructorBlock.is_destructor_block">
<code class="sig-name descname">is_destructor_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.DestructorBlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.DestructorBlock.is_destructor_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.DestructorBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.DestructorBlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.DestructorBlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.DestructorBlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.DiffEqExpression">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">DiffEqExpression</code><a class="headerlink" href="#nmodl.ast.DiffEqExpression" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Expression</span></code></p>
<p>Represents differential equation in DERIVATIVE block</p>
<dl class="method">
<dt id="nmodl.ast.DiffEqExpression.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.DiffEqExpression.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.DiffEqExpression, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.DiffEqExpression, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.DiffEqExpression.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.DiffEqExpression</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.DiffEqExpression<a class="headerlink" href="#nmodl.ast.DiffEqExpression.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.DiffEqExpression.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.DiffEqExpression</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.DiffEqExpression.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.DiffEqExpression.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.DiffEqExpression</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.DiffEqExpression.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.DiffEqExpression.is_diff_eq_expression">
<code class="sig-name descname">is_diff_eq_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.DiffEqExpression</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.DiffEqExpression.is_diff_eq_expression" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.DiffEqExpression</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.DiffEqExpression.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.DiffEqExpression</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.DiffEqExpression.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.DiscreteBlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">DiscreteBlock</code><a class="headerlink" href="#nmodl.ast.DiscreteBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.DiscreteBlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.DiscreteBlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.DiscreteBlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.DiscreteBlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.DiscreteBlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.DiscreteBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.DiscreteBlock<a class="headerlink" href="#nmodl.ast.DiscreteBlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.DiscreteBlock.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.DiscreteBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.DiscreteBlock.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.DiscreteBlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.DiscreteBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.DiscreteBlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.DiscreteBlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.DiscreteBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.DiscreteBlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.DiscreteBlock.is_discrete_block">
<code class="sig-name descname">is_discrete_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.DiscreteBlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.DiscreteBlock.is_discrete_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.DiscreteBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.DiscreteBlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.DiscreteBlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.DiscreteBlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Distribution">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Distribution</code><span class="sig-paren">(</span><em class="sig-param">location=None</em>, <em class="sig-param">metadata=None</em>, <em class="sig-param">project_name=None</em>, <em class="sig-param">version=None</em>, <em class="sig-param">py_version='3.8'</em>, <em class="sig-param">platform=None</em>, <em class="sig-param">precedence=3</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Distribution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.Distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Wrap an actual or potential sys.path entry w/metadata</p>
<dl class="method">
<dt id="nmodl.ast.Distribution.activate">
<code class="sig-name descname">activate</code><span class="sig-paren">(</span><em class="sig-param">path=None</em>, <em class="sig-param">replace=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Distribution.activate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.Distribution.activate" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure distribution is importable on <cite>path</cite> (default=sys.path)</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Distribution.as_requirement">
<code class="sig-name descname">as_requirement</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Distribution.as_requirement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.Distribution.as_requirement" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <code class="docutils literal notranslate"><span class="pre">Requirement</span></code> that matches this distribution exactly</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Distribution.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">**kw</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Distribution.clone"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.Distribution.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy this distribution, substituting in any changed keyword args</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Distribution.egg_name">
<code class="sig-name descname">egg_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Distribution.egg_name"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.Distribution.egg_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return what this distribution’s standard .egg filename should be</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Distribution.get_entry_info">
<code class="sig-name descname">get_entry_info</code><span class="sig-paren">(</span><em class="sig-param">group</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Distribution.get_entry_info"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.Distribution.get_entry_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the EntryPoint object for <cite>group`+`name</cite>, or <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Distribution.get_entry_map">
<code class="sig-name descname">get_entry_map</code><span class="sig-paren">(</span><em class="sig-param">group=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Distribution.get_entry_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.Distribution.get_entry_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the entry point map for <cite>group</cite>, or the full entry map</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Distribution.insert_on">
<code class="sig-name descname">insert_on</code><span class="sig-paren">(</span><em class="sig-param">path</em>, <em class="sig-param">loc=None</em>, <em class="sig-param">replace=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Distribution.insert_on"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.Distribution.insert_on" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure self.location is on path</p>
<dl>
<dt>If replace=False (default):</dt><dd><ul>
<li><p>If location is already in path anywhere, do nothing.</p></li>
<li><p>Else:
- If it’s an egg and its parent directory is on path,</p>
<blockquote>
<div><p>insert just ahead of the parent.</p>
</div></blockquote>
<ul class="simple">
<li><p>Else: add to the end of path.</p></li>
</ul>
</li>
</ul>
</dd>
<dt>If replace=True:</dt><dd><ul>
<li><p>If location is already on path anywhere (not eggs)
or higher priority than its parent (eggs)
do nothing.</p></li>
<li><p>Else:
- If it’s an egg and its parent directory is on path,</p>
<blockquote>
<div><p>insert just ahead of the parent,
removing any lower-priority entries.</p>
</div></blockquote>
<ul class="simple">
<li><p>Else: add it to the front of path.</p></li>
</ul>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Distribution.load_entry_point">
<code class="sig-name descname">load_entry_point</code><span class="sig-paren">(</span><em class="sig-param">group</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Distribution.load_entry_point"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.Distribution.load_entry_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <cite>name</cite> entry point of <cite>group</cite> or raise ImportError</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Distribution.requires">
<code class="sig-name descname">requires</code><span class="sig-paren">(</span><em class="sig-param">extras=()</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Distribution.requires"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.Distribution.requires" title="Permalink to this definition">¶</a></dt>
<dd><p>List of Requirements needed for this distro if <cite>extras</cite> are used</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="nmodl.ast.DistributionNotFound">
<em class="property">exception </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">DistributionNotFound</code><a class="reference internal" href="_modules/pkg_resources.html#DistributionNotFound"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.DistributionNotFound" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pkg_resources.ResolutionError</span></code></p>
<p>A requested distribution was not found</p>
</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Double">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Double</code><a class="headerlink" href="#nmodl.ast.Double" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Number</span></code></p>
<p>Represents a double variable</p>
<dl class="method">
<dt id="nmodl.ast.Double.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Double.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Double, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Double, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Double.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Double</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Double<a class="headerlink" href="#nmodl.ast.Double.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Double.eval">
<code class="sig-name descname">eval</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Double</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Double.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Return value of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Double.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Double</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Double.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Double.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Double</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Double.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Double.is_double">
<code class="sig-name descname">is_double</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Double</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Double.is_double" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Double</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Double.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Double</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Double.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.DoubleUnit">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">DoubleUnit</code><a class="headerlink" href="#nmodl.ast.DoubleUnit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Expression</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.DoubleUnit.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.DoubleUnit.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.DoubleUnit, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.DoubleUnit, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.DoubleUnit.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.DoubleUnit</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.DoubleUnit<a class="headerlink" href="#nmodl.ast.DoubleUnit.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.DoubleUnit.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.DoubleUnit</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.DoubleUnit.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.DoubleUnit.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.DoubleUnit</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.DoubleUnit.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.DoubleUnit.is_double_unit">
<code class="sig-name descname">is_double_unit</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.DoubleUnit</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.DoubleUnit.is_double_unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.DoubleUnit</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.DoubleUnit.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.DoubleUnit</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.DoubleUnit.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.EggMetadata">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">EggMetadata</code><span class="sig-paren">(</span><em class="sig-param">importer</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#EggMetadata"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.EggMetadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pkg_resources.ZipProvider</span></code></p>
<p>Metadata provider for .egg files</p>
</dd></dl>

<dl class="class">
<dt id="nmodl.ast.EggProvider">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">EggProvider</code><span class="sig-paren">(</span><em class="sig-param">module</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#EggProvider"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.EggProvider" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pkg_resources.NullProvider</span></code></p>
<p>Provider based on a virtual filesystem</p>
</dd></dl>

<dl class="class">
<dt id="nmodl.ast.EigenLinearSolverBlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">EigenLinearSolverBlock</code><a class="headerlink" href="#nmodl.ast.EigenLinearSolverBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>Represent linear solver solution block based on Eigen</p>
<dl class="method">
<dt id="nmodl.ast.EigenLinearSolverBlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.EigenLinearSolverBlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.EigenLinearSolverBlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.EigenLinearSolverBlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.EigenLinearSolverBlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.EigenLinearSolverBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.EigenLinearSolverBlock<a class="headerlink" href="#nmodl.ast.EigenLinearSolverBlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.EigenLinearSolverBlock.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.EigenLinearSolverBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.EigenLinearSolverBlock.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.EigenLinearSolverBlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.EigenLinearSolverBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.EigenLinearSolverBlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.EigenLinearSolverBlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.EigenLinearSolverBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.EigenLinearSolverBlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.EigenLinearSolverBlock.is_eigen_linear_solver_block">
<code class="sig-name descname">is_eigen_linear_solver_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.EigenLinearSolverBlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.EigenLinearSolverBlock.is_eigen_linear_solver_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.EigenLinearSolverBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.EigenLinearSolverBlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.EigenLinearSolverBlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.EigenLinearSolverBlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.EigenNewtonSolverBlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">EigenNewtonSolverBlock</code><a class="headerlink" href="#nmodl.ast.EigenNewtonSolverBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>Represent newton solver solution block based on Eigen</p>
<dl class="method">
<dt id="nmodl.ast.EigenNewtonSolverBlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.EigenNewtonSolverBlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.EigenNewtonSolverBlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.EigenNewtonSolverBlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.EigenNewtonSolverBlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.EigenNewtonSolverBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.EigenNewtonSolverBlock<a class="headerlink" href="#nmodl.ast.EigenNewtonSolverBlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.EigenNewtonSolverBlock.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.EigenNewtonSolverBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.EigenNewtonSolverBlock.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.EigenNewtonSolverBlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.EigenNewtonSolverBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.EigenNewtonSolverBlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.EigenNewtonSolverBlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.EigenNewtonSolverBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.EigenNewtonSolverBlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.EigenNewtonSolverBlock.is_eigen_newton_solver_block">
<code class="sig-name descname">is_eigen_newton_solver_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.EigenNewtonSolverBlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.EigenNewtonSolverBlock.is_eigen_newton_solver_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.EigenNewtonSolverBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.EigenNewtonSolverBlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.EigenNewtonSolverBlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.EigenNewtonSolverBlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.ElectrodeCurVar">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">ElectrodeCurVar</code><a class="headerlink" href="#nmodl.ast.ElectrodeCurVar" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Identifier</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.ElectrodeCurVar.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.ElectrodeCurVar.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.ElectrodeCurVar, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.ElectrodeCurVar, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ElectrodeCurVar.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ElectrodeCurVar</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.ElectrodeCurVar<a class="headerlink" href="#nmodl.ast.ElectrodeCurVar.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ElectrodeCurVar.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ElectrodeCurVar</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.ElectrodeCurVar.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ElectrodeCurVar.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ElectrodeCurVar</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ElectrodeCurVar.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ElectrodeCurVar.is_electrode_cur_var">
<code class="sig-name descname">is_electrode_cur_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ElectrodeCurVar</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.ElectrodeCurVar.is_electrode_cur_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ElectrodeCurVar</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ElectrodeCurVar.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ElectrodeCurVar</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.ElectrodeCurVar.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.ElectrodeCurrent">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">ElectrodeCurrent</code><a class="headerlink" href="#nmodl.ast.ElectrodeCurrent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>Represents ELECTRODE_CURRENT variables statement in NMODL</p>
<dl class="method">
<dt id="nmodl.ast.ElectrodeCurrent.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.ElectrodeCurrent.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.ElectrodeCurrent, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.ElectrodeCurrent, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ElectrodeCurrent.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ElectrodeCurrent</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.ElectrodeCurrent<a class="headerlink" href="#nmodl.ast.ElectrodeCurrent.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ElectrodeCurrent.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ElectrodeCurrent</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ElectrodeCurrent.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ElectrodeCurrent.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ElectrodeCurrent</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.ElectrodeCurrent.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ElectrodeCurrent.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ElectrodeCurrent</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ElectrodeCurrent.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ElectrodeCurrent.is_electrode_current">
<code class="sig-name descname">is_electrode_current</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ElectrodeCurrent</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.ElectrodeCurrent.is_electrode_current" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ElectrodeCurrent</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ElectrodeCurrent.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ElectrodeCurrent</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.ElectrodeCurrent.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.ElseIfStatement">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">ElseIfStatement</code><a class="headerlink" href="#nmodl.ast.ElseIfStatement" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.ElseIfStatement.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.ElseIfStatement.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.ElseIfStatement, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.ElseIfStatement, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ElseIfStatement.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ElseIfStatement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.ElseIfStatement<a class="headerlink" href="#nmodl.ast.ElseIfStatement.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ElseIfStatement.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ElseIfStatement</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ElseIfStatement.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ElseIfStatement.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ElseIfStatement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.ElseIfStatement.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ElseIfStatement.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ElseIfStatement</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ElseIfStatement.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ElseIfStatement.is_else_if_statement">
<code class="sig-name descname">is_else_if_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ElseIfStatement</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.ElseIfStatement.is_else_if_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ElseIfStatement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ElseIfStatement.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ElseIfStatement</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.ElseIfStatement.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.ElseStatement">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">ElseStatement</code><a class="headerlink" href="#nmodl.ast.ElseStatement" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.ElseStatement.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.ElseStatement.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.ElseStatement, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.ElseStatement, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ElseStatement.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ElseStatement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.ElseStatement<a class="headerlink" href="#nmodl.ast.ElseStatement.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ElseStatement.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ElseStatement</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ElseStatement.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ElseStatement.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ElseStatement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.ElseStatement.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ElseStatement.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ElseStatement</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ElseStatement.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ElseStatement.is_else_statement">
<code class="sig-name descname">is_else_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ElseStatement</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.ElseStatement.is_else_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ElseStatement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ElseStatement.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ElseStatement</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.ElseStatement.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.EmptyProvider">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">EmptyProvider</code><a class="reference internal" href="_modules/pkg_resources.html#EmptyProvider"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.EmptyProvider" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pkg_resources.NullProvider</span></code></p>
<p>Provider that returns nothing for all requests</p>
</dd></dl>

<dl class="class">
<dt id="nmodl.ast.EntryPoint">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">EntryPoint</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">module_name</em>, <em class="sig-param">attrs=()</em>, <em class="sig-param">extras=()</em>, <em class="sig-param">dist=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#EntryPoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.EntryPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Object representing an advertised importable object</p>
<dl class="method">
<dt id="nmodl.ast.EntryPoint.load">
<code class="sig-name descname">load</code><span class="sig-paren">(</span><em class="sig-param">require=True</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#EntryPoint.load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.EntryPoint.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Require packages for this EntryPoint, then resolve it.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.EntryPoint.parse">
<em class="property">classmethod </em><code class="sig-name descname">parse</code><span class="sig-paren">(</span><em class="sig-param">src</em>, <em class="sig-param">dist=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#EntryPoint.parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.EntryPoint.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a single entry point from string <cite>src</cite></p>
<p>Entry point syntax follows the form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">name</span> <span class="o">=</span> <span class="n">some</span><span class="o">.</span><span class="n">module</span><span class="p">:</span><span class="n">some</span><span class="o">.</span><span class="n">attr</span> <span class="p">[</span><span class="n">extra1</span><span class="p">,</span> <span class="n">extra2</span><span class="p">]</span>
</pre></div>
</div>
<p>The entry name and module name are required, but the <code class="docutils literal notranslate"><span class="pre">:attrs</span></code> and
<code class="docutils literal notranslate"><span class="pre">[extras]</span></code> parts are optional</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.EntryPoint.parse_group">
<em class="property">classmethod </em><code class="sig-name descname">parse_group</code><span class="sig-paren">(</span><em class="sig-param">group</em>, <em class="sig-param">lines</em>, <em class="sig-param">dist=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#EntryPoint.parse_group"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.EntryPoint.parse_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse an entry point group</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.EntryPoint.parse_map">
<em class="property">classmethod </em><code class="sig-name descname">parse_map</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">dist=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#EntryPoint.parse_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.EntryPoint.parse_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a map of entry point groups</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.EntryPoint.resolve">
<code class="sig-name descname">resolve</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#EntryPoint.resolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.EntryPoint.resolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Resolve the entry point from its module and attrs.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Environment">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Environment</code><span class="sig-paren">(</span><em class="sig-param">search_path=None</em>, <em class="sig-param">platform='linux-x86_64'</em>, <em class="sig-param">python='3.8'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Environment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.Environment" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Searchable snapshot of distributions on a search path</p>
<dl class="method">
<dt id="nmodl.ast.Environment.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param">dist</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Environment.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.Environment.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add <cite>dist</cite> if we <code class="docutils literal notranslate"><span class="pre">can_add()</span></code> it and it has not already been added</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Environment.best_match">
<code class="sig-name descname">best_match</code><span class="sig-paren">(</span><em class="sig-param">req</em>, <em class="sig-param">working_set</em>, <em class="sig-param">installer=None</em>, <em class="sig-param">replace_conflicting=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Environment.best_match"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.Environment.best_match" title="Permalink to this definition">¶</a></dt>
<dd><p>Find distribution best matching <cite>req</cite> and usable on <cite>working_set</cite></p>
<p>This calls the <code class="docutils literal notranslate"><span class="pre">find(req)</span></code> method of the <cite>working_set</cite> to see if a
suitable distribution is already active.  (This may raise
<code class="docutils literal notranslate"><span class="pre">VersionConflict</span></code> if an unsuitable version of the project is already
active in the specified <cite>working_set</cite>.)  If a suitable distribution
isn’t active, this method returns the newest distribution in the
environment that meets the <code class="docutils literal notranslate"><span class="pre">Requirement</span></code> in <cite>req</cite>.  If no suitable
distribution is found, and <cite>installer</cite> is supplied, then the result of
calling the environment’s <code class="docutils literal notranslate"><span class="pre">obtain(req,</span> <span class="pre">installer)</span></code> method will be
returned.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Environment.can_add">
<code class="sig-name descname">can_add</code><span class="sig-paren">(</span><em class="sig-param">dist</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Environment.can_add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.Environment.can_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Is distribution <cite>dist</cite> acceptable for this environment?</p>
<p>The distribution must match the platform and python version
requirements specified when this environment was created, or False
is returned.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Environment.obtain">
<code class="sig-name descname">obtain</code><span class="sig-paren">(</span><em class="sig-param">requirement</em>, <em class="sig-param">installer=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Environment.obtain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.Environment.obtain" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain a distribution matching <cite>requirement</cite> (e.g. via download)</p>
<p>Obtain a distro that matches requirement (e.g. via download).  In the
base <code class="docutils literal notranslate"><span class="pre">Environment</span></code> class, this routine just returns
<code class="docutils literal notranslate"><span class="pre">installer(requirement)</span></code>, unless <cite>installer</cite> is None, in which case
None is returned instead.  This method is a hook that allows subclasses
to attempt other ways of obtaining a distribution before falling back
to the <cite>installer</cite> argument.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Environment.remove">
<code class="sig-name descname">remove</code><span class="sig-paren">(</span><em class="sig-param">dist</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Environment.remove"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.Environment.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove <cite>dist</cite> from the environment</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Environment.scan">
<code class="sig-name descname">scan</code><span class="sig-paren">(</span><em class="sig-param">search_path=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Environment.scan"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.Environment.scan" title="Permalink to this definition">¶</a></dt>
<dd><p>Scan <cite>search_path</cite> for distributions usable in this environment</p>
<p>Any distributions found are added to the environment.
<cite>search_path</cite> should be a sequence of <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> items.  If not
supplied, <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> is used.  Only distributions conforming to
the platform/python version defined at initialization are added.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Expression">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Expression</code><a class="headerlink" href="#nmodl.ast.Expression" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Node</span></code></p>
<p>Base class for all expressions in the NMODL</p>
<dl class="method">
<dt id="nmodl.ast.Expression.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Expression.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Expression, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Expression, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Expression.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Expression</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Expression<a class="headerlink" href="#nmodl.ast.Expression.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Expression.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Expression</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Expression.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Expression.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Expression</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Expression.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Expression.is_expression">
<code class="sig-name descname">is_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Expression</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Expression.is_expression" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Expression</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Expression.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Expression</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Expression.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.ExpressionStatement">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">ExpressionStatement</code><a class="headerlink" href="#nmodl.ast.ExpressionStatement" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.ExpressionStatement.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.ExpressionStatement.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.ExpressionStatement, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.ExpressionStatement, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ExpressionStatement.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ExpressionStatement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.ExpressionStatement<a class="headerlink" href="#nmodl.ast.ExpressionStatement.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ExpressionStatement.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ExpressionStatement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.ExpressionStatement.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ExpressionStatement.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ExpressionStatement</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ExpressionStatement.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ExpressionStatement.is_expression_statement">
<code class="sig-name descname">is_expression_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ExpressionStatement</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.ExpressionStatement.is_expression_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ExpressionStatement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ExpressionStatement.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ExpressionStatement</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.ExpressionStatement.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.ExternVar">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">ExternVar</code><a class="headerlink" href="#nmodl.ast.ExternVar" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Identifier</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.ExternVar.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.ExternVar.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.ExternVar, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.ExternVar, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ExternVar.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ExternVar</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.ExternVar<a class="headerlink" href="#nmodl.ast.ExternVar.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ExternVar.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ExternVar</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.ExternVar.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ExternVar.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ExternVar</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ExternVar.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ExternVar.is_extern_var">
<code class="sig-name descname">is_extern_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ExternVar</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.ExternVar.is_extern_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ExternVar</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ExternVar.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ExternVar</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.ExternVar.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.External">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">External</code><a class="headerlink" href="#nmodl.ast.External" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>Represents EXTERNAL statement in NMODL</p>
<dl class="method">
<dt id="nmodl.ast.External.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.External.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.External, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.External, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.External.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.External</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.External<a class="headerlink" href="#nmodl.ast.External.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.External.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.External</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.External.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.External.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.External</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.External.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.External.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.External</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.External.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.External.is_external">
<code class="sig-name descname">is_external</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.External</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.External.is_external" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.External</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.External.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.External</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.External.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="nmodl.ast.ExtractionError">
<em class="property">exception </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">ExtractionError</code><a class="reference internal" href="_modules/pkg_resources.html#ExtractionError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.ExtractionError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">RuntimeError</span></code></p>
<p>An error occurred extracting a resource</p>
<p>The following attributes are available from instances of this exception:</p>
<dl class="simple">
<dt>manager</dt><dd><p>The resource manager that raised this exception</p>
</dd>
<dt>cache_path</dt><dd><p>The base directory for resource extraction</p>
</dd>
<dt>original_error</dt><dd><p>The exception instance that caused extraction to fail</p>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nmodl.ast.FactorDef">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">FactorDef</code><a class="headerlink" href="#nmodl.ast.FactorDef" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Expression</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.FactorDef.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.FactorDef.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.FactorDef, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.FactorDef, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FactorDef.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FactorDef</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.FactorDef<a class="headerlink" href="#nmodl.ast.FactorDef.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FactorDef.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FactorDef</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.FactorDef.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FactorDef.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FactorDef</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.FactorDef.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FactorDef.is_factor_def">
<code class="sig-name descname">is_factor_def</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FactorDef</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.FactorDef.is_factor_def" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.FactorDef</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FactorDef.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FactorDef</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.FactorDef.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.FileMetadata">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">FileMetadata</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#FileMetadata"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.FileMetadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pkg_resources.EmptyProvider</span></code></p>
<p>Metadata handler for standalone PKG-INFO files</p>
<p>Usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">metadata</span> <span class="o">=</span> <span class="n">FileMetadata</span><span class="p">(</span><span class="s2">&quot;/path/to/PKG-INFO&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>This provider rejects all data and metadata requests except for PKG-INFO,
which is treated as existing, and will be the contents of the file at
the provided location.</p>
</dd></dl>

<dl class="class">
<dt id="nmodl.ast.FirstLastTypeIndex">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">FirstLastTypeIndex</code><a class="headerlink" href="#nmodl.ast.FirstLastTypeIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Expression</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.FirstLastTypeIndex.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.FirstLastTypeIndex.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.FirstLastTypeIndex, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.FirstLastTypeIndex, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FirstLastTypeIndex.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FirstLastTypeIndex</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.FirstLastTypeIndex<a class="headerlink" href="#nmodl.ast.FirstLastTypeIndex.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FirstLastTypeIndex.eval">
<code class="sig-name descname">eval</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FirstLastTypeIndex</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.FirstLastTypeIndex.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Return value of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FirstLastTypeIndex.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FirstLastTypeIndex</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.FirstLastTypeIndex.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FirstLastTypeIndex.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FirstLastTypeIndex</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.FirstLastTypeIndex.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FirstLastTypeIndex.is_first_last_type_index">
<code class="sig-name descname">is_first_last_type_index</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FirstLastTypeIndex</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.FirstLastTypeIndex.is_first_last_type_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.FirstLastTypeIndex</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FirstLastTypeIndex.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FirstLastTypeIndex</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.FirstLastTypeIndex.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Float">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Float</code><a class="headerlink" href="#nmodl.ast.Float" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Number</span></code></p>
<p>Represents a float variable</p>
<dl class="method">
<dt id="nmodl.ast.Float.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Float.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Float, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Float, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Float.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Float</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Float<a class="headerlink" href="#nmodl.ast.Float.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Float.eval">
<code class="sig-name descname">eval</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Float</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Float.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Return value of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Float.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Float</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Float.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Float.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Float</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Float.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Float.is_float">
<code class="sig-name descname">is_float</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Float</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Float.is_float" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Float</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Float.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Float</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Float.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.ForAllStatement">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">ForAllStatement</code><a class="headerlink" href="#nmodl.ast.ForAllStatement" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.ForAllStatement.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.ForAllStatement.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.ForAllStatement, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.ForAllStatement, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ForAllStatement.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ForAllStatement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.ForAllStatement<a class="headerlink" href="#nmodl.ast.ForAllStatement.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ForAllStatement.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ForAllStatement</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ForAllStatement.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ForAllStatement.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ForAllStatement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.ForAllStatement.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ForAllStatement.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ForAllStatement</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ForAllStatement.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ForAllStatement.is_for_all_statement">
<code class="sig-name descname">is_for_all_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ForAllStatement</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.ForAllStatement.is_for_all_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ForAllStatement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ForAllStatement.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ForAllStatement</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.ForAllStatement.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.ForNetcon">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">ForNetcon</code><a class="headerlink" href="#nmodl.ast.ForNetcon" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.ForNetcon.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.ForNetcon.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.ForNetcon, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.ForNetcon, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ForNetcon.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ForNetcon</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.ForNetcon<a class="headerlink" href="#nmodl.ast.ForNetcon.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ForNetcon.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ForNetcon</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ForNetcon.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ForNetcon.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ForNetcon</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.ForNetcon.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ForNetcon.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ForNetcon</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ForNetcon.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ForNetcon.is_for_netcon">
<code class="sig-name descname">is_for_netcon</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ForNetcon</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.ForNetcon.is_for_netcon" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ForNetcon</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ForNetcon.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ForNetcon</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.ForNetcon.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.FromStatement">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">FromStatement</code><a class="headerlink" href="#nmodl.ast.FromStatement" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.FromStatement.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.FromStatement.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.FromStatement, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.FromStatement, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FromStatement.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FromStatement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.FromStatement<a class="headerlink" href="#nmodl.ast.FromStatement.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FromStatement.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FromStatement</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.FromStatement.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FromStatement.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FromStatement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.FromStatement.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FromStatement.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FromStatement</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.FromStatement.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FromStatement.is_from_statement">
<code class="sig-name descname">is_from_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FromStatement</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.FromStatement.is_from_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.FromStatement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FromStatement.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FromStatement</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.FromStatement.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.FunctionBlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">FunctionBlock</code><a class="headerlink" href="#nmodl.ast.FunctionBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.FunctionBlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.FunctionBlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.FunctionBlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.FunctionBlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FunctionBlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FunctionBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.FunctionBlock<a class="headerlink" href="#nmodl.ast.FunctionBlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FunctionBlock.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FunctionBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.FunctionBlock.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FunctionBlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FunctionBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.FunctionBlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FunctionBlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FunctionBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.FunctionBlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FunctionBlock.is_function_block">
<code class="sig-name descname">is_function_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FunctionBlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.FunctionBlock.is_function_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.FunctionBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FunctionBlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FunctionBlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.FunctionBlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.FunctionCall">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">FunctionCall</code><a class="headerlink" href="#nmodl.ast.FunctionCall" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Expression</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.FunctionCall.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.FunctionCall.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.FunctionCall, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.FunctionCall, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FunctionCall.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FunctionCall</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.FunctionCall<a class="headerlink" href="#nmodl.ast.FunctionCall.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FunctionCall.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FunctionCall</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.FunctionCall.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FunctionCall.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FunctionCall</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.FunctionCall.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FunctionCall.is_function_call">
<code class="sig-name descname">is_function_call</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FunctionCall</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.FunctionCall.is_function_call" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.FunctionCall</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FunctionCall.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FunctionCall</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.FunctionCall.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.FunctionTableBlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">FunctionTableBlock</code><a class="headerlink" href="#nmodl.ast.FunctionTableBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.FunctionTableBlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.FunctionTableBlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.FunctionTableBlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.FunctionTableBlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FunctionTableBlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FunctionTableBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.FunctionTableBlock<a class="headerlink" href="#nmodl.ast.FunctionTableBlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FunctionTableBlock.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FunctionTableBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.FunctionTableBlock.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FunctionTableBlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FunctionTableBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.FunctionTableBlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FunctionTableBlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FunctionTableBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.FunctionTableBlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FunctionTableBlock.is_function_table_block">
<code class="sig-name descname">is_function_table_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FunctionTableBlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.FunctionTableBlock.is_function_table_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.FunctionTableBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.FunctionTableBlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.FunctionTableBlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.FunctionTableBlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Global">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Global</code><a class="headerlink" href="#nmodl.ast.Global" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>Represents GLOBAL statement in NMODL</p>
<dl class="method">
<dt id="nmodl.ast.Global.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Global.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Global, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Global, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Global.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Global</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Global<a class="headerlink" href="#nmodl.ast.Global.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Global.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Global</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Global.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Global.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Global</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Global.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Global.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Global</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Global.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Global.is_global">
<code class="sig-name descname">is_global</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Global</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Global.is_global" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Global</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Global.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Global</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Global.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.GlobalVar">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">GlobalVar</code><a class="headerlink" href="#nmodl.ast.GlobalVar" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Identifier</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.GlobalVar.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.GlobalVar.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.GlobalVar, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.GlobalVar, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.GlobalVar.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.GlobalVar</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.GlobalVar<a class="headerlink" href="#nmodl.ast.GlobalVar.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.GlobalVar.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.GlobalVar</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.GlobalVar.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.GlobalVar.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.GlobalVar</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.GlobalVar.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.GlobalVar.is_global_var">
<code class="sig-name descname">is_global_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.GlobalVar</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.GlobalVar.is_global_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.GlobalVar</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.GlobalVar.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.GlobalVar</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.GlobalVar.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.IResourceProvider">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">IResourceProvider</code><a class="reference internal" href="_modules/pkg_resources.html#IResourceProvider"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.IResourceProvider" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pkg_resources.IMetadataProvider</span></code></p>
<p>An object that provides access to package resources</p>
<dl class="method">
<dt id="nmodl.ast.IResourceProvider.get_resource_filename">
<code class="sig-name descname">get_resource_filename</code><span class="sig-paren">(</span><em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#IResourceProvider.get_resource_filename"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.IResourceProvider.get_resource_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a true filesystem path for <cite>resource_name</cite></p>
<p><cite>manager</cite> must be an <code class="docutils literal notranslate"><span class="pre">IResourceManager</span></code></p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.IResourceProvider.get_resource_stream">
<code class="sig-name descname">get_resource_stream</code><span class="sig-paren">(</span><em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#IResourceProvider.get_resource_stream"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.IResourceProvider.get_resource_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a readable file-like object for <cite>resource_name</cite></p>
<p><cite>manager</cite> must be an <code class="docutils literal notranslate"><span class="pre">IResourceManager</span></code></p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.IResourceProvider.get_resource_string">
<code class="sig-name descname">get_resource_string</code><span class="sig-paren">(</span><em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#IResourceProvider.get_resource_string"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.IResourceProvider.get_resource_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string containing the contents of <cite>resource_name</cite></p>
<p><cite>manager</cite> must be an <code class="docutils literal notranslate"><span class="pre">IResourceManager</span></code></p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.IResourceProvider.has_resource">
<code class="sig-name descname">has_resource</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#IResourceProvider.has_resource"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.IResourceProvider.has_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>Does the package contain the named resource?</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.IResourceProvider.resource_isdir">
<code class="sig-name descname">resource_isdir</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#IResourceProvider.resource_isdir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.IResourceProvider.resource_isdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the named resource a directory?  (like <code class="docutils literal notranslate"><span class="pre">os.path.isdir()</span></code>)</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.IResourceProvider.resource_listdir">
<code class="sig-name descname">resource_listdir</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#IResourceProvider.resource_listdir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.IResourceProvider.resource_listdir" title="Permalink to this definition">¶</a></dt>
<dd><p>List of resource names in the directory (like <code class="docutils literal notranslate"><span class="pre">os.listdir()</span></code>)</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Identifier">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Identifier</code><a class="headerlink" href="#nmodl.ast.Identifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Expression</span></code></p>
<p>Base class for all identifiers</p>
<dl class="method">
<dt id="nmodl.ast.Identifier.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Identifier.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Identifier, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Identifier, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Identifier.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Identifier</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Identifier<a class="headerlink" href="#nmodl.ast.Identifier.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Identifier.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Identifier</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Identifier.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Identifier.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Identifier</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Identifier.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Identifier.is_identifier">
<code class="sig-name descname">is_identifier</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Identifier</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Identifier.is_identifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Identifier</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Identifier.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Identifier</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Identifier.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.IfStatement">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">IfStatement</code><a class="headerlink" href="#nmodl.ast.IfStatement" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.IfStatement.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.IfStatement.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.IfStatement, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.IfStatement, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.IfStatement.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.IfStatement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.IfStatement<a class="headerlink" href="#nmodl.ast.IfStatement.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.IfStatement.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.IfStatement</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.IfStatement.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.IfStatement.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.IfStatement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.IfStatement.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.IfStatement.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.IfStatement</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.IfStatement.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.IfStatement.is_if_statement">
<code class="sig-name descname">is_if_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.IfStatement</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.IfStatement.is_if_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.IfStatement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.IfStatement.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.IfStatement</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.IfStatement.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Include">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Include</code><a class="headerlink" href="#nmodl.ast.Include" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>Represents an <cite>INCLUDE</cite> statement in NMODL</p>
<dl class="method">
<dt id="nmodl.ast.Include.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Include.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Include, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Include, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Include.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Include</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Include<a class="headerlink" href="#nmodl.ast.Include.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Include.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Include</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Include.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Include.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Include</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Include.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Include.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Include</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Include.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Include.is_include">
<code class="sig-name descname">is_include</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Include</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Include.is_include" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Include</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Include.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Include</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Include.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.IndependentBlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">IndependentBlock</code><a class="headerlink" href="#nmodl.ast.IndependentBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>Represents a <cite>INDEPENDENT</cite> block in the NMODL</p>
<dl class="method">
<dt id="nmodl.ast.IndependentBlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.IndependentBlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.IndependentBlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.IndependentBlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.IndependentBlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.IndependentBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.IndependentBlock<a class="headerlink" href="#nmodl.ast.IndependentBlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.IndependentBlock.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.IndependentBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.IndependentBlock.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.IndependentBlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.IndependentBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.IndependentBlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.IndependentBlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.IndependentBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.IndependentBlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.IndependentBlock.is_independent_block">
<code class="sig-name descname">is_independent_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.IndependentBlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.IndependentBlock.is_independent_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.IndependentBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.IndependentBlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.IndependentBlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.IndependentBlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.IndependentDefinition">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">IndependentDefinition</code><a class="headerlink" href="#nmodl.ast.IndependentDefinition" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.IndependentDefinition.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.IndependentDefinition.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.IndependentDefinition, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.IndependentDefinition, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.IndependentDefinition.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.IndependentDefinition</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.IndependentDefinition<a class="headerlink" href="#nmodl.ast.IndependentDefinition.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.IndependentDefinition.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.IndependentDefinition</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.IndependentDefinition.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.IndependentDefinition.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.IndependentDefinition</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.IndependentDefinition.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.IndependentDefinition.is_independent_definition">
<code class="sig-name descname">is_independent_definition</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.IndependentDefinition</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.IndependentDefinition.is_independent_definition" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.IndependentDefinition</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.IndependentDefinition.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.IndependentDefinition</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.IndependentDefinition.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.IndexedName">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">IndexedName</code><a class="headerlink" href="#nmodl.ast.IndexedName" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Identifier</span></code></p>
<p>Represents specific element of an array variable</p>
<dl class="method">
<dt id="nmodl.ast.IndexedName.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.IndexedName.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.IndexedName, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.IndexedName, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.IndexedName.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.IndexedName</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.IndexedName<a class="headerlink" href="#nmodl.ast.IndexedName.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.IndexedName.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.IndexedName</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.IndexedName.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.IndexedName.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.IndexedName</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.IndexedName.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.IndexedName.is_indexed_name">
<code class="sig-name descname">is_indexed_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.IndexedName</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.IndexedName.is_indexed_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.IndexedName</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.IndexedName.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.IndexedName</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.IndexedName.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.InitialBlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">InitialBlock</code><a class="headerlink" href="#nmodl.ast.InitialBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>Represents a <cite>INITIAL</cite> block in the NMODL</p>
<dl class="method">
<dt id="nmodl.ast.InitialBlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.InitialBlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.InitialBlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.InitialBlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.InitialBlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.InitialBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.InitialBlock<a class="headerlink" href="#nmodl.ast.InitialBlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.InitialBlock.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.InitialBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.InitialBlock.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.InitialBlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.InitialBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.InitialBlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.InitialBlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.InitialBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.InitialBlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.InitialBlock.is_initial_block">
<code class="sig-name descname">is_initial_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.InitialBlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.InitialBlock.is_initial_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.InitialBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.InitialBlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.InitialBlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.InitialBlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Integer">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Integer</code><a class="headerlink" href="#nmodl.ast.Integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Number</span></code></p>
<p>Represents an integer variable</p>
<dl class="method">
<dt id="nmodl.ast.Integer.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Integer.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Integer, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Integer, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Integer.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Integer</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Integer<a class="headerlink" href="#nmodl.ast.Integer.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Integer.eval">
<code class="sig-name descname">eval</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Integer</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#nmodl.ast.Integer.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Return value of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Integer.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Integer</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Integer.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Integer.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Integer</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Integer.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Integer.is_integer">
<code class="sig-name descname">is_integer</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Integer</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Integer.is_integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Integer</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Integer.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Integer</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Integer.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.KineticBlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">KineticBlock</code><a class="headerlink" href="#nmodl.ast.KineticBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.KineticBlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.KineticBlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.KineticBlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.KineticBlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.KineticBlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.KineticBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.KineticBlock<a class="headerlink" href="#nmodl.ast.KineticBlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.KineticBlock.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.KineticBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.KineticBlock.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.KineticBlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.KineticBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.KineticBlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.KineticBlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.KineticBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.KineticBlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.KineticBlock.is_kinetic_block">
<code class="sig-name descname">is_kinetic_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.KineticBlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.KineticBlock.is_kinetic_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.KineticBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.KineticBlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.KineticBlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.KineticBlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.LagStatement">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">LagStatement</code><a class="headerlink" href="#nmodl.ast.LagStatement" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>Represents a LAG statement in the mod file</p>
<dl class="method">
<dt id="nmodl.ast.LagStatement.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.LagStatement.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.LagStatement, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.LagStatement, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LagStatement.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LagStatement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.LagStatement<a class="headerlink" href="#nmodl.ast.LagStatement.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LagStatement.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LagStatement</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.LagStatement.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LagStatement.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LagStatement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.LagStatement.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LagStatement.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LagStatement</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.LagStatement.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LagStatement.is_lag_statement">
<code class="sig-name descname">is_lag_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LagStatement</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.LagStatement.is_lag_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.LagStatement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LagStatement.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LagStatement</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.LagStatement.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Limits">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Limits</code><a class="headerlink" href="#nmodl.ast.Limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Expression</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.Limits.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Limits.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Limits, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Limits, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Limits.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Limits</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Limits<a class="headerlink" href="#nmodl.ast.Limits.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Limits.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Limits</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Limits.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Limits.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Limits</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Limits.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Limits.is_limits">
<code class="sig-name descname">is_limits</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Limits</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Limits.is_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Limits</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Limits.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Limits</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Limits.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.LinEquation">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">LinEquation</code><a class="headerlink" href="#nmodl.ast.LinEquation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Expression</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.LinEquation.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.LinEquation.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.LinEquation, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.LinEquation, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LinEquation.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LinEquation</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.LinEquation<a class="headerlink" href="#nmodl.ast.LinEquation.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LinEquation.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LinEquation</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.LinEquation.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LinEquation.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LinEquation</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.LinEquation.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LinEquation.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LinEquation</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.LinEquation.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LinEquation.is_lin_equation">
<code class="sig-name descname">is_lin_equation</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LinEquation</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.LinEquation.is_lin_equation" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.LinEquation</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LinEquation.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LinEquation</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.LinEquation.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.LineComment">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">LineComment</code><a class="headerlink" href="#nmodl.ast.LineComment" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>Represents a one line comment in NMODL</p>
<dl class="method">
<dt id="nmodl.ast.LineComment.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.LineComment.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.LineComment, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.LineComment, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LineComment.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LineComment</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.LineComment<a class="headerlink" href="#nmodl.ast.LineComment.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LineComment.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LineComment</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.LineComment.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LineComment.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LineComment</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.LineComment.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LineComment.is_line_comment">
<code class="sig-name descname">is_line_comment</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LineComment</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.LineComment.is_line_comment" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.LineComment</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LineComment.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LineComment</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.LineComment.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.LinearBlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">LinearBlock</code><a class="headerlink" href="#nmodl.ast.LinearBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>Represents <cite>LINEAR</cite> block in the NMODL</p>
<dl class="method">
<dt id="nmodl.ast.LinearBlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.LinearBlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.LinearBlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.LinearBlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LinearBlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LinearBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.LinearBlock<a class="headerlink" href="#nmodl.ast.LinearBlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LinearBlock.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LinearBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.LinearBlock.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LinearBlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LinearBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.LinearBlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LinearBlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LinearBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.LinearBlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LinearBlock.is_linear_block">
<code class="sig-name descname">is_linear_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LinearBlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.LinearBlock.is_linear_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.LinearBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LinearBlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LinearBlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.LinearBlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.LocalListStatement">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">LocalListStatement</code><a class="headerlink" href="#nmodl.ast.LocalListStatement" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.LocalListStatement.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.LocalListStatement.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.LocalListStatement, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.LocalListStatement, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LocalListStatement.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LocalListStatement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.LocalListStatement<a class="headerlink" href="#nmodl.ast.LocalListStatement.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LocalListStatement.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LocalListStatement</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.LocalListStatement.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LocalListStatement.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LocalListStatement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.LocalListStatement.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LocalListStatement.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LocalListStatement</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.LocalListStatement.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LocalListStatement.is_local_list_statement">
<code class="sig-name descname">is_local_list_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LocalListStatement</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.LocalListStatement.is_local_list_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.LocalListStatement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LocalListStatement.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LocalListStatement</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.LocalListStatement.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.LocalVar">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">LocalVar</code><a class="headerlink" href="#nmodl.ast.LocalVar" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Expression</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.LocalVar.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.LocalVar.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.LocalVar, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.LocalVar, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LocalVar.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LocalVar</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.LocalVar<a class="headerlink" href="#nmodl.ast.LocalVar.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LocalVar.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LocalVar</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.LocalVar.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LocalVar.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LocalVar</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.LocalVar.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LocalVar.is_local_var">
<code class="sig-name descname">is_local_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LocalVar</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.LocalVar.is_local_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.LocalVar</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LocalVar.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LocalVar</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.LocalVar.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.LonDifuse">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">LonDifuse</code><a class="headerlink" href="#nmodl.ast.LonDifuse" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>Represent LONGITUDINAL_DIFFUSION statement in NMODL</p>
<dl class="method">
<dt id="nmodl.ast.LonDifuse.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.LonDifuse.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.LonDifuse, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.LonDifuse, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LonDifuse.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LonDifuse</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.LonDifuse<a class="headerlink" href="#nmodl.ast.LonDifuse.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LonDifuse.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LonDifuse</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.LonDifuse.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LonDifuse.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LonDifuse</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.LonDifuse.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LonDifuse.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LonDifuse</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.LonDifuse.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LonDifuse.is_lon_difuse">
<code class="sig-name descname">is_lon_difuse</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LonDifuse</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.LonDifuse.is_lon_difuse" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.LonDifuse</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.LonDifuse.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.LonDifuse</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.LonDifuse.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Match">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Match</code><a class="headerlink" href="#nmodl.ast.Match" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Expression</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.Match.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Match.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Match, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Match, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Match.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Match</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Match<a class="headerlink" href="#nmodl.ast.Match.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Match.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Match</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Match.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Match.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Match</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Match.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Match.is_match">
<code class="sig-name descname">is_match</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Match</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Match.is_match" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Match</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Match.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Match</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Match.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.MatchBlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">MatchBlock</code><a class="headerlink" href="#nmodl.ast.MatchBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.MatchBlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.MatchBlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.MatchBlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.MatchBlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.MatchBlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.MatchBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.MatchBlock<a class="headerlink" href="#nmodl.ast.MatchBlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.MatchBlock.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.MatchBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.MatchBlock.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.MatchBlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.MatchBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.MatchBlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.MatchBlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.MatchBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.MatchBlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.MatchBlock.is_match_block">
<code class="sig-name descname">is_match_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.MatchBlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.MatchBlock.is_match_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.MatchBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.MatchBlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.MatchBlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.MatchBlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Model">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Model</code><a class="headerlink" href="#nmodl.ast.Model" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.Model.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Model.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Model, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Model, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Model.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Model</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Model<a class="headerlink" href="#nmodl.ast.Model.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Model.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Model</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Model.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Model.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Model</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Model.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Model.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Model</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Model.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Model.is_model">
<code class="sig-name descname">is_model</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Model</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Model.is_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Model</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Model.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Model</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Model.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.MutexLock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">MutexLock</code><a class="headerlink" href="#nmodl.ast.MutexLock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>Represent MUTEXLOCK statement in NMODL</p>
<dl class="method">
<dt id="nmodl.ast.MutexLock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.MutexLock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.MutexLock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.MutexLock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.MutexLock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.MutexLock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.MutexLock<a class="headerlink" href="#nmodl.ast.MutexLock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.MutexLock.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.MutexLock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.MutexLock.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.MutexLock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.MutexLock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.MutexLock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.MutexLock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.MutexLock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.MutexLock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.MutexLock.is_mutex_lock">
<code class="sig-name descname">is_mutex_lock</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.MutexLock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.MutexLock.is_mutex_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.MutexLock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.MutexLock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.MutexLock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.MutexLock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.MutexUnlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">MutexUnlock</code><a class="headerlink" href="#nmodl.ast.MutexUnlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>Represent MUTEXUNLOCK statement in NMODL</p>
<dl class="method">
<dt id="nmodl.ast.MutexUnlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.MutexUnlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.MutexUnlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.MutexUnlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.MutexUnlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.MutexUnlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.MutexUnlock<a class="headerlink" href="#nmodl.ast.MutexUnlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.MutexUnlock.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.MutexUnlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.MutexUnlock.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.MutexUnlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.MutexUnlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.MutexUnlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.MutexUnlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.MutexUnlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.MutexUnlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.MutexUnlock.is_mutex_unlock">
<code class="sig-name descname">is_mutex_unlock</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.MutexUnlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.MutexUnlock.is_mutex_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.MutexUnlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.MutexUnlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.MutexUnlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.MutexUnlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Name">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Name</code><a class="headerlink" href="#nmodl.ast.Name" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Identifier</span></code></p>
<p>Represents a name</p>
<dl class="method">
<dt id="nmodl.ast.Name.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Name.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Name, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Name, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Name.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Name</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Name<a class="headerlink" href="#nmodl.ast.Name.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Name.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Name</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Name.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Name.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Name</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Name.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Name.is_name">
<code class="sig-name descname">is_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Name</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Name.is_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Name</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Name.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Name</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Name.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.NetReceiveBlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">NetReceiveBlock</code><a class="headerlink" href="#nmodl.ast.NetReceiveBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.NetReceiveBlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.NetReceiveBlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.NetReceiveBlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.NetReceiveBlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NetReceiveBlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NetReceiveBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.NetReceiveBlock<a class="headerlink" href="#nmodl.ast.NetReceiveBlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NetReceiveBlock.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NetReceiveBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.NetReceiveBlock.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NetReceiveBlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NetReceiveBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.NetReceiveBlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NetReceiveBlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NetReceiveBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.NetReceiveBlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NetReceiveBlock.is_net_receive_block">
<code class="sig-name descname">is_net_receive_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NetReceiveBlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.NetReceiveBlock.is_net_receive_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.NetReceiveBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NetReceiveBlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NetReceiveBlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.NetReceiveBlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.NeuronBlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">NeuronBlock</code><a class="headerlink" href="#nmodl.ast.NeuronBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>Represent <cite>NEURON</cite> block in the mod file</p>
<dl class="method">
<dt id="nmodl.ast.NeuronBlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.NeuronBlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.NeuronBlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.NeuronBlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NeuronBlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NeuronBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.NeuronBlock<a class="headerlink" href="#nmodl.ast.NeuronBlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NeuronBlock.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NeuronBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.NeuronBlock.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NeuronBlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NeuronBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.NeuronBlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NeuronBlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NeuronBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.NeuronBlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NeuronBlock.is_neuron_block">
<code class="sig-name descname">is_neuron_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NeuronBlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.NeuronBlock.is_neuron_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.NeuronBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NeuronBlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NeuronBlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.NeuronBlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Node">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Node</code><a class="headerlink" href="#nmodl.ast.Node" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Ast</span></code></p>
<p>Base class for all AST node</p>
<dl class="method">
<dt id="nmodl.ast.Node.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Node.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Node, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Node, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Node.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Node</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Node<a class="headerlink" href="#nmodl.ast.Node.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Node.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Node</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Node.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Node.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Node</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Node.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Node.is_node">
<code class="sig-name descname">is_node</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Node</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Node.is_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Node.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Node</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Node.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.NonLinEquation">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">NonLinEquation</code><a class="headerlink" href="#nmodl.ast.NonLinEquation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Expression</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.NonLinEquation.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.NonLinEquation.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.NonLinEquation, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.NonLinEquation, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NonLinEquation.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NonLinEquation</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.NonLinEquation<a class="headerlink" href="#nmodl.ast.NonLinEquation.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NonLinEquation.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NonLinEquation</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.NonLinEquation.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NonLinEquation.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NonLinEquation</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.NonLinEquation.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NonLinEquation.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NonLinEquation</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.NonLinEquation.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NonLinEquation.is_non_lin_equation">
<code class="sig-name descname">is_non_lin_equation</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NonLinEquation</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.NonLinEquation.is_non_lin_equation" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.NonLinEquation</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NonLinEquation.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NonLinEquation</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.NonLinEquation.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.NonLinearBlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">NonLinearBlock</code><a class="headerlink" href="#nmodl.ast.NonLinearBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>Represents <cite>NONLINEAR</cite> block in the NMODL</p>
<dl class="method">
<dt id="nmodl.ast.NonLinearBlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.NonLinearBlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.NonLinearBlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.NonLinearBlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NonLinearBlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NonLinearBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.NonLinearBlock<a class="headerlink" href="#nmodl.ast.NonLinearBlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NonLinearBlock.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NonLinearBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.NonLinearBlock.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NonLinearBlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NonLinearBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.NonLinearBlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NonLinearBlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NonLinearBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.NonLinearBlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NonLinearBlock.is_non_linear_block">
<code class="sig-name descname">is_non_linear_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NonLinearBlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.NonLinearBlock.is_non_linear_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.NonLinearBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NonLinearBlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NonLinearBlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.NonLinearBlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Nonspecific">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Nonspecific</code><a class="headerlink" href="#nmodl.ast.Nonspecific" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>Represents NONSPECIFIC_CURRENT variables statement in NMODL</p>
<dl class="method">
<dt id="nmodl.ast.Nonspecific.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Nonspecific.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Nonspecific, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Nonspecific, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Nonspecific.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Nonspecific</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Nonspecific<a class="headerlink" href="#nmodl.ast.Nonspecific.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Nonspecific.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Nonspecific</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Nonspecific.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Nonspecific.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Nonspecific</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Nonspecific.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Nonspecific.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Nonspecific</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Nonspecific.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Nonspecific.is_nonspecific">
<code class="sig-name descname">is_nonspecific</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Nonspecific</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Nonspecific.is_nonspecific" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Nonspecific</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Nonspecific.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Nonspecific</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Nonspecific.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.NonspecificCurVar">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">NonspecificCurVar</code><a class="headerlink" href="#nmodl.ast.NonspecificCurVar" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Identifier</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.NonspecificCurVar.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.NonspecificCurVar.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.NonspecificCurVar, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.NonspecificCurVar, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NonspecificCurVar.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NonspecificCurVar</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.NonspecificCurVar<a class="headerlink" href="#nmodl.ast.NonspecificCurVar.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NonspecificCurVar.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NonspecificCurVar</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.NonspecificCurVar.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NonspecificCurVar.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NonspecificCurVar</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.NonspecificCurVar.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NonspecificCurVar.is_nonspecific_cur_var">
<code class="sig-name descname">is_nonspecific_cur_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NonspecificCurVar</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.NonspecificCurVar.is_nonspecific_cur_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.NonspecificCurVar</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NonspecificCurVar.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NonspecificCurVar</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.NonspecificCurVar.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.NrnStateBlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">NrnStateBlock</code><a class="headerlink" href="#nmodl.ast.NrnStateBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>Represents the coreneuron nrn_state callback function</p>
<dl class="method">
<dt id="nmodl.ast.NrnStateBlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.NrnStateBlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.NrnStateBlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.NrnStateBlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NrnStateBlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NrnStateBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.NrnStateBlock<a class="headerlink" href="#nmodl.ast.NrnStateBlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NrnStateBlock.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NrnStateBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.NrnStateBlock.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NrnStateBlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NrnStateBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.NrnStateBlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NrnStateBlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NrnStateBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.NrnStateBlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NrnStateBlock.is_nrn_state_block">
<code class="sig-name descname">is_nrn_state_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NrnStateBlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.NrnStateBlock.is_nrn_state_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.NrnStateBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NrnStateBlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NrnStateBlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.NrnStateBlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.NullProvider">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">NullProvider</code><span class="sig-paren">(</span><em class="sig-param">module</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#NullProvider"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.NullProvider" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Try to implement resources and metadata for arbitrary PEP 302 loaders</p>
</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Number">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Number</code><a class="headerlink" href="#nmodl.ast.Number" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Expression</span></code></p>
<p>Base class for all numbers</p>
<dl class="method">
<dt id="nmodl.ast.Number.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Number.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Number, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Number, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Number.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Number</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Number<a class="headerlink" href="#nmodl.ast.Number.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Number.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Number</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Number.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Number.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Number</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Number.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Number.is_number">
<code class="sig-name descname">is_number</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Number</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Number.is_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Number</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Number.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Number</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Number.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.NumberRange">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">NumberRange</code><a class="headerlink" href="#nmodl.ast.NumberRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Expression</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.NumberRange.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.NumberRange.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.NumberRange, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.NumberRange, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NumberRange.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NumberRange</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.NumberRange<a class="headerlink" href="#nmodl.ast.NumberRange.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NumberRange.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NumberRange</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.NumberRange.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NumberRange.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NumberRange</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.NumberRange.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NumberRange.is_number_range">
<code class="sig-name descname">is_number_range</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NumberRange</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.NumberRange.is_number_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.NumberRange</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.NumberRange.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.NumberRange</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.NumberRange.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.OntologyStatement">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">OntologyStatement</code><a class="headerlink" href="#nmodl.ast.OntologyStatement" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>Represents CURIE information in NMODL</p>
<dl class="method">
<dt id="nmodl.ast.OntologyStatement.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.OntologyStatement.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.OntologyStatement, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.OntologyStatement, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.OntologyStatement.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.OntologyStatement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.OntologyStatement<a class="headerlink" href="#nmodl.ast.OntologyStatement.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.OntologyStatement.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.OntologyStatement</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.OntologyStatement.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.OntologyStatement.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.OntologyStatement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.OntologyStatement.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.OntologyStatement.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.OntologyStatement</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.OntologyStatement.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.OntologyStatement.is_ontology_statement">
<code class="sig-name descname">is_ontology_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.OntologyStatement</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.OntologyStatement.is_ontology_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.OntologyStatement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.OntologyStatement.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.OntologyStatement</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.OntologyStatement.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="nmodl.ast.PEP440Warning">
<em class="property">exception </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">PEP440Warning</code><a class="reference internal" href="_modules/pkg_resources.html#PEP440Warning"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.PEP440Warning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">RuntimeWarning</span></code></p>
<p>Used when there is an issue with a version or specifier not complying with
PEP 440.</p>
</dd></dl>

<dl class="class">
<dt id="nmodl.ast.ParamAssign">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">ParamAssign</code><a class="headerlink" href="#nmodl.ast.ParamAssign" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.ParamAssign.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.ParamAssign.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.ParamAssign, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.ParamAssign, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ParamAssign.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ParamAssign</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.ParamAssign<a class="headerlink" href="#nmodl.ast.ParamAssign.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ParamAssign.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ParamAssign</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.ParamAssign.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ParamAssign.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ParamAssign</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ParamAssign.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ParamAssign.is_param_assign">
<code class="sig-name descname">is_param_assign</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ParamAssign</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.ParamAssign.is_param_assign" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ParamAssign</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ParamAssign.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ParamAssign</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.ParamAssign.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.ParamBlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">ParamBlock</code><a class="headerlink" href="#nmodl.ast.ParamBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>Represents a <cite>PARAMETER</cite> block in the NMODL</p>
<dl class="method">
<dt id="nmodl.ast.ParamBlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.ParamBlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.ParamBlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.ParamBlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ParamBlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ParamBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.ParamBlock<a class="headerlink" href="#nmodl.ast.ParamBlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ParamBlock.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ParamBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ParamBlock.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ParamBlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ParamBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.ParamBlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ParamBlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ParamBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ParamBlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ParamBlock.is_param_block">
<code class="sig-name descname">is_param_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ParamBlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.ParamBlock.is_param_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ParamBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ParamBlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ParamBlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.ParamBlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.ParenExpression">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">ParenExpression</code><a class="headerlink" href="#nmodl.ast.ParenExpression" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Expression</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.ParenExpression.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.ParenExpression.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.ParenExpression, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.ParenExpression, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ParenExpression.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ParenExpression</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.ParenExpression<a class="headerlink" href="#nmodl.ast.ParenExpression.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ParenExpression.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ParenExpression</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.ParenExpression.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ParenExpression.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ParenExpression</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ParenExpression.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ParenExpression.is_paren_expression">
<code class="sig-name descname">is_paren_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ParenExpression</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.ParenExpression.is_paren_expression" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ParenExpression</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ParenExpression.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ParenExpression</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.ParenExpression.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.PartialBlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">PartialBlock</code><a class="headerlink" href="#nmodl.ast.PartialBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.PartialBlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.PartialBlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.PartialBlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.PartialBlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PartialBlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PartialBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.PartialBlock<a class="headerlink" href="#nmodl.ast.PartialBlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PartialBlock.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PartialBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.PartialBlock.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PartialBlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PartialBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.PartialBlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PartialBlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PartialBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.PartialBlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PartialBlock.is_partial_block">
<code class="sig-name descname">is_partial_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PartialBlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.PartialBlock.is_partial_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.PartialBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PartialBlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PartialBlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.PartialBlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.PartialBoundary">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">PartialBoundary</code><a class="headerlink" href="#nmodl.ast.PartialBoundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.PartialBoundary.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.PartialBoundary.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.PartialBoundary, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.PartialBoundary, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PartialBoundary.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PartialBoundary</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.PartialBoundary<a class="headerlink" href="#nmodl.ast.PartialBoundary.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PartialBoundary.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PartialBoundary</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.PartialBoundary.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PartialBoundary.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PartialBoundary</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.PartialBoundary.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PartialBoundary.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PartialBoundary</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.PartialBoundary.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PartialBoundary.is_partial_boundary">
<code class="sig-name descname">is_partial_boundary</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PartialBoundary</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.PartialBoundary.is_partial_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.PartialBoundary</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PartialBoundary.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PartialBoundary</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.PartialBoundary.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.PartialEquation">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">PartialEquation</code><a class="headerlink" href="#nmodl.ast.PartialEquation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.PartialEquation.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.PartialEquation.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.PartialEquation, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.PartialEquation, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PartialEquation.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PartialEquation</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.PartialEquation<a class="headerlink" href="#nmodl.ast.PartialEquation.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PartialEquation.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PartialEquation</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.PartialEquation.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PartialEquation.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PartialEquation</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.PartialEquation.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PartialEquation.is_partial_equation">
<code class="sig-name descname">is_partial_equation</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PartialEquation</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.PartialEquation.is_partial_equation" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.PartialEquation</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PartialEquation.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PartialEquation</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.PartialEquation.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.PathMetadata">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">PathMetadata</code><span class="sig-paren">(</span><em class="sig-param">path</em>, <em class="sig-param">egg_info</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#PathMetadata"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.PathMetadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pkg_resources.DefaultProvider</span></code></p>
<p>Metadata provider for egg directories</p>
<p>Usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Development eggs:</span>

<span class="n">egg_info</span> <span class="o">=</span> <span class="s2">&quot;/path/to/PackageName.egg-info&quot;</span>
<span class="n">base_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">egg_info</span><span class="p">)</span>
<span class="n">metadata</span> <span class="o">=</span> <span class="n">PathMetadata</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">egg_info</span><span class="p">)</span>
<span class="n">dist_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">egg_info</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">dist</span> <span class="o">=</span> <span class="n">Distribution</span><span class="p">(</span><span class="n">basedir</span><span class="p">,</span> <span class="n">project_name</span><span class="o">=</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span>

<span class="c1"># Unpacked egg directories:</span>

<span class="n">egg_path</span> <span class="o">=</span> <span class="s2">&quot;/path/to/PackageName-ver-pyver-etc.egg&quot;</span>
<span class="n">metadata</span> <span class="o">=</span> <span class="n">PathMetadata</span><span class="p">(</span><span class="n">egg_path</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">egg_path</span><span class="p">,</span><span class="s1">&#39;EGG-INFO&#39;</span><span class="p">))</span>
<span class="n">dist</span> <span class="o">=</span> <span class="n">Distribution</span><span class="o">.</span><span class="n">from_filename</span><span class="p">(</span><span class="n">egg_path</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="exception">
<dt id="nmodl.ast.PkgResourcesDeprecationWarning">
<em class="property">exception </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">PkgResourcesDeprecationWarning</code><a class="reference internal" href="_modules/pkg_resources.html#PkgResourcesDeprecationWarning"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.PkgResourcesDeprecationWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Warning</span></code></p>
<p>Base class for warning about deprecations in <code class="docutils literal notranslate"><span class="pre">pkg_resources</span></code></p>
<p>This class is not derived from <code class="docutils literal notranslate"><span class="pre">DeprecationWarning</span></code>, and as such is
visible by default.</p>
</dd></dl>

<dl class="class">
<dt id="nmodl.ast.PlotBlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">PlotBlock</code><a class="headerlink" href="#nmodl.ast.PlotBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>Represents a <cite>PLOT</cite> statement in the NMODL</p>
<dl class="method">
<dt id="nmodl.ast.PlotBlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.PlotBlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.PlotBlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.PlotBlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PlotBlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PlotBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.PlotBlock<a class="headerlink" href="#nmodl.ast.PlotBlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PlotBlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PlotBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.PlotBlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PlotBlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PlotBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.PlotBlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PlotBlock.is_plot_block">
<code class="sig-name descname">is_plot_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PlotBlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.PlotBlock.is_plot_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.PlotBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PlotBlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PlotBlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.PlotBlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.PlotDeclaration">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">PlotDeclaration</code><a class="headerlink" href="#nmodl.ast.PlotDeclaration" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.PlotDeclaration.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.PlotDeclaration.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.PlotDeclaration, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.PlotDeclaration, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PlotDeclaration.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PlotDeclaration</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.PlotDeclaration<a class="headerlink" href="#nmodl.ast.PlotDeclaration.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PlotDeclaration.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PlotDeclaration</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.PlotDeclaration.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PlotDeclaration.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PlotDeclaration</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.PlotDeclaration.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PlotDeclaration.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PlotDeclaration</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.PlotDeclaration.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PlotDeclaration.is_plot_declaration">
<code class="sig-name descname">is_plot_declaration</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PlotDeclaration</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.PlotDeclaration.is_plot_declaration" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.PlotDeclaration</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PlotDeclaration.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PlotDeclaration</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.PlotDeclaration.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.PlotVar">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">PlotVar</code><a class="headerlink" href="#nmodl.ast.PlotVar" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Expression</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.PlotVar.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.PlotVar.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.PlotVar, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.PlotVar, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PlotVar.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PlotVar</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.PlotVar<a class="headerlink" href="#nmodl.ast.PlotVar.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PlotVar.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PlotVar</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.PlotVar.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PlotVar.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PlotVar</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.PlotVar.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PlotVar.is_plot_var">
<code class="sig-name descname">is_plot_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PlotVar</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.PlotVar.is_plot_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.PlotVar</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PlotVar.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PlotVar</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.PlotVar.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Pointer">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Pointer</code><a class="headerlink" href="#nmodl.ast.Pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>Represents POINTER statement in NMODL</p>
<dl class="method">
<dt id="nmodl.ast.Pointer.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Pointer.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Pointer, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Pointer, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Pointer.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Pointer</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Pointer<a class="headerlink" href="#nmodl.ast.Pointer.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Pointer.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Pointer</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Pointer.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Pointer.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Pointer</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Pointer.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Pointer.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Pointer</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Pointer.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Pointer.is_pointer">
<code class="sig-name descname">is_pointer</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Pointer</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Pointer.is_pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Pointer</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Pointer.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Pointer</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Pointer.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.PointerVar">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">PointerVar</code><a class="headerlink" href="#nmodl.ast.PointerVar" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Identifier</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.PointerVar.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.PointerVar.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.PointerVar, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.PointerVar, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PointerVar.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PointerVar</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.PointerVar<a class="headerlink" href="#nmodl.ast.PointerVar.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PointerVar.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PointerVar</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.PointerVar.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PointerVar.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PointerVar</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.PointerVar.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PointerVar.is_pointer_var">
<code class="sig-name descname">is_pointer_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PointerVar</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.PointerVar.is_pointer_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.PointerVar</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PointerVar.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PointerVar</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.PointerVar.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.PrimeName">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">PrimeName</code><a class="headerlink" href="#nmodl.ast.PrimeName" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Identifier</span></code></p>
<p>Represents a prime variable (for ODE)</p>
<dl class="method">
<dt id="nmodl.ast.PrimeName.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.PrimeName.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.PrimeName, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.PrimeName, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PrimeName.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PrimeName</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.PrimeName<a class="headerlink" href="#nmodl.ast.PrimeName.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PrimeName.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PrimeName</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.PrimeName.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PrimeName.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PrimeName</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.PrimeName.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PrimeName.is_prime_name">
<code class="sig-name descname">is_prime_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PrimeName</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.PrimeName.is_prime_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.PrimeName</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.PrimeName.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.PrimeName</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.PrimeName.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.ProcedureBlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">ProcedureBlock</code><a class="headerlink" href="#nmodl.ast.ProcedureBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.ProcedureBlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.ProcedureBlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.ProcedureBlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.ProcedureBlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ProcedureBlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ProcedureBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.ProcedureBlock<a class="headerlink" href="#nmodl.ast.ProcedureBlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ProcedureBlock.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ProcedureBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ProcedureBlock.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ProcedureBlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ProcedureBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.ProcedureBlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ProcedureBlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ProcedureBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ProcedureBlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ProcedureBlock.is_procedure_block">
<code class="sig-name descname">is_procedure_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ProcedureBlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.ProcedureBlock.is_procedure_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ProcedureBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ProcedureBlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ProcedureBlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.ProcedureBlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Program">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Program</code><a class="headerlink" href="#nmodl.ast.Program" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Ast</span></code></p>
<p>Represents top level AST node for whole NMODL input</p>
<dl class="method">
<dt id="nmodl.ast.Program.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Program.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Program, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Program, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Program.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Program</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Program<a class="headerlink" href="#nmodl.ast.Program.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Program.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Program</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Program.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Program.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Program</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Program.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Program.is_program">
<code class="sig-name descname">is_program</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Program</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Program.is_program" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Program</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Program.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Program</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Program.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.ProtectStatement">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">ProtectStatement</code><a class="headerlink" href="#nmodl.ast.ProtectStatement" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.ProtectStatement.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.ProtectStatement.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.ProtectStatement, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.ProtectStatement, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ProtectStatement.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ProtectStatement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.ProtectStatement<a class="headerlink" href="#nmodl.ast.ProtectStatement.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ProtectStatement.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ProtectStatement</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ProtectStatement.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ProtectStatement.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ProtectStatement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.ProtectStatement.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ProtectStatement.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ProtectStatement</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ProtectStatement.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ProtectStatement.is_protect_statement">
<code class="sig-name descname">is_protect_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ProtectStatement</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.ProtectStatement.is_protect_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ProtectStatement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ProtectStatement.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ProtectStatement</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.ProtectStatement.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.QueueExpressionType">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">QueueExpressionType</code><a class="headerlink" href="#nmodl.ast.QueueExpressionType" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Expression</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.QueueExpressionType.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.QueueExpressionType.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.QueueExpressionType, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.QueueExpressionType, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.QueueExpressionType.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.QueueExpressionType</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.QueueExpressionType<a class="headerlink" href="#nmodl.ast.QueueExpressionType.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.QueueExpressionType.eval">
<code class="sig-name descname">eval</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.QueueExpressionType</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.QueueExpressionType.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Return value of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.QueueExpressionType.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.QueueExpressionType</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.QueueExpressionType.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.QueueExpressionType.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.QueueExpressionType</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.QueueExpressionType.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.QueueExpressionType.is_queue_expression_type">
<code class="sig-name descname">is_queue_expression_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.QueueExpressionType</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.QueueExpressionType.is_queue_expression_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.QueueExpressionType</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.QueueExpressionType.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.QueueExpressionType</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.QueueExpressionType.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.QueueStatement">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">QueueStatement</code><a class="headerlink" href="#nmodl.ast.QueueStatement" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>Represent queue statement in NMODL</p>
<dl class="method">
<dt id="nmodl.ast.QueueStatement.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.QueueStatement.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.QueueStatement, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.QueueStatement, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.QueueStatement.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.QueueStatement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.QueueStatement<a class="headerlink" href="#nmodl.ast.QueueStatement.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.QueueStatement.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.QueueStatement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.QueueStatement.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.QueueStatement.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.QueueStatement</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.QueueStatement.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.QueueStatement.is_queue_statement">
<code class="sig-name descname">is_queue_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.QueueStatement</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.QueueStatement.is_queue_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.QueueStatement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.QueueStatement.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.QueueStatement</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.QueueStatement.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Range">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Range</code><a class="headerlink" href="#nmodl.ast.Range" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>Represents RANGE variables statement in NMODL</p>
<dl class="method">
<dt id="nmodl.ast.Range.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Range.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Range, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Range, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Range.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Range</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Range<a class="headerlink" href="#nmodl.ast.Range.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Range.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Range</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Range.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Range.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Range</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Range.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Range.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Range</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Range.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Range.is_range">
<code class="sig-name descname">is_range</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Range</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Range.is_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Range</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Range.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Range</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Range.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.RangeVar">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">RangeVar</code><a class="headerlink" href="#nmodl.ast.RangeVar" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Identifier</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.RangeVar.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.RangeVar.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.RangeVar, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.RangeVar, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.RangeVar.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.RangeVar</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.RangeVar<a class="headerlink" href="#nmodl.ast.RangeVar.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.RangeVar.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.RangeVar</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.RangeVar.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.RangeVar.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.RangeVar</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.RangeVar.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.RangeVar.is_range_var">
<code class="sig-name descname">is_range_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.RangeVar</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.RangeVar.is_range_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.RangeVar</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.RangeVar.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.RangeVar</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.RangeVar.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.ReactVarName">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">ReactVarName</code><a class="headerlink" href="#nmodl.ast.ReactVarName" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Identifier</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.ReactVarName.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.ReactVarName.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.ReactVarName, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.ReactVarName, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ReactVarName.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ReactVarName</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.ReactVarName<a class="headerlink" href="#nmodl.ast.ReactVarName.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ReactVarName.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ReactVarName</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.ReactVarName.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ReactVarName.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ReactVarName</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ReactVarName.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ReactVarName.is_react_var_name">
<code class="sig-name descname">is_react_var_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ReactVarName</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.ReactVarName.is_react_var_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ReactVarName</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ReactVarName.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ReactVarName</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.ReactVarName.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.ReactionOperator">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">ReactionOperator</code><a class="headerlink" href="#nmodl.ast.ReactionOperator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Expression</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.ReactionOperator.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.ReactionOperator.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.ReactionOperator, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.ReactionOperator, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ReactionOperator.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ReactionOperator</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.ReactionOperator<a class="headerlink" href="#nmodl.ast.ReactionOperator.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ReactionOperator.eval">
<code class="sig-name descname">eval</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ReactionOperator</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ReactionOperator.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Return value of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ReactionOperator.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ReactionOperator</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.ReactionOperator.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ReactionOperator.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ReactionOperator</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ReactionOperator.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ReactionOperator.is_reaction_operator">
<code class="sig-name descname">is_reaction_operator</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ReactionOperator</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.ReactionOperator.is_reaction_operator" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ReactionOperator</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ReactionOperator.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ReactionOperator</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.ReactionOperator.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.ReactionStatement">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">ReactionStatement</code><a class="headerlink" href="#nmodl.ast.ReactionStatement" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.ReactionStatement.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.ReactionStatement.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.ReactionStatement, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.ReactionStatement, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ReactionStatement.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ReactionStatement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.ReactionStatement<a class="headerlink" href="#nmodl.ast.ReactionStatement.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ReactionStatement.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ReactionStatement</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ReactionStatement.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ReactionStatement.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ReactionStatement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.ReactionStatement.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ReactionStatement.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ReactionStatement</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ReactionStatement.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ReactionStatement.is_reaction_statement">
<code class="sig-name descname">is_reaction_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ReactionStatement</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.ReactionStatement.is_reaction_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ReactionStatement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ReactionStatement.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ReactionStatement</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.ReactionStatement.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.ReadIonVar">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">ReadIonVar</code><a class="headerlink" href="#nmodl.ast.ReadIonVar" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Identifier</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.ReadIonVar.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.ReadIonVar.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.ReadIonVar, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.ReadIonVar, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ReadIonVar.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ReadIonVar</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.ReadIonVar<a class="headerlink" href="#nmodl.ast.ReadIonVar.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ReadIonVar.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ReadIonVar</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.ReadIonVar.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ReadIonVar.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ReadIonVar</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ReadIonVar.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ReadIonVar.is_read_ion_var">
<code class="sig-name descname">is_read_ion_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ReadIonVar</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.ReadIonVar.is_read_ion_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ReadIonVar</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ReadIonVar.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ReadIonVar</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.ReadIonVar.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Requirement">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Requirement</code><span class="sig-paren">(</span><em class="sig-param">requirement_string</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Requirement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.Requirement" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pkg_resources.extern.packaging.requirements.Requirement</span></code></p>
</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Reset">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Reset</code><a class="headerlink" href="#nmodl.ast.Reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>Represent RESET statement in NMODL</p>
<dl class="method">
<dt id="nmodl.ast.Reset.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Reset.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Reset, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Reset, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Reset.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Reset</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Reset<a class="headerlink" href="#nmodl.ast.Reset.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Reset.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Reset</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Reset.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Reset.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Reset</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Reset.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Reset.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Reset</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Reset.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Reset.is_reset">
<code class="sig-name descname">is_reset</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Reset</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Reset.is_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Reset</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Reset.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Reset</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Reset.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="nmodl.ast.ResolutionError">
<em class="property">exception </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">ResolutionError</code><a class="reference internal" href="_modules/pkg_resources.html#ResolutionError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.ResolutionError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
<p>Abstract base for dependency resolution errors</p>
</dd></dl>

<dl class="class">
<dt id="nmodl.ast.ResourceManager">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">ResourceManager</code><a class="reference internal" href="_modules/pkg_resources.html#ResourceManager"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.ResourceManager" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Manage resource extraction and packages</p>
<dl class="method">
<dt id="nmodl.ast.ResourceManager.cleanup_resources">
<code class="sig-name descname">cleanup_resources</code><span class="sig-paren">(</span><em class="sig-param">force=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#ResourceManager.cleanup_resources"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.ResourceManager.cleanup_resources" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete all extracted resource files and directories, returning a list
of the file and directory names that could not be successfully removed.
This function does not have any concurrency protection, so it should
generally only be called when the extraction path is a temporary
directory exclusive to a single process.  This method is not
automatically called; you must call it explicitly or register it as an
<code class="docutils literal notranslate"><span class="pre">atexit</span></code> function if you wish to ensure cleanup of a temporary
directory used for extractions.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ResourceManager.extraction_error">
<code class="sig-name descname">extraction_error</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#ResourceManager.extraction_error"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.ResourceManager.extraction_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Give an error message for problems extracting file(s)</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ResourceManager.get_cache_path">
<code class="sig-name descname">get_cache_path</code><span class="sig-paren">(</span><em class="sig-param">archive_name</em>, <em class="sig-param">names=()</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#ResourceManager.get_cache_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.ResourceManager.get_cache_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return absolute location in cache for <cite>archive_name</cite> and <cite>names</cite></p>
<p>The parent directory of the resulting path will be created if it does
not already exist.  <cite>archive_name</cite> should be the base filename of the
enclosing egg (which may not be the name of the enclosing zipfile!),
including its “.egg” extension.  <cite>names</cite>, if provided, should be a
sequence of path name parts “under” the egg’s extraction location.</p>
<p>This method should only be called by resource providers that need to
obtain an extraction location, and only for names they intend to
extract, as it tracks the generated names for possible cleanup later.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ResourceManager.postprocess">
<code class="sig-name descname">postprocess</code><span class="sig-paren">(</span><em class="sig-param">tempname</em>, <em class="sig-param">filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#ResourceManager.postprocess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.ResourceManager.postprocess" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform any platform-specific postprocessing of <cite>tempname</cite></p>
<p>This is where Mac header rewrites should be done; other platforms don’t
have anything special they should do.</p>
<p>Resource providers should call this method ONLY after successfully
extracting a compressed resource.  They must NOT call it on resources
that are already in the filesystem.</p>
<p><cite>tempname</cite> is the current (temporary) name of the file, and <cite>filename</cite>
is the name it will be renamed to by the caller after this routine
returns.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ResourceManager.resource_exists">
<code class="sig-name descname">resource_exists</code><span class="sig-paren">(</span><em class="sig-param">package_or_requirement</em>, <em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#ResourceManager.resource_exists"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.ResourceManager.resource_exists" title="Permalink to this definition">¶</a></dt>
<dd><p>Does the named resource exist?</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ResourceManager.resource_filename">
<code class="sig-name descname">resource_filename</code><span class="sig-paren">(</span><em class="sig-param">package_or_requirement</em>, <em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#ResourceManager.resource_filename"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.ResourceManager.resource_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a true filesystem path for specified resource</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ResourceManager.resource_isdir">
<code class="sig-name descname">resource_isdir</code><span class="sig-paren">(</span><em class="sig-param">package_or_requirement</em>, <em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#ResourceManager.resource_isdir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.ResourceManager.resource_isdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the named resource an existing directory?</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ResourceManager.resource_listdir">
<code class="sig-name descname">resource_listdir</code><span class="sig-paren">(</span><em class="sig-param">package_or_requirement</em>, <em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#ResourceManager.resource_listdir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.ResourceManager.resource_listdir" title="Permalink to this definition">¶</a></dt>
<dd><p>List the contents of the named resource directory</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ResourceManager.resource_stream">
<code class="sig-name descname">resource_stream</code><span class="sig-paren">(</span><em class="sig-param">package_or_requirement</em>, <em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#ResourceManager.resource_stream"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.ResourceManager.resource_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a readable file-like object for specified resource</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ResourceManager.resource_string">
<code class="sig-name descname">resource_string</code><span class="sig-paren">(</span><em class="sig-param">package_or_requirement</em>, <em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#ResourceManager.resource_string"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.ResourceManager.resource_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Return specified resource as a string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ResourceManager.set_extraction_path">
<code class="sig-name descname">set_extraction_path</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#ResourceManager.set_extraction_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.ResourceManager.set_extraction_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the base path where resources will be extracted to, if needed.</p>
<p>If you do not call this routine before any extractions take place, the
path defaults to the return value of <code class="docutils literal notranslate"><span class="pre">get_default_cache()</span></code>.  (Which
is based on the <code class="docutils literal notranslate"><span class="pre">PYTHON_EGG_CACHE</span></code> environment variable, with various
platform-specific fallbacks.  See that routine’s documentation for more
details.)</p>
<p>Resources are extracted to subdirectories of this path based upon
information given by the <code class="docutils literal notranslate"><span class="pre">IResourceProvider</span></code>.  You may set this to a
temporary directory, but then you must call <code class="docutils literal notranslate"><span class="pre">cleanup_resources()</span></code> to
delete the extracted files when done.  There is no guarantee that
<code class="docutils literal notranslate"><span class="pre">cleanup_resources()</span></code> will be able to remove all extracted files.</p>
<p>(Note: you may not change the extraction path for a given resource
manager once resources have been extracted, unless you first call
<code class="docutils literal notranslate"><span class="pre">cleanup_resources()</span></code>.)</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Section">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Section</code><a class="headerlink" href="#nmodl.ast.Section" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>Represents SECTION variables statement in NMODL</p>
<dl class="method">
<dt id="nmodl.ast.Section.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Section.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Section, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Section, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Section.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Section</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Section<a class="headerlink" href="#nmodl.ast.Section.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Section.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Section</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Section.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Section.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Section</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Section.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Section.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Section</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Section.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Section.is_section">
<code class="sig-name descname">is_section</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Section</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Section.is_section" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Section</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Section.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Section</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Section.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.SectionVar">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">SectionVar</code><a class="headerlink" href="#nmodl.ast.SectionVar" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Identifier</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.SectionVar.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.SectionVar.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.SectionVar, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.SectionVar, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.SectionVar.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.SectionVar</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.SectionVar<a class="headerlink" href="#nmodl.ast.SectionVar.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.SectionVar.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.SectionVar</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.SectionVar.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.SectionVar.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.SectionVar</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.SectionVar.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.SectionVar.is_section_var">
<code class="sig-name descname">is_section_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.SectionVar</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.SectionVar.is_section_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.SectionVar</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.SectionVar.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.SectionVar</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.SectionVar.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Sens">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Sens</code><a class="headerlink" href="#nmodl.ast.Sens" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>Represent SENS statement in NMODL</p>
<dl class="method">
<dt id="nmodl.ast.Sens.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Sens.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Sens, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Sens, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Sens.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Sens</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Sens<a class="headerlink" href="#nmodl.ast.Sens.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Sens.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Sens</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Sens.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Sens.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Sens</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Sens.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Sens.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Sens</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Sens.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Sens.is_sens">
<code class="sig-name descname">is_sens</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Sens</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Sens.is_sens" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Sens</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Sens.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Sens</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Sens.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.SolutionExpression">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">SolutionExpression</code><a class="headerlink" href="#nmodl.ast.SolutionExpression" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Expression</span></code></p>
<p>Represent solution of a block in the AST</p>
<dl class="method">
<dt id="nmodl.ast.SolutionExpression.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.SolutionExpression.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.SolutionExpression, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.SolutionExpression, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.SolutionExpression.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.SolutionExpression</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.SolutionExpression<a class="headerlink" href="#nmodl.ast.SolutionExpression.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.SolutionExpression.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.SolutionExpression</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.SolutionExpression.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.SolutionExpression.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.SolutionExpression</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.SolutionExpression.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.SolutionExpression.is_solution_expression">
<code class="sig-name descname">is_solution_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.SolutionExpression</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.SolutionExpression.is_solution_expression" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.SolutionExpression</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.SolutionExpression.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.SolutionExpression</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.SolutionExpression.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.SolveBlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">SolveBlock</code><a class="headerlink" href="#nmodl.ast.SolveBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.SolveBlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.SolveBlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.SolveBlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.SolveBlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.SolveBlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.SolveBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.SolveBlock<a class="headerlink" href="#nmodl.ast.SolveBlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.SolveBlock.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.SolveBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.SolveBlock.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.SolveBlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.SolveBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.SolveBlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.SolveBlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.SolveBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.SolveBlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.SolveBlock.is_solve_block">
<code class="sig-name descname">is_solve_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.SolveBlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.SolveBlock.is_solve_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.SolveBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.SolveBlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.SolveBlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.SolveBlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.StateBlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">StateBlock</code><a class="headerlink" href="#nmodl.ast.StateBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>Represents a <cite>STATE</cite> block in the NMODL</p>
<dl class="method">
<dt id="nmodl.ast.StateBlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.StateBlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.StateBlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.StateBlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.StateBlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.StateBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.StateBlock<a class="headerlink" href="#nmodl.ast.StateBlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.StateBlock.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.StateBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.StateBlock.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.StateBlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.StateBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.StateBlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.StateBlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.StateBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.StateBlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.StateBlock.is_state_block">
<code class="sig-name descname">is_state_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.StateBlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.StateBlock.is_state_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.StateBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.StateBlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.StateBlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.StateBlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Statement">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Statement</code><a class="headerlink" href="#nmodl.ast.Statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Node</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.Statement.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Statement.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Statement, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Statement, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Statement.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Statement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Statement<a class="headerlink" href="#nmodl.ast.Statement.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Statement.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Statement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Statement.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Statement.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Statement</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Statement.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Statement.is_statement">
<code class="sig-name descname">is_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Statement</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Statement.is_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Statement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Statement.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Statement</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Statement.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.StatementBlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">StatementBlock</code><a class="headerlink" href="#nmodl.ast.StatementBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>Represents block encapsulating list of statements</p>
<dl class="method">
<dt id="nmodl.ast.StatementBlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.StatementBlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.StatementBlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.StatementBlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.StatementBlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.StatementBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.StatementBlock<a class="headerlink" href="#nmodl.ast.StatementBlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.StatementBlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.StatementBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.StatementBlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.StatementBlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.StatementBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.StatementBlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.StatementBlock.is_statement_block">
<code class="sig-name descname">is_statement_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.StatementBlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.StatementBlock.is_statement_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.StatementBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.StatementBlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.StatementBlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.StatementBlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.StepBlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">StepBlock</code><a class="headerlink" href="#nmodl.ast.StepBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>Represents a <cite>STEPPED</cite> block in the NMODL</p>
<dl class="method">
<dt id="nmodl.ast.StepBlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.StepBlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.StepBlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.StepBlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.StepBlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.StepBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.StepBlock<a class="headerlink" href="#nmodl.ast.StepBlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.StepBlock.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.StepBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.StepBlock.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.StepBlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.StepBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.StepBlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.StepBlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.StepBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.StepBlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.StepBlock.is_step_block">
<code class="sig-name descname">is_step_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.StepBlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.StepBlock.is_step_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.StepBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.StepBlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.StepBlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.StepBlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Stepped">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Stepped</code><a class="headerlink" href="#nmodl.ast.Stepped" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.Stepped.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Stepped.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Stepped, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Stepped, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Stepped.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Stepped</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Stepped<a class="headerlink" href="#nmodl.ast.Stepped.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Stepped.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Stepped</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Stepped.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Stepped.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Stepped</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Stepped.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Stepped.is_stepped">
<code class="sig-name descname">is_stepped</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Stepped</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Stepped.is_stepped" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Stepped</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Stepped.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Stepped</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Stepped.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.String">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">String</code><a class="headerlink" href="#nmodl.ast.String" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Expression</span></code></p>
<p>Represents a string</p>
<dl class="method">
<dt id="nmodl.ast.String.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.String.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.String, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.String, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.String.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.String</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.String<a class="headerlink" href="#nmodl.ast.String.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.String.eval">
<code class="sig-name descname">eval</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.String</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.String.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Return value of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.String.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.String</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.String.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.String.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.String</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.String.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.String.is_string">
<code class="sig-name descname">is_string</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.String</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.String.is_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.String</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.String.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.String</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.String.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Suffix">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Suffix</code><a class="headerlink" href="#nmodl.ast.Suffix" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>Represents SUFFIX statement in NMODL</p>
<dl class="method">
<dt id="nmodl.ast.Suffix.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Suffix.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Suffix, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Suffix, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Suffix.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Suffix</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Suffix<a class="headerlink" href="#nmodl.ast.Suffix.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Suffix.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Suffix</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Suffix.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Suffix.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Suffix</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Suffix.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Suffix.is_suffix">
<code class="sig-name descname">is_suffix</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Suffix</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Suffix.is_suffix" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Suffix</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Suffix.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Suffix</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Suffix.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.TableStatement">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">TableStatement</code><a class="headerlink" href="#nmodl.ast.TableStatement" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>Represents TABLE statement in NMODL</p>
<dl class="method">
<dt id="nmodl.ast.TableStatement.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.TableStatement.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.TableStatement, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.TableStatement, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.TableStatement.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.TableStatement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.TableStatement<a class="headerlink" href="#nmodl.ast.TableStatement.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.TableStatement.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.TableStatement</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.TableStatement.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.TableStatement.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.TableStatement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.TableStatement.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.TableStatement.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.TableStatement</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.TableStatement.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.TableStatement.is_table_statement">
<code class="sig-name descname">is_table_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.TableStatement</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.TableStatement.is_table_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.TableStatement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.TableStatement.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.TableStatement</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.TableStatement.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.TerminalBlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">TerminalBlock</code><a class="headerlink" href="#nmodl.ast.TerminalBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.TerminalBlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.TerminalBlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.TerminalBlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.TerminalBlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.TerminalBlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.TerminalBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.TerminalBlock<a class="headerlink" href="#nmodl.ast.TerminalBlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.TerminalBlock.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.TerminalBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.TerminalBlock.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.TerminalBlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.TerminalBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.TerminalBlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.TerminalBlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.TerminalBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.TerminalBlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.TerminalBlock.is_terminal_block">
<code class="sig-name descname">is_terminal_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.TerminalBlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.TerminalBlock.is_terminal_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.TerminalBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.TerminalBlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.TerminalBlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.TerminalBlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.ThreadSafe">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">ThreadSafe</code><a class="headerlink" href="#nmodl.ast.ThreadSafe" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>Represents THREADSAFE statement in NMODL</p>
<dl class="method">
<dt id="nmodl.ast.ThreadSafe.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.ThreadSafe.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.ThreadSafe, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.ThreadSafe, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ThreadSafe.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ThreadSafe</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.ThreadSafe<a class="headerlink" href="#nmodl.ast.ThreadSafe.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ThreadSafe.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ThreadSafe</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ThreadSafe.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ThreadSafe.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ThreadSafe</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.ThreadSafe.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ThreadSafe.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ThreadSafe</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ThreadSafe.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ThreadSafe.is_thread_safe">
<code class="sig-name descname">is_thread_safe</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ThreadSafe</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.ThreadSafe.is_thread_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ThreadSafe</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ThreadSafe.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ThreadSafe</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.ThreadSafe.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.ThreadsafeVar">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">ThreadsafeVar</code><a class="headerlink" href="#nmodl.ast.ThreadsafeVar" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Identifier</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.ThreadsafeVar.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.ThreadsafeVar.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.ThreadsafeVar, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.ThreadsafeVar, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ThreadsafeVar.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ThreadsafeVar</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.ThreadsafeVar<a class="headerlink" href="#nmodl.ast.ThreadsafeVar.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ThreadsafeVar.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ThreadsafeVar</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.ThreadsafeVar.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ThreadsafeVar.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ThreadsafeVar</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.ThreadsafeVar.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ThreadsafeVar.is_threadsafe_var">
<code class="sig-name descname">is_threadsafe_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ThreadsafeVar</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.ThreadsafeVar.is_threadsafe_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.ThreadsafeVar</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.ThreadsafeVar.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.ThreadsafeVar</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.ThreadsafeVar.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.UnaryExpression">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">UnaryExpression</code><a class="headerlink" href="#nmodl.ast.UnaryExpression" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Expression</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.UnaryExpression.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.UnaryExpression.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.UnaryExpression, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.UnaryExpression, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UnaryExpression.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UnaryExpression</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.UnaryExpression<a class="headerlink" href="#nmodl.ast.UnaryExpression.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UnaryExpression.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UnaryExpression</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.UnaryExpression.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UnaryExpression.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UnaryExpression</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.UnaryExpression.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UnaryExpression.is_unary_expression">
<code class="sig-name descname">is_unary_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UnaryExpression</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.UnaryExpression.is_unary_expression" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.UnaryExpression</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UnaryExpression.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UnaryExpression</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.UnaryExpression.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.UnaryOperator">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">UnaryOperator</code><a class="headerlink" href="#nmodl.ast.UnaryOperator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Expression</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.UnaryOperator.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.UnaryOperator.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.UnaryOperator, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.UnaryOperator, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UnaryOperator.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UnaryOperator</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.UnaryOperator<a class="headerlink" href="#nmodl.ast.UnaryOperator.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UnaryOperator.eval">
<code class="sig-name descname">eval</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UnaryOperator</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.UnaryOperator.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Return value of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UnaryOperator.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UnaryOperator</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.UnaryOperator.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UnaryOperator.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UnaryOperator</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.UnaryOperator.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UnaryOperator.is_unary_operator">
<code class="sig-name descname">is_unary_operator</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UnaryOperator</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.UnaryOperator.is_unary_operator" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.UnaryOperator</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UnaryOperator.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UnaryOperator</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.UnaryOperator.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Unit">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Unit</code><a class="headerlink" href="#nmodl.ast.Unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Expression</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.Unit.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Unit.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Unit, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Unit, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Unit.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Unit</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Unit<a class="headerlink" href="#nmodl.ast.Unit.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Unit.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Unit</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Unit.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Unit.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Unit</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Unit.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Unit.is_unit">
<code class="sig-name descname">is_unit</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Unit</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Unit.is_unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Unit</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Unit.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Unit</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Unit.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.UnitBlock">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">UnitBlock</code><a class="headerlink" href="#nmodl.ast.UnitBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Block</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.UnitBlock.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.UnitBlock.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.UnitBlock, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.UnitBlock, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UnitBlock.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UnitBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.UnitBlock<a class="headerlink" href="#nmodl.ast.UnitBlock.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UnitBlock.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UnitBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.UnitBlock.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UnitBlock.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UnitBlock</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.UnitBlock.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UnitBlock.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UnitBlock</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.UnitBlock.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UnitBlock.is_unit_block">
<code class="sig-name descname">is_unit_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UnitBlock</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.UnitBlock.is_unit_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.UnitBlock</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UnitBlock.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UnitBlock</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.UnitBlock.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.UnitDef">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">UnitDef</code><a class="headerlink" href="#nmodl.ast.UnitDef" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Expression</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.UnitDef.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.UnitDef.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.UnitDef, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.UnitDef, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UnitDef.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UnitDef</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.UnitDef<a class="headerlink" href="#nmodl.ast.UnitDef.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UnitDef.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UnitDef</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.UnitDef.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UnitDef.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UnitDef</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.UnitDef.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UnitDef.is_unit_def">
<code class="sig-name descname">is_unit_def</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UnitDef</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.UnitDef.is_unit_def" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.UnitDef</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UnitDef.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UnitDef</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.UnitDef.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.UnitState">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">UnitState</code><a class="headerlink" href="#nmodl.ast.UnitState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.UnitState.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.UnitState.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.UnitState, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.UnitState, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UnitState.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UnitState</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.UnitState<a class="headerlink" href="#nmodl.ast.UnitState.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UnitState.eval">
<code class="sig-name descname">eval</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UnitState</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.UnitState.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Return value of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UnitState.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UnitState</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.UnitState.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UnitState.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UnitState</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.UnitState.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UnitState.is_unit_state">
<code class="sig-name descname">is_unit_state</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UnitState</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.UnitState.is_unit_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.UnitState</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UnitState.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UnitState</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.UnitState.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="nmodl.ast.UnknownExtra">
<em class="property">exception </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">UnknownExtra</code><a class="reference internal" href="_modules/pkg_resources.html#UnknownExtra"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.UnknownExtra" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pkg_resources.ResolutionError</span></code></p>
<p>Distribution doesn’t have an “extra feature” of the given name</p>
</dd></dl>

<dl class="class">
<dt id="nmodl.ast.UpdateDt">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">UpdateDt</code><a class="headerlink" href="#nmodl.ast.UpdateDt" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>Statement to indicate a change in timestep in a given block</p>
<dl class="method">
<dt id="nmodl.ast.UpdateDt.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.UpdateDt.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.UpdateDt, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.UpdateDt, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UpdateDt.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UpdateDt</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.UpdateDt<a class="headerlink" href="#nmodl.ast.UpdateDt.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UpdateDt.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UpdateDt</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.UpdateDt.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UpdateDt.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UpdateDt</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.UpdateDt.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UpdateDt.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UpdateDt</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.UpdateDt.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UpdateDt.is_update_dt">
<code class="sig-name descname">is_update_dt</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UpdateDt</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.UpdateDt.is_update_dt" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.UpdateDt</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.UpdateDt.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.UpdateDt</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.UpdateDt.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Useion">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Useion</code><a class="headerlink" href="#nmodl.ast.Useion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>Represents USEION statement in NMODL</p>
<dl class="method">
<dt id="nmodl.ast.Useion.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Useion.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Useion, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Useion, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Useion.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Useion</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Useion<a class="headerlink" href="#nmodl.ast.Useion.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Useion.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Useion</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Useion.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Useion.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Useion</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Useion.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Useion.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Useion</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Useion.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Useion.is_useion">
<code class="sig-name descname">is_useion</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Useion</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Useion.is_useion" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Useion</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Useion.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Useion</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Useion.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Valence">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Valence</code><a class="headerlink" href="#nmodl.ast.Valence" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Expression</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.Valence.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Valence.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Valence, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Valence, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Valence.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Valence</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Valence<a class="headerlink" href="#nmodl.ast.Valence.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Valence.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Valence</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Valence.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Valence.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Valence</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Valence.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Valence.is_valence">
<code class="sig-name descname">is_valence</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Valence</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Valence.is_valence" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Valence</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Valence.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Valence</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Valence.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.VarName">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">VarName</code><a class="headerlink" href="#nmodl.ast.VarName" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Identifier</span></code></p>
<p>Represents a variable</p>
<dl class="method">
<dt id="nmodl.ast.VarName.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.VarName.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.VarName, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.VarName, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.VarName.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.VarName</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.VarName<a class="headerlink" href="#nmodl.ast.VarName.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.VarName.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.VarName</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.VarName.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.VarName.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.VarName</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.VarName.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.VarName.is_var_name">
<code class="sig-name descname">is_var_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.VarName</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.VarName.is_var_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.VarName</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.VarName.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.VarName</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.VarName.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Verbatim">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Verbatim</code><a class="headerlink" href="#nmodl.ast.Verbatim" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>Represents a C code block</p>
<dl class="method">
<dt id="nmodl.ast.Verbatim.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Verbatim.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Verbatim, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Verbatim, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Verbatim.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Verbatim</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Verbatim<a class="headerlink" href="#nmodl.ast.Verbatim.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Verbatim.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Verbatim</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Verbatim.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Verbatim.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Verbatim</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Verbatim.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Verbatim.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Verbatim</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Verbatim.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Verbatim.is_verbatim">
<code class="sig-name descname">is_verbatim</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Verbatim</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Verbatim.is_verbatim" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Verbatim</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Verbatim.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Verbatim</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Verbatim.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="nmodl.ast.VersionConflict">
<em class="property">exception </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">VersionConflict</code><a class="reference internal" href="_modules/pkg_resources.html#VersionConflict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.VersionConflict" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pkg_resources.ResolutionError</span></code></p>
<p>An already-installed version conflicts with the requested version.</p>
<p>Should be initialized with the installed Distribution and the requested
Requirement.</p>
<dl class="method">
<dt id="nmodl.ast.VersionConflict.with_context">
<code class="sig-name descname">with_context</code><span class="sig-paren">(</span><em class="sig-param">required_by</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#VersionConflict.with_context"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.VersionConflict.with_context" title="Permalink to this definition">¶</a></dt>
<dd><p>If required_by is non-empty, return a version of self that is a
ContextualVersionConflict.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.Watch">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">Watch</code><a class="headerlink" href="#nmodl.ast.Watch" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Expression</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.Watch.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.Watch.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.Watch, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.Watch, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Watch.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Watch</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Watch<a class="headerlink" href="#nmodl.ast.Watch.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Watch.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Watch</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.Watch.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Watch.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Watch</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.Watch.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Watch.is_watch">
<code class="sig-name descname">is_watch</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Watch</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.Watch.is_watch" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.Watch</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.Watch.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.Watch</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.Watch.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.WatchStatement">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">WatchStatement</code><a class="headerlink" href="#nmodl.ast.WatchStatement" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>Represent WATCH statement in NMODL</p>
<dl class="method">
<dt id="nmodl.ast.WatchStatement.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.WatchStatement.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.WatchStatement, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.WatchStatement, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.WatchStatement.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.WatchStatement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.WatchStatement<a class="headerlink" href="#nmodl.ast.WatchStatement.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.WatchStatement.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.WatchStatement</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.WatchStatement.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.WatchStatement.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.WatchStatement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.WatchStatement.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.WatchStatement.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.WatchStatement</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.WatchStatement.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.WatchStatement.is_watch_statement">
<code class="sig-name descname">is_watch_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.WatchStatement</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.WatchStatement.is_watch_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.WatchStatement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.WatchStatement.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.WatchStatement</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.WatchStatement.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.WhileStatement">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">WhileStatement</code><a class="headerlink" href="#nmodl.ast.WhileStatement" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Statement</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.WhileStatement.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.WhileStatement.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.WhileStatement, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.WhileStatement, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.WhileStatement.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.WhileStatement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.WhileStatement<a class="headerlink" href="#nmodl.ast.WhileStatement.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.WhileStatement.get_nmodl_name">
<code class="sig-name descname">get_nmodl_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.WhileStatement</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.WhileStatement.get_nmodl_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return nmodl statement of the node</p>
<p>Some ast nodes have a member designated as nmodl name. For example,
in case of “NEURON { }” the statement of NMODL which is stored as nmodl
name is “NEURON”. This function is only implemented by node types that
have a nmodl statement.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.WhileStatement.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.WhileStatement</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.WhileStatement.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.WhileStatement.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.WhileStatement</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.WhileStatement.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.WhileStatement.is_while_statement">
<code class="sig-name descname">is_while_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.WhileStatement</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.WhileStatement.is_while_statement" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.WhileStatement</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.WhileStatement.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.WhileStatement</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.WhileStatement.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.WorkingSet">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">WorkingSet</code><span class="sig-paren">(</span><em class="sig-param">entries=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#WorkingSet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.WorkingSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A collection of active distributions on sys.path (or a similar list)</p>
<dl class="method">
<dt id="nmodl.ast.WorkingSet.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param">dist</em>, <em class="sig-param">entry=None</em>, <em class="sig-param">insert=True</em>, <em class="sig-param">replace=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#WorkingSet.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.WorkingSet.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add <cite>dist</cite> to working set, associated with <cite>entry</cite></p>
<p>If <cite>entry</cite> is unspecified, it defaults to the <code class="docutils literal notranslate"><span class="pre">.location</span></code> of <cite>dist</cite>.
On exit from this routine, <cite>entry</cite> is added to the end of the working
set’s <code class="docutils literal notranslate"><span class="pre">.entries</span></code> (if it wasn’t already present).</p>
<p><cite>dist</cite> is only added to the working set if it’s for a project that
doesn’t already have a distribution in the set, unless <cite>replace=True</cite>.
If it’s added, any callbacks registered with the <code class="docutils literal notranslate"><span class="pre">subscribe()</span></code> method
will be called.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.WorkingSet.add_entry">
<code class="sig-name descname">add_entry</code><span class="sig-paren">(</span><em class="sig-param">entry</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#WorkingSet.add_entry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.WorkingSet.add_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a path item to <code class="docutils literal notranslate"><span class="pre">.entries</span></code>, finding any distributions on it</p>
<p><code class="docutils literal notranslate"><span class="pre">find_distributions(entry,</span> <span class="pre">True)</span></code> is used to find distributions
corresponding to the path entry, and they are added.  <cite>entry</cite> is
always appended to <code class="docutils literal notranslate"><span class="pre">.entries</span></code>, even if it is already present.
(This is because <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> can contain the same value more than
once, and the <code class="docutils literal notranslate"><span class="pre">.entries</span></code> of the <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> WorkingSet should always
equal <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>.)</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.WorkingSet.find">
<code class="sig-name descname">find</code><span class="sig-paren">(</span><em class="sig-param">req</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#WorkingSet.find"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.WorkingSet.find" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a distribution matching requirement <cite>req</cite></p>
<p>If there is an active distribution for the requested project, this
returns it as long as it meets the version requirement specified by
<cite>req</cite>.  But, if there is an active distribution for the project and it
does <em>not</em> meet the <cite>req</cite> requirement, <code class="docutils literal notranslate"><span class="pre">VersionConflict</span></code> is raised.
If there is no active distribution for the requested project, <code class="docutils literal notranslate"><span class="pre">None</span></code>
is returned.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.WorkingSet.find_plugins">
<code class="sig-name descname">find_plugins</code><span class="sig-paren">(</span><em class="sig-param">plugin_env</em>, <em class="sig-param">full_env=None</em>, <em class="sig-param">installer=None</em>, <em class="sig-param">fallback=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#WorkingSet.find_plugins"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.WorkingSet.find_plugins" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all activatable distributions in <cite>plugin_env</cite></p>
<p>Example usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">distributions</span><span class="p">,</span> <span class="n">errors</span> <span class="o">=</span> <span class="n">working_set</span><span class="o">.</span><span class="n">find_plugins</span><span class="p">(</span>
    <span class="n">Environment</span><span class="p">(</span><span class="n">plugin_dirlist</span><span class="p">)</span>
<span class="p">)</span>
<span class="c1"># add plugins+libs to sys.path</span>
<span class="nb">map</span><span class="p">(</span><span class="n">working_set</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="n">distributions</span><span class="p">)</span>
<span class="c1"># display errors</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Could not load&#39;</span><span class="p">,</span> <span class="n">errors</span><span class="p">)</span>
</pre></div>
</div>
<p>The <cite>plugin_env</cite> should be an <code class="docutils literal notranslate"><span class="pre">Environment</span></code> instance that contains
only distributions that are in the project’s “plugin directory” or
directories. The <cite>full_env</cite>, if supplied, should be an <code class="docutils literal notranslate"><span class="pre">Environment</span></code>
contains all currently-available distributions.  If <cite>full_env</cite> is not
supplied, one is created automatically from the <code class="docutils literal notranslate"><span class="pre">WorkingSet</span></code> this
method is called on, which will typically mean that every directory on
<code class="docutils literal notranslate"><span class="pre">sys.path</span></code> will be scanned for distributions.</p>
<p><cite>installer</cite> is a standard installer callback as used by the
<code class="docutils literal notranslate"><span class="pre">resolve()</span></code> method. The <cite>fallback</cite> flag indicates whether we should
attempt to resolve older versions of a plugin if the newest version
cannot be resolved.</p>
<p>This method returns a 2-tuple: (<cite>distributions</cite>, <cite>error_info</cite>), where
<cite>distributions</cite> is a list of the distributions found in <cite>plugin_env</cite>
that were loadable, along with any other distributions that are needed
to resolve their dependencies.  <cite>error_info</cite> is a dictionary mapping
unloadable plugin distributions to an exception instance describing the
error that occurred. Usually this will be a <code class="docutils literal notranslate"><span class="pre">DistributionNotFound</span></code> or
<code class="docutils literal notranslate"><span class="pre">VersionConflict</span></code> instance.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.WorkingSet.iter_entry_points">
<code class="sig-name descname">iter_entry_points</code><span class="sig-paren">(</span><em class="sig-param">group</em>, <em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#WorkingSet.iter_entry_points"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.WorkingSet.iter_entry_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield entry point objects from <cite>group</cite> matching <cite>name</cite></p>
<p>If <cite>name</cite> is None, yields all entry points in <cite>group</cite> from all
distributions in the working set, otherwise only ones matching
both <cite>group</cite> and <cite>name</cite> are yielded (in distribution order).</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.WorkingSet.require">
<code class="sig-name descname">require</code><span class="sig-paren">(</span><em class="sig-param">*requirements</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#WorkingSet.require"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.WorkingSet.require" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure that distributions matching <cite>requirements</cite> are activated</p>
<p><cite>requirements</cite> must be a string or a (possibly-nested) sequence
thereof, specifying the distributions and versions required.  The
return value is a sequence of the distributions that needed to be
activated to fulfill the requirements; all relevant distributions are
included, even if they were already activated in this working set.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.WorkingSet.resolve">
<code class="sig-name descname">resolve</code><span class="sig-paren">(</span><em class="sig-param">requirements</em>, <em class="sig-param">env=None</em>, <em class="sig-param">installer=None</em>, <em class="sig-param">replace_conflicting=False</em>, <em class="sig-param">extras=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#WorkingSet.resolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.WorkingSet.resolve" title="Permalink to this definition">¶</a></dt>
<dd><p>List all distributions needed to (recursively) meet <cite>requirements</cite></p>
<p><cite>requirements</cite> must be a sequence of <code class="docutils literal notranslate"><span class="pre">Requirement</span></code> objects.  <cite>env</cite>,
if supplied, should be an <code class="docutils literal notranslate"><span class="pre">Environment</span></code> instance.  If
not supplied, it defaults to all distributions available within any
entry or distribution in the working set.  <cite>installer</cite>, if supplied,
will be invoked with each requirement that cannot be met by an
already-installed distribution; it should return a <code class="docutils literal notranslate"><span class="pre">Distribution</span></code> or
<code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Unless <cite>replace_conflicting=True</cite>, raises a VersionConflict exception
if
any requirements are found on the path that have the correct name but
the wrong version.  Otherwise, if an <cite>installer</cite> is supplied it will be
invoked to obtain the correct version of the requirement and activate
it.</p>
<p><cite>extras</cite> is a list of the extras to be used with these requirements.
This is important because extra requirements may look like <cite>my_req;
extra = “my_extra”</cite>, which would otherwise be interpreted as a purely
optional requirement.  Instead, we want to be able to assert that these
requirements are truly required.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.WorkingSet.run_script">
<code class="sig-name descname">run_script</code><span class="sig-paren">(</span><em class="sig-param">requires</em>, <em class="sig-param">script_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#WorkingSet.run_script"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.WorkingSet.run_script" title="Permalink to this definition">¶</a></dt>
<dd><p>Locate distribution for <cite>requires</cite> and run <cite>script_name</cite> script</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.WorkingSet.subscribe">
<code class="sig-name descname">subscribe</code><span class="sig-paren">(</span><em class="sig-param">callback</em>, <em class="sig-param">existing=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#WorkingSet.subscribe"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.WorkingSet.subscribe" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke <cite>callback</cite> for all distributions</p>
<p>If <cite>existing=True</cite> (default),
call on all existing ones, as well.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.WrappedExpression">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">WrappedExpression</code><a class="headerlink" href="#nmodl.ast.WrappedExpression" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Expression</span></code></p>
<p>Wrap any other expression type</p>
<dl class="method">
<dt id="nmodl.ast.WrappedExpression.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.WrappedExpression.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.WrappedExpression, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.WrappedExpression, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.WrappedExpression.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.WrappedExpression</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.WrappedExpression<a class="headerlink" href="#nmodl.ast.WrappedExpression.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.WrappedExpression.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.WrappedExpression</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.WrappedExpression.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.WrappedExpression.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.WrappedExpression</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.WrappedExpression.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.WrappedExpression.is_wrapped_expression">
<code class="sig-name descname">is_wrapped_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.WrappedExpression</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.WrappedExpression.is_wrapped_expression" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.WrappedExpression</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.WrappedExpression.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.WrappedExpression</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.WrappedExpression.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.WriteIonVar">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">WriteIonVar</code><a class="headerlink" href="#nmodl.ast.WriteIonVar" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.ast.Identifier</span></code></p>
<p>TODO</p>
<dl class="method">
<dt id="nmodl.ast.WriteIonVar.accept">
<code class="sig-name descname">accept</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.WriteIonVar.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>accept(self: nmodl._nmodl.ast.WriteIonVar, arg0: nmodl._nmodl.visitor.Visitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p>accept(self: nmodl._nmodl.ast.WriteIonVar, arg0: nmodl._nmodl.visitor.ConstVisitor) -&gt; None</p>
<blockquote>
<div><p>Accept (or visit) the current AST node using current visitor</p>
<p>Instead of visiting children of AST node, like Ast::visit_children,
accept allows to visit the current node itself using the concrete
visitor provided.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>v (Visitor):  Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.WriteIonVar.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.WriteIonVar</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.WriteIonVar<a class="headerlink" href="#nmodl.ast.WriteIonVar.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of the AST node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.WriteIonVar.get_node_type">
<code class="sig-name descname">get_node_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.WriteIonVar</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.AstNodeType<a class="headerlink" href="#nmodl.ast.WriteIonVar.get_node_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.WriteIonVar.get_node_type_name">
<code class="sig-name descname">get_node_type_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.WriteIonVar</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.ast.WriteIonVar.get_node_type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type (ast.AstNodeType) of the ast node as string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.WriteIonVar.is_write_ion_var">
<code class="sig-name descname">is_write_ion_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.WriteIonVar</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.ast.WriteIonVar.is_write_ion_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if node is of type ast.WriteIonVar</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.ast.WriteIonVar.visit_children">
<code class="sig-name descname">visit_children</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.ast.WriteIonVar</em>, <em class="sig-param">arg0: nmodl._nmodl.visitor.Visitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.ast.WriteIonVar.visit_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Visit children i.e. member of current AST node using provided visitor</p>
<p>Different nodes in the AST have different members (i.e. children). This method
recursively visits children using provided concrete visitor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> (<a class="reference internal" href="#nmodl.visitor.Visitor" title="nmodl.visitor.Visitor"><em>Visitor</em></a>) – Concrete visitor that will be used to recursively visit node</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.ast.ZipProvider">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">ZipProvider</code><span class="sig-paren">(</span><em class="sig-param">module</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#ZipProvider"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.ZipProvider" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pkg_resources.EggProvider</span></code></p>
<p>Resource support for zips and eggs</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.add_activation_listener">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">add_activation_listener</code><span class="sig-paren">(</span><em class="sig-param">callback</em>, <em class="sig-param">existing=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.add_activation_listener" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke <cite>callback</cite> for all distributions</p>
<p>If <cite>existing=True</cite> (default),
call on all existing ones, as well.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.cleanup_resources">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">cleanup_resources</code><span class="sig-paren">(</span><em class="sig-param">force=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.cleanup_resources" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete all extracted resource files and directories, returning a list
of the file and directory names that could not be successfully removed.
This function does not have any concurrency protection, so it should
generally only be called when the extraction path is a temporary
directory exclusive to a single process.  This method is not
automatically called; you must call it explicitly or register it as an
<code class="docutils literal notranslate"><span class="pre">atexit</span></code> function if you wish to ensure cleanup of a temporary
directory used for extractions.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.compatible_platforms">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">compatible_platforms</code><span class="sig-paren">(</span><em class="sig-param">provided</em>, <em class="sig-param">required</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#compatible_platforms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.compatible_platforms" title="Permalink to this definition">¶</a></dt>
<dd><p>Can code for the <cite>provided</cite> platform run on the <cite>required</cite> platform?</p>
<p>Returns true if either platform is <code class="docutils literal notranslate"><span class="pre">None</span></code>, or the platforms are equal.</p>
<p>XXX Needs compatibility checks for Linux and other unixy OSes.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.declare_namespace">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">declare_namespace</code><span class="sig-paren">(</span><em class="sig-param">packageName</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#declare_namespace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.declare_namespace" title="Permalink to this definition">¶</a></dt>
<dd><p>Declare that package ‘packageName’ is a namespace package</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.ensure_directory">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">ensure_directory</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#ensure_directory"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.ensure_directory" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure that the parent directory of <cite>path</cite> exists</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.evaluate_marker">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">evaluate_marker</code><span class="sig-paren">(</span><em class="sig-param">text</em>, <em class="sig-param">extra=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#evaluate_marker"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.evaluate_marker" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a PEP 508 environment marker.
Return a boolean indicating the marker result in this environment.
Raise SyntaxError if marker is invalid.</p>
<p>This implementation uses the ‘pyparsing’ module.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.find_distributions">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">find_distributions</code><span class="sig-paren">(</span><em class="sig-param">path_item</em>, <em class="sig-param">only=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#find_distributions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.find_distributions" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield distributions accessible via <cite>path_item</cite></p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.fixup_namespace_packages">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">fixup_namespace_packages</code><span class="sig-paren">(</span><em class="sig-param">path_item</em>, <em class="sig-param">parent=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#fixup_namespace_packages"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.fixup_namespace_packages" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure that previously-declared namespace packages include path_item</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.get_default_cache">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">get_default_cache</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#get_default_cache"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.get_default_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <code class="docutils literal notranslate"><span class="pre">PYTHON_EGG_CACHE</span></code> environment variable
or a platform-relevant user cache dir for an app
named “Python-Eggs”.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.get_distribution">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">get_distribution</code><span class="sig-paren">(</span><em class="sig-param">dist</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#get_distribution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.get_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a current distribution object for a Requirement or string</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.get_entry_info">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">get_entry_info</code><span class="sig-paren">(</span><em class="sig-param">dist</em>, <em class="sig-param">group</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#get_entry_info"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.get_entry_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the EntryPoint object for <cite>group`+`name</cite>, or <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.get_entry_map">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">get_entry_map</code><span class="sig-paren">(</span><em class="sig-param">dist</em>, <em class="sig-param">group=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#get_entry_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.get_entry_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the entry point map for <cite>group</cite>, or the full entry map</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.get_importer">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">get_importer</code><span class="sig-paren">(</span><em class="sig-param">path_item</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkgutil.html#get_importer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.get_importer" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a finder for the given path item</p>
<p>The returned finder is cached in sys.path_importer_cache
if it was newly created by a path hook.</p>
<p>The cache (or part of it) can be cleared manually if a
rescan of sys.path_hooks is necessary.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.get_platform">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">get_platform</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.get_platform" title="Permalink to this definition">¶</a></dt>
<dd><p>Return this platform’s string for platform-specific distributions</p>
<p>XXX Currently this is the same as <code class="docutils literal notranslate"><span class="pre">distutils.util.get_platform()</span></code>, but it
needs some hacks for Linux and macOS.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.get_provider">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">get_provider</code><span class="sig-paren">(</span><em class="sig-param">moduleOrReq</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#get_provider"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.get_provider" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an IResourceProvider for the named module or requirement</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.invalid_marker">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">invalid_marker</code><span class="sig-paren">(</span><em class="sig-param">text</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#invalid_marker"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.invalid_marker" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate text as a PEP 508 environment marker; return an exception
if invalid or False otherwise.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.iter_entry_points">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">iter_entry_points</code><span class="sig-paren">(</span><em class="sig-param">group</em>, <em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.iter_entry_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield entry point objects from <cite>group</cite> matching <cite>name</cite></p>
<p>If <cite>name</cite> is None, yields all entry points in <cite>group</cite> from all
distributions in the working set, otherwise only ones matching
both <cite>group</cite> and <cite>name</cite> are yielded (in distribution order).</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.load_entry_point">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">load_entry_point</code><span class="sig-paren">(</span><em class="sig-param">dist</em>, <em class="sig-param">group</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#load_entry_point"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.load_entry_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <cite>name</cite> entry point of <cite>group</cite> for <cite>dist</cite> or raise ImportError</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.normalize_path">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">normalize_path</code><span class="sig-paren">(</span><em class="sig-param">filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#normalize_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.normalize_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize a file/dir name for comparison purposes</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.parse_requirements">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">parse_requirements</code><span class="sig-paren">(</span><em class="sig-param">strs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#parse_requirements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.parse_requirements" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield <code class="docutils literal notranslate"><span class="pre">Requirement</span></code> objects for each specification in <cite>strs</cite></p>
<p><cite>strs</cite> must be a string, or a (possibly-nested) iterable thereof.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.register_finder">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">register_finder</code><span class="sig-paren">(</span><em class="sig-param">importer_type</em>, <em class="sig-param">distribution_finder</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#register_finder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.register_finder" title="Permalink to this definition">¶</a></dt>
<dd><p>Register <cite>distribution_finder</cite> to find distributions in sys.path items</p>
<p><cite>importer_type</cite> is the type or class of a PEP 302 “Importer” (sys.path item
handler), and <cite>distribution_finder</cite> is a callable that, passed a path
item and the importer instance, yields <code class="docutils literal notranslate"><span class="pre">Distribution</span></code> instances found on
that path item.  See <code class="docutils literal notranslate"><span class="pre">pkg_resources.find_on_path</span></code> for an example.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.register_loader_type">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">register_loader_type</code><span class="sig-paren">(</span><em class="sig-param">loader_type</em>, <em class="sig-param">provider_factory</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#register_loader_type"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.register_loader_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Register <cite>provider_factory</cite> to make providers for <cite>loader_type</cite></p>
<p><cite>loader_type</cite> is the type or class of a PEP 302 <code class="docutils literal notranslate"><span class="pre">module.__loader__</span></code>,
and <cite>provider_factory</cite> is a function that, passed a <em>module</em> object,
returns an <code class="docutils literal notranslate"><span class="pre">IResourceProvider</span></code> for that module.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.register_namespace_handler">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">register_namespace_handler</code><span class="sig-paren">(</span><em class="sig-param">importer_type</em>, <em class="sig-param">namespace_handler</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#register_namespace_handler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.register_namespace_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>Register <cite>namespace_handler</cite> to declare namespace packages</p>
<p><cite>importer_type</cite> is the type or class of a PEP 302 “Importer” (sys.path item
handler), and <cite>namespace_handler</cite> is a callable like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">namespace_handler</span><span class="p">(</span><span class="n">importer</span><span class="p">,</span> <span class="n">path_entry</span><span class="p">,</span> <span class="n">moduleName</span><span class="p">,</span> <span class="n">module</span><span class="p">):</span>
    <span class="c1"># return a path_entry to use for child packages</span>
</pre></div>
</div>
<p>Namespace handlers are only called if the importer object has already
agreed that it can handle the relevant path item, and they should only
return a subpath if the module __path__ does not already contain an
equivalent subpath.  For an example namespace handler, see
<code class="docutils literal notranslate"><span class="pre">pkg_resources.file_ns_handler</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.require">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">require</code><span class="sig-paren">(</span><em class="sig-param">*requirements</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.require" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure that distributions matching <cite>requirements</cite> are activated</p>
<p><cite>requirements</cite> must be a string or a (possibly-nested) sequence
thereof, specifying the distributions and versions required.  The
return value is a sequence of the distributions that needed to be
activated to fulfill the requirements; all relevant distributions are
included, even if they were already activated in this working set.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.resource_exists">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">resource_exists</code><span class="sig-paren">(</span><em class="sig-param">package_or_requirement</em>, <em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.resource_exists" title="Permalink to this definition">¶</a></dt>
<dd><p>Does the named resource exist?</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.resource_filename">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">resource_filename</code><span class="sig-paren">(</span><em class="sig-param">package_or_requirement</em>, <em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.resource_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a true filesystem path for specified resource</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.resource_isdir">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">resource_isdir</code><span class="sig-paren">(</span><em class="sig-param">package_or_requirement</em>, <em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.resource_isdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the named resource an existing directory?</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.resource_listdir">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">resource_listdir</code><span class="sig-paren">(</span><em class="sig-param">package_or_requirement</em>, <em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.resource_listdir" title="Permalink to this definition">¶</a></dt>
<dd><p>List the contents of the named resource directory</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.resource_stream">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">resource_stream</code><span class="sig-paren">(</span><em class="sig-param">package_or_requirement</em>, <em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.resource_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a readable file-like object for specified resource</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.resource_string">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">resource_string</code><span class="sig-paren">(</span><em class="sig-param">package_or_requirement</em>, <em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.resource_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Return specified resource as a string</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.run_main">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">run_main</code><span class="sig-paren">(</span><em class="sig-param">requires</em>, <em class="sig-param">script_name</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.run_main" title="Permalink to this definition">¶</a></dt>
<dd><p>Locate distribution for <cite>requires</cite> and run <cite>script_name</cite> script</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.run_script">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">run_script</code><span class="sig-paren">(</span><em class="sig-param">requires</em>, <em class="sig-param">script_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#run_script"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.run_script" title="Permalink to this definition">¶</a></dt>
<dd><p>Locate distribution for <cite>requires</cite> and run <cite>script_name</cite> script</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.safe_extra">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">safe_extra</code><span class="sig-paren">(</span><em class="sig-param">extra</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#safe_extra"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.safe_extra" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an arbitrary string to a standard ‘extra’ name</p>
<p>Any runs of non-alphanumeric characters are replaced with a single ‘_’,
and the result is always lowercased.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.safe_name">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">safe_name</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#safe_name"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.safe_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an arbitrary string to a standard distribution name</p>
<p>Any runs of non-alphanumeric/. characters are replaced with a single ‘-‘.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.safe_version">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">safe_version</code><span class="sig-paren">(</span><em class="sig-param">version</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#safe_version"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.safe_version" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an arbitrary string to a standard version string</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.set_extraction_path">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">set_extraction_path</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.ast.set_extraction_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the base path where resources will be extracted to, if needed.</p>
<p>If you do not call this routine before any extractions take place, the
path defaults to the return value of <code class="docutils literal notranslate"><span class="pre">get_default_cache()</span></code>.  (Which
is based on the <code class="docutils literal notranslate"><span class="pre">PYTHON_EGG_CACHE</span></code> environment variable, with various
platform-specific fallbacks.  See that routine’s documentation for more
details.)</p>
<p>Resources are extracted to subdirectories of this path based upon
information given by the <code class="docutils literal notranslate"><span class="pre">IResourceProvider</span></code>.  You may set this to a
temporary directory, but then you must call <code class="docutils literal notranslate"><span class="pre">cleanup_resources()</span></code> to
delete the extracted files when done.  There is no guarantee that
<code class="docutils literal notranslate"><span class="pre">cleanup_resources()</span></code> will be able to remove all extracted files.</p>
<p>(Note: you may not change the extraction path for a given resource
manager once resources have been extracted, unless you first call
<code class="docutils literal notranslate"><span class="pre">cleanup_resources()</span></code>.)</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.split_sections">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">split_sections</code><span class="sig-paren">(</span><em class="sig-param">s</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#split_sections"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.split_sections" title="Permalink to this definition">¶</a></dt>
<dd><p>Split a string or iterable thereof into (section, content) pairs</p>
<p>Each <code class="docutils literal notranslate"><span class="pre">section</span></code> is a stripped version of the section header (“[section]”)
and each <code class="docutils literal notranslate"><span class="pre">content</span></code> is a list of stripped lines excluding blank lines and
comment-only lines.  If there are any such lines before the first section
header, they’re returned in a first <code class="docutils literal notranslate"><span class="pre">section</span></code> of <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.to_filename">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">to_filename</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#to_filename"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.to_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a project or version name to its filename-escaped form</p>
<p>Any ‘-’ characters are currently replaced with ‘_’.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.view">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">view</code><span class="sig-paren">(</span><em class="sig-param">nmodl_ast</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmodl/ast.html#view"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.view" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize given NMODL AST in web browser</p>
<p>In memory representation of AST can be converted to JSON
form and it can be visualized using AST viewer implemented
using d3.js.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>nmodl_ast</strong> – AST object of nmodl file or string</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nmodl.ast.yield_lines">
<code class="sig-prename descclassname">nmodl.ast.</code><code class="sig-name descname">yield_lines</code><span class="sig-paren">(</span><em class="sig-param">iterable</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#yield_lines"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ast.yield_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield valid lines of a string or iterable</p>
</dd></dl>

</section>
<section id="module-nmodl.dsl">
<span id="nmodl-dsl-module"></span><h2>nmodl.dsl module<a class="headerlink" href="#module-nmodl.dsl" title="Permalink to this headline">¶</a></h2>
<dl class="attribute">
<dt id="nmodl.dsl.AvailableDistributions">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">AvailableDistributions</code><a class="headerlink" href="#nmodl.dsl.AvailableDistributions" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">pkg_resources.Environment</span></code></p>
</dd></dl>

<dl class="class">
<dt id="nmodl.dsl.DefaultProvider">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">DefaultProvider</code><span class="sig-paren">(</span><em class="sig-param">module</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#DefaultProvider"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.DefaultProvider" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pkg_resources.EggProvider</span></code></p>
<p>Provides access to package resources in the filesystem</p>
<dl class="method">
<dt id="nmodl.dsl.DefaultProvider.get_resource_stream">
<code class="sig-name descname">get_resource_stream</code><span class="sig-paren">(</span><em class="sig-param">manager</em>, <em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#DefaultProvider.get_resource_stream"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.DefaultProvider.get_resource_stream" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.dsl.Distribution">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">Distribution</code><span class="sig-paren">(</span><em class="sig-param">location=None</em>, <em class="sig-param">metadata=None</em>, <em class="sig-param">project_name=None</em>, <em class="sig-param">version=None</em>, <em class="sig-param">py_version='3.8'</em>, <em class="sig-param">platform=None</em>, <em class="sig-param">precedence=3</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Distribution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.Distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Wrap an actual or potential sys.path entry w/metadata</p>
<dl class="attribute">
<dt id="nmodl.dsl.Distribution.PKG_INFO">
<code class="sig-name descname">PKG_INFO</code><em class="property"> = 'PKG-INFO'</em><a class="headerlink" href="#nmodl.dsl.Distribution.PKG_INFO" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.Distribution.activate">
<code class="sig-name descname">activate</code><span class="sig-paren">(</span><em class="sig-param">path=None</em>, <em class="sig-param">replace=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Distribution.activate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.Distribution.activate" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure distribution is importable on <cite>path</cite> (default=sys.path)</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.Distribution.as_requirement">
<code class="sig-name descname">as_requirement</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Distribution.as_requirement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.Distribution.as_requirement" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <code class="docutils literal notranslate"><span class="pre">Requirement</span></code> that matches this distribution exactly</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.Distribution.check_version_conflict">
<code class="sig-name descname">check_version_conflict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Distribution.check_version_conflict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.Distribution.check_version_conflict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.Distribution.clone">
<code class="sig-name descname">clone</code><span class="sig-paren">(</span><em class="sig-param">**kw</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Distribution.clone"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.Distribution.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy this distribution, substituting in any changed keyword args</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.Distribution.egg_name">
<code class="sig-name descname">egg_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Distribution.egg_name"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.Distribution.egg_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return what this distribution’s standard .egg filename should be</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.Distribution.extras">
<em class="property">property </em><code class="sig-name descname">extras</code><a class="headerlink" href="#nmodl.dsl.Distribution.extras" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.Distribution.from_filename">
<em class="property">classmethod </em><code class="sig-name descname">from_filename</code><span class="sig-paren">(</span><em class="sig-param">filename</em>, <em class="sig-param">metadata=None</em>, <em class="sig-param">**kw</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Distribution.from_filename"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.Distribution.from_filename" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.Distribution.from_location">
<em class="property">classmethod </em><code class="sig-name descname">from_location</code><span class="sig-paren">(</span><em class="sig-param">location</em>, <em class="sig-param">basename</em>, <em class="sig-param">metadata=None</em>, <em class="sig-param">**kw</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Distribution.from_location"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.Distribution.from_location" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.Distribution.get_entry_info">
<code class="sig-name descname">get_entry_info</code><span class="sig-paren">(</span><em class="sig-param">group</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Distribution.get_entry_info"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.Distribution.get_entry_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the EntryPoint object for <cite>group`+`name</cite>, or <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.Distribution.get_entry_map">
<code class="sig-name descname">get_entry_map</code><span class="sig-paren">(</span><em class="sig-param">group=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Distribution.get_entry_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.Distribution.get_entry_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the entry point map for <cite>group</cite>, or the full entry map</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.Distribution.has_version">
<code class="sig-name descname">has_version</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Distribution.has_version"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.Distribution.has_version" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.Distribution.hashcmp">
<em class="property">property </em><code class="sig-name descname">hashcmp</code><a class="headerlink" href="#nmodl.dsl.Distribution.hashcmp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.Distribution.insert_on">
<code class="sig-name descname">insert_on</code><span class="sig-paren">(</span><em class="sig-param">path</em>, <em class="sig-param">loc=None</em>, <em class="sig-param">replace=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Distribution.insert_on"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.Distribution.insert_on" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure self.location is on path</p>
<dl>
<dt>If replace=False (default):</dt><dd><ul>
<li><p>If location is already in path anywhere, do nothing.</p></li>
<li><p>Else:
- If it’s an egg and its parent directory is on path,</p>
<blockquote>
<div><p>insert just ahead of the parent.</p>
</div></blockquote>
<ul class="simple">
<li><p>Else: add to the end of path.</p></li>
</ul>
</li>
</ul>
</dd>
<dt>If replace=True:</dt><dd><ul>
<li><p>If location is already on path anywhere (not eggs)
or higher priority than its parent (eggs)
do nothing.</p></li>
<li><p>Else:
- If it’s an egg and its parent directory is on path,</p>
<blockquote>
<div><p>insert just ahead of the parent,
removing any lower-priority entries.</p>
</div></blockquote>
<ul class="simple">
<li><p>Else: add it to the front of path.</p></li>
</ul>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.Distribution.key">
<em class="property">property </em><code class="sig-name descname">key</code><a class="headerlink" href="#nmodl.dsl.Distribution.key" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.Distribution.load_entry_point">
<code class="sig-name descname">load_entry_point</code><span class="sig-paren">(</span><em class="sig-param">group</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Distribution.load_entry_point"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.Distribution.load_entry_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <cite>name</cite> entry point of <cite>group</cite> or raise ImportError</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.Distribution.parsed_version">
<em class="property">property </em><code class="sig-name descname">parsed_version</code><a class="headerlink" href="#nmodl.dsl.Distribution.parsed_version" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.Distribution.requires">
<code class="sig-name descname">requires</code><span class="sig-paren">(</span><em class="sig-param">extras=()</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Distribution.requires"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.Distribution.requires" title="Permalink to this definition">¶</a></dt>
<dd><p>List of Requirements needed for this distro if <cite>extras</cite> are used</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.Distribution.version">
<em class="property">property </em><code class="sig-name descname">version</code><a class="headerlink" href="#nmodl.dsl.Distribution.version" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="nmodl.dsl.DistributionNotFound">
<em class="property">exception </em><code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">DistributionNotFound</code><a class="reference internal" href="_modules/pkg_resources.html#DistributionNotFound"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.DistributionNotFound" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pkg_resources.ResolutionError</span></code></p>
<p>A requested distribution was not found</p>
<dl class="method">
<dt id="nmodl.dsl.DistributionNotFound.report">
<code class="sig-name descname">report</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#DistributionNotFound.report"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.DistributionNotFound.report" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.DistributionNotFound.req">
<em class="property">property </em><code class="sig-name descname">req</code><a class="headerlink" href="#nmodl.dsl.DistributionNotFound.req" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.DistributionNotFound.requirers">
<em class="property">property </em><code class="sig-name descname">requirers</code><a class="headerlink" href="#nmodl.dsl.DistributionNotFound.requirers" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.DistributionNotFound.requirers_str">
<em class="property">property </em><code class="sig-name descname">requirers_str</code><a class="headerlink" href="#nmodl.dsl.DistributionNotFound.requirers_str" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.dsl.EggMetadata">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">EggMetadata</code><span class="sig-paren">(</span><em class="sig-param">importer</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#EggMetadata"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.EggMetadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pkg_resources.ZipProvider</span></code></p>
<p>Metadata provider for .egg files</p>
</dd></dl>

<dl class="class">
<dt id="nmodl.dsl.EggProvider">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">EggProvider</code><span class="sig-paren">(</span><em class="sig-param">module</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#EggProvider"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.EggProvider" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pkg_resources.NullProvider</span></code></p>
<p>Provider based on a virtual filesystem</p>
</dd></dl>

<dl class="class">
<dt id="nmodl.dsl.EmptyProvider">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">EmptyProvider</code><a class="reference internal" href="_modules/pkg_resources.html#EmptyProvider"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.EmptyProvider" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pkg_resources.NullProvider</span></code></p>
<p>Provider that returns nothing for all requests</p>
<dl class="attribute">
<dt id="nmodl.dsl.EmptyProvider.module_path">
<code class="sig-name descname">module_path</code><em class="property"> = None</em><a class="headerlink" href="#nmodl.dsl.EmptyProvider.module_path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.dsl.EntryPoint">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">EntryPoint</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">module_name</em>, <em class="sig-param">attrs=()</em>, <em class="sig-param">extras=()</em>, <em class="sig-param">dist=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#EntryPoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.EntryPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Object representing an advertised importable object</p>
<dl class="method">
<dt id="nmodl.dsl.EntryPoint.load">
<code class="sig-name descname">load</code><span class="sig-paren">(</span><em class="sig-param">require=True</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#EntryPoint.load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.EntryPoint.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Require packages for this EntryPoint, then resolve it.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.EntryPoint.parse">
<em class="property">classmethod </em><code class="sig-name descname">parse</code><span class="sig-paren">(</span><em class="sig-param">src</em>, <em class="sig-param">dist=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#EntryPoint.parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.EntryPoint.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a single entry point from string <cite>src</cite></p>
<p>Entry point syntax follows the form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">name</span> <span class="o">=</span> <span class="n">some</span><span class="o">.</span><span class="n">module</span><span class="p">:</span><span class="n">some</span><span class="o">.</span><span class="n">attr</span> <span class="p">[</span><span class="n">extra1</span><span class="p">,</span> <span class="n">extra2</span><span class="p">]</span>
</pre></div>
</div>
<p>The entry name and module name are required, but the <code class="docutils literal notranslate"><span class="pre">:attrs</span></code> and
<code class="docutils literal notranslate"><span class="pre">[extras]</span></code> parts are optional</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.EntryPoint.parse_group">
<em class="property">classmethod </em><code class="sig-name descname">parse_group</code><span class="sig-paren">(</span><em class="sig-param">group</em>, <em class="sig-param">lines</em>, <em class="sig-param">dist=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#EntryPoint.parse_group"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.EntryPoint.parse_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse an entry point group</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.EntryPoint.parse_map">
<em class="property">classmethod </em><code class="sig-name descname">parse_map</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">dist=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#EntryPoint.parse_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.EntryPoint.parse_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a map of entry point groups</p>
</dd></dl>

<dl class="attribute">
<dt id="nmodl.dsl.EntryPoint.pattern">
<code class="sig-name descname">pattern</code><em class="property"> = re.compile('\\s*(?P&lt;name&gt;.+?)\\s*=\\s*(?P&lt;module&gt;[\\w.]+)\\s*(:\\s*(?P&lt;attr&gt;[\\w.]+))?\\s*(?P&lt;extras&gt;\\[.*\\])?\\s*$')</em><a class="headerlink" href="#nmodl.dsl.EntryPoint.pattern" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.EntryPoint.require">
<code class="sig-name descname">require</code><span class="sig-paren">(</span><em class="sig-param">env=None</em>, <em class="sig-param">installer=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#EntryPoint.require"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.EntryPoint.require" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.EntryPoint.resolve">
<code class="sig-name descname">resolve</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#EntryPoint.resolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.EntryPoint.resolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Resolve the entry point from its module and attrs.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.dsl.Environment">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">Environment</code><span class="sig-paren">(</span><em class="sig-param">search_path=None</em>, <em class="sig-param">platform='linux-x86_64'</em>, <em class="sig-param">python='3.8'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Environment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.Environment" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Searchable snapshot of distributions on a search path</p>
<dl class="method">
<dt id="nmodl.dsl.Environment.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param">dist</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Environment.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.Environment.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add <cite>dist</cite> if we <code class="docutils literal notranslate"><span class="pre">can_add()</span></code> it and it has not already been added</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.Environment.best_match">
<code class="sig-name descname">best_match</code><span class="sig-paren">(</span><em class="sig-param">req</em>, <em class="sig-param">working_set</em>, <em class="sig-param">installer=None</em>, <em class="sig-param">replace_conflicting=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Environment.best_match"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.Environment.best_match" title="Permalink to this definition">¶</a></dt>
<dd><p>Find distribution best matching <cite>req</cite> and usable on <cite>working_set</cite></p>
<p>This calls the <code class="docutils literal notranslate"><span class="pre">find(req)</span></code> method of the <cite>working_set</cite> to see if a
suitable distribution is already active.  (This may raise
<code class="docutils literal notranslate"><span class="pre">VersionConflict</span></code> if an unsuitable version of the project is already
active in the specified <cite>working_set</cite>.)  If a suitable distribution
isn’t active, this method returns the newest distribution in the
environment that meets the <code class="docutils literal notranslate"><span class="pre">Requirement</span></code> in <cite>req</cite>.  If no suitable
distribution is found, and <cite>installer</cite> is supplied, then the result of
calling the environment’s <code class="docutils literal notranslate"><span class="pre">obtain(req,</span> <span class="pre">installer)</span></code> method will be
returned.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.Environment.can_add">
<code class="sig-name descname">can_add</code><span class="sig-paren">(</span><em class="sig-param">dist</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Environment.can_add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.Environment.can_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Is distribution <cite>dist</cite> acceptable for this environment?</p>
<p>The distribution must match the platform and python version
requirements specified when this environment was created, or False
is returned.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.Environment.obtain">
<code class="sig-name descname">obtain</code><span class="sig-paren">(</span><em class="sig-param">requirement</em>, <em class="sig-param">installer=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Environment.obtain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.Environment.obtain" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain a distribution matching <cite>requirement</cite> (e.g. via download)</p>
<p>Obtain a distro that matches requirement (e.g. via download).  In the
base <code class="docutils literal notranslate"><span class="pre">Environment</span></code> class, this routine just returns
<code class="docutils literal notranslate"><span class="pre">installer(requirement)</span></code>, unless <cite>installer</cite> is None, in which case
None is returned instead.  This method is a hook that allows subclasses
to attempt other ways of obtaining a distribution before falling back
to the <cite>installer</cite> argument.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.Environment.remove">
<code class="sig-name descname">remove</code><span class="sig-paren">(</span><em class="sig-param">dist</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Environment.remove"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.Environment.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove <cite>dist</cite> from the environment</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.Environment.scan">
<code class="sig-name descname">scan</code><span class="sig-paren">(</span><em class="sig-param">search_path=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Environment.scan"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.Environment.scan" title="Permalink to this definition">¶</a></dt>
<dd><p>Scan <cite>search_path</cite> for distributions usable in this environment</p>
<p>Any distributions found are added to the environment.
<cite>search_path</cite> should be a sequence of <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> items.  If not
supplied, <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> is used.  Only distributions conforming to
the platform/python version defined at initialization are added.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="nmodl.dsl.ExtractionError">
<em class="property">exception </em><code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">ExtractionError</code><a class="reference internal" href="_modules/pkg_resources.html#ExtractionError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.ExtractionError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">RuntimeError</span></code></p>
<p>An error occurred extracting a resource</p>
<p>The following attributes are available from instances of this exception:</p>
<dl class="simple">
<dt>manager</dt><dd><p>The resource manager that raised this exception</p>
</dd>
<dt>cache_path</dt><dd><p>The base directory for resource extraction</p>
</dd>
<dt>original_error</dt><dd><p>The exception instance that caused extraction to fail</p>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="nmodl.dsl.FileMetadata">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">FileMetadata</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#FileMetadata"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.FileMetadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pkg_resources.EmptyProvider</span></code></p>
<p>Metadata handler for standalone PKG-INFO files</p>
<p>Usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">metadata</span> <span class="o">=</span> <span class="n">FileMetadata</span><span class="p">(</span><span class="s2">&quot;/path/to/PKG-INFO&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>This provider rejects all data and metadata requests except for PKG-INFO,
which is treated as existing, and will be the contents of the file at
the provided location.</p>
<dl class="method">
<dt id="nmodl.dsl.FileMetadata.get_metadata">
<code class="sig-name descname">get_metadata</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#FileMetadata.get_metadata"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.FileMetadata.get_metadata" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.FileMetadata.get_metadata_lines">
<code class="sig-name descname">get_metadata_lines</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#FileMetadata.get_metadata_lines"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.FileMetadata.get_metadata_lines" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.FileMetadata.has_metadata">
<code class="sig-name descname">has_metadata</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#FileMetadata.has_metadata"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.FileMetadata.has_metadata" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.dsl.IMetadataProvider">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">IMetadataProvider</code><a class="reference internal" href="_modules/pkg_resources.html#IMetadataProvider"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.IMetadataProvider" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="nmodl.dsl.IMetadataProvider.get_metadata">
<code class="sig-name descname">get_metadata</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#IMetadataProvider.get_metadata"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.IMetadataProvider.get_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>The named metadata resource as a string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.IMetadataProvider.get_metadata_lines">
<code class="sig-name descname">get_metadata_lines</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#IMetadataProvider.get_metadata_lines"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.IMetadataProvider.get_metadata_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield named metadata resource as list of non-blank non-comment lines</p>
<p>Leading and trailing whitespace is stripped from each line, and lines
with <code class="docutils literal notranslate"><span class="pre">#</span></code> as the first non-blank character are omitted.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.IMetadataProvider.has_metadata">
<code class="sig-name descname">has_metadata</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#IMetadataProvider.has_metadata"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.IMetadataProvider.has_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Does the package’s distribution contain the named metadata?</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.IMetadataProvider.metadata_isdir">
<code class="sig-name descname">metadata_isdir</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#IMetadataProvider.metadata_isdir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.IMetadataProvider.metadata_isdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the named metadata a directory?  (like <code class="docutils literal notranslate"><span class="pre">os.path.isdir()</span></code>)</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.IMetadataProvider.metadata_listdir">
<code class="sig-name descname">metadata_listdir</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#IMetadataProvider.metadata_listdir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.IMetadataProvider.metadata_listdir" title="Permalink to this definition">¶</a></dt>
<dd><p>List of metadata names in the directory (like <code class="docutils literal notranslate"><span class="pre">os.listdir()</span></code>)</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.IMetadataProvider.run_script">
<code class="sig-name descname">run_script</code><span class="sig-paren">(</span><em class="sig-param">namespace</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#IMetadataProvider.run_script"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.IMetadataProvider.run_script" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute the named script in the supplied namespace dictionary</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.dsl.IResourceProvider">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">IResourceProvider</code><a class="reference internal" href="_modules/pkg_resources.html#IResourceProvider"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.IResourceProvider" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pkg_resources.IMetadataProvider</span></code></p>
<p>An object that provides access to package resources</p>
<dl class="method">
<dt id="nmodl.dsl.IResourceProvider.get_resource_filename">
<code class="sig-name descname">get_resource_filename</code><span class="sig-paren">(</span><em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#IResourceProvider.get_resource_filename"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.IResourceProvider.get_resource_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a true filesystem path for <cite>resource_name</cite></p>
<p><cite>manager</cite> must be an <code class="docutils literal notranslate"><span class="pre">IResourceManager</span></code></p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.IResourceProvider.get_resource_stream">
<code class="sig-name descname">get_resource_stream</code><span class="sig-paren">(</span><em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#IResourceProvider.get_resource_stream"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.IResourceProvider.get_resource_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a readable file-like object for <cite>resource_name</cite></p>
<p><cite>manager</cite> must be an <code class="docutils literal notranslate"><span class="pre">IResourceManager</span></code></p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.IResourceProvider.get_resource_string">
<code class="sig-name descname">get_resource_string</code><span class="sig-paren">(</span><em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#IResourceProvider.get_resource_string"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.IResourceProvider.get_resource_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string containing the contents of <cite>resource_name</cite></p>
<p><cite>manager</cite> must be an <code class="docutils literal notranslate"><span class="pre">IResourceManager</span></code></p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.IResourceProvider.has_resource">
<code class="sig-name descname">has_resource</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#IResourceProvider.has_resource"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.IResourceProvider.has_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>Does the package contain the named resource?</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.IResourceProvider.resource_isdir">
<code class="sig-name descname">resource_isdir</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#IResourceProvider.resource_isdir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.IResourceProvider.resource_isdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the named resource a directory?  (like <code class="docutils literal notranslate"><span class="pre">os.path.isdir()</span></code>)</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.IResourceProvider.resource_listdir">
<code class="sig-name descname">resource_listdir</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#IResourceProvider.resource_listdir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.IResourceProvider.resource_listdir" title="Permalink to this definition">¶</a></dt>
<dd><p>List of resource names in the directory (like <code class="docutils literal notranslate"><span class="pre">os.listdir()</span></code>)</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.dsl.NmodlDriver">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">NmodlDriver</code><a class="headerlink" href="#nmodl.dsl.NmodlDriver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_builtins.pybind11_object</span></code></p>
<p>This is the NmodlDriver class documentation</p>
<dl class="method">
<dt id="nmodl.dsl.NmodlDriver.get_ast">
<code class="sig-name descname">get_ast</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.NmodlDriver</em><span class="sig-paren">)</span> &#x2192; nmodl::ast::Program<a class="headerlink" href="#nmodl.dsl.NmodlDriver.get_ast" title="Permalink to this definition">¶</a></dt>
<dd><p>Get ast</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Program</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.NmodlDriver.parse_file">
<code class="sig-name descname">parse_file</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.NmodlDriver</em>, <em class="sig-param">filename: str</em><span class="sig-paren">)</span> &#x2192; nmodl::ast::Program<a class="headerlink" href="#nmodl.dsl.NmodlDriver.parse_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse NMODL provided as a file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>filename</strong> (<em>str</em>) – name of the C file</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>ast root node if success, throws an exception otherwise</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>AST</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.NmodlDriver.parse_stream">
<code class="sig-name descname">parse_stream</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.NmodlDriver</em>, <em class="sig-param">in: object</em><span class="sig-paren">)</span> &#x2192; nmodl::ast::Program<a class="headerlink" href="#nmodl.dsl.NmodlDriver.parse_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse NMODL file provided as istream</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>in</strong> (<em>file</em>) – ifstream object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>ast root node if success, throws an exception otherwise</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>AST</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.NmodlDriver.parse_string">
<code class="sig-name descname">parse_string</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.NmodlDriver</em>, <em class="sig-param">input: str</em><span class="sig-paren">)</span> &#x2192; nmodl::ast::Program<a class="headerlink" href="#nmodl.dsl.NmodlDriver.parse_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse NMODL provided as a string</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>input</strong> (<em>str</em>) – C code as string</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>ast root node if success, throws an exception otherwise</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>AST</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ast</span> <span class="o">=</span> <span class="n">driver</span><span class="o">.</span><span class="n">parse_string</span><span class="p">(</span><span class="s2">&quot;DEFINE NSTEP 6&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.dsl.NullProvider">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">NullProvider</code><span class="sig-paren">(</span><em class="sig-param">module</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#NullProvider"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.NullProvider" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Try to implement resources and metadata for arbitrary PEP 302 loaders</p>
<dl class="attribute">
<dt id="nmodl.dsl.NullProvider.egg_info">
<code class="sig-name descname">egg_info</code><em class="property"> = None</em><a class="headerlink" href="#nmodl.dsl.NullProvider.egg_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.dsl.NullProvider.egg_name">
<code class="sig-name descname">egg_name</code><em class="property"> = None</em><a class="headerlink" href="#nmodl.dsl.NullProvider.egg_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.NullProvider.get_metadata">
<code class="sig-name descname">get_metadata</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#NullProvider.get_metadata"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.NullProvider.get_metadata" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.NullProvider.get_metadata_lines">
<code class="sig-name descname">get_metadata_lines</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#NullProvider.get_metadata_lines"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.NullProvider.get_metadata_lines" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.NullProvider.get_resource_filename">
<code class="sig-name descname">get_resource_filename</code><span class="sig-paren">(</span><em class="sig-param">manager</em>, <em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#NullProvider.get_resource_filename"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.NullProvider.get_resource_filename" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.NullProvider.get_resource_stream">
<code class="sig-name descname">get_resource_stream</code><span class="sig-paren">(</span><em class="sig-param">manager</em>, <em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#NullProvider.get_resource_stream"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.NullProvider.get_resource_stream" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.NullProvider.get_resource_string">
<code class="sig-name descname">get_resource_string</code><span class="sig-paren">(</span><em class="sig-param">manager</em>, <em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#NullProvider.get_resource_string"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.NullProvider.get_resource_string" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.NullProvider.has_metadata">
<code class="sig-name descname">has_metadata</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#NullProvider.has_metadata"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.NullProvider.has_metadata" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.NullProvider.has_resource">
<code class="sig-name descname">has_resource</code><span class="sig-paren">(</span><em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#NullProvider.has_resource"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.NullProvider.has_resource" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.dsl.NullProvider.loader">
<code class="sig-name descname">loader</code><em class="property"> = None</em><a class="headerlink" href="#nmodl.dsl.NullProvider.loader" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.NullProvider.metadata_isdir">
<code class="sig-name descname">metadata_isdir</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#NullProvider.metadata_isdir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.NullProvider.metadata_isdir" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.NullProvider.metadata_listdir">
<code class="sig-name descname">metadata_listdir</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#NullProvider.metadata_listdir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.NullProvider.metadata_listdir" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.NullProvider.resource_isdir">
<code class="sig-name descname">resource_isdir</code><span class="sig-paren">(</span><em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#NullProvider.resource_isdir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.NullProvider.resource_isdir" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.NullProvider.resource_listdir">
<code class="sig-name descname">resource_listdir</code><span class="sig-paren">(</span><em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#NullProvider.resource_listdir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.NullProvider.resource_listdir" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.NullProvider.run_script">
<code class="sig-name descname">run_script</code><span class="sig-paren">(</span><em class="sig-param">script_name</em>, <em class="sig-param">namespace</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#NullProvider.run_script"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.NullProvider.run_script" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="nmodl.dsl.PEP440Warning">
<em class="property">exception </em><code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">PEP440Warning</code><a class="reference internal" href="_modules/pkg_resources.html#PEP440Warning"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.PEP440Warning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">RuntimeWarning</span></code></p>
<p>Used when there is an issue with a version or specifier not complying with
PEP 440.</p>
</dd></dl>

<dl class="class">
<dt id="nmodl.dsl.PathMetadata">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">PathMetadata</code><span class="sig-paren">(</span><em class="sig-param">path</em>, <em class="sig-param">egg_info</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#PathMetadata"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.PathMetadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pkg_resources.DefaultProvider</span></code></p>
<p>Metadata provider for egg directories</p>
<p>Usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Development eggs:</span>

<span class="n">egg_info</span> <span class="o">=</span> <span class="s2">&quot;/path/to/PackageName.egg-info&quot;</span>
<span class="n">base_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">egg_info</span><span class="p">)</span>
<span class="n">metadata</span> <span class="o">=</span> <span class="n">PathMetadata</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">egg_info</span><span class="p">)</span>
<span class="n">dist_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">egg_info</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">dist</span> <span class="o">=</span> <span class="n">Distribution</span><span class="p">(</span><span class="n">basedir</span><span class="p">,</span> <span class="n">project_name</span><span class="o">=</span><span class="n">dist_name</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span>

<span class="c1"># Unpacked egg directories:</span>

<span class="n">egg_path</span> <span class="o">=</span> <span class="s2">&quot;/path/to/PackageName-ver-pyver-etc.egg&quot;</span>
<span class="n">metadata</span> <span class="o">=</span> <span class="n">PathMetadata</span><span class="p">(</span><span class="n">egg_path</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">egg_path</span><span class="p">,</span><span class="s1">&#39;EGG-INFO&#39;</span><span class="p">))</span>
<span class="n">dist</span> <span class="o">=</span> <span class="n">Distribution</span><span class="o">.</span><span class="n">from_filename</span><span class="p">(</span><span class="n">egg_path</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="exception">
<dt id="nmodl.dsl.PkgResourcesDeprecationWarning">
<em class="property">exception </em><code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">PkgResourcesDeprecationWarning</code><a class="reference internal" href="_modules/pkg_resources.html#PkgResourcesDeprecationWarning"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.PkgResourcesDeprecationWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Warning</span></code></p>
<p>Base class for warning about deprecations in <code class="docutils literal notranslate"><span class="pre">pkg_resources</span></code></p>
<p>This class is not derived from <code class="docutils literal notranslate"><span class="pre">DeprecationWarning</span></code>, and as such is
visible by default.</p>
</dd></dl>

<dl class="class">
<dt id="nmodl.dsl.Requirement">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">Requirement</code><span class="sig-paren">(</span><em class="sig-param">requirement_string</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Requirement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.Requirement" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pkg_resources.extern.packaging.requirements.Requirement</span></code></p>
<dl class="method">
<dt id="nmodl.dsl.Requirement.parse">
<em class="property">static </em><code class="sig-name descname">parse</code><span class="sig-paren">(</span><em class="sig-param">s</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#Requirement.parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.Requirement.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="nmodl.dsl.ResolutionError">
<em class="property">exception </em><code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">ResolutionError</code><a class="reference internal" href="_modules/pkg_resources.html#ResolutionError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.ResolutionError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
<p>Abstract base for dependency resolution errors</p>
</dd></dl>

<dl class="class">
<dt id="nmodl.dsl.ResourceManager">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">ResourceManager</code><a class="reference internal" href="_modules/pkg_resources.html#ResourceManager"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.ResourceManager" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Manage resource extraction and packages</p>
<dl class="method">
<dt id="nmodl.dsl.ResourceManager.cleanup_resources">
<code class="sig-name descname">cleanup_resources</code><span class="sig-paren">(</span><em class="sig-param">force=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#ResourceManager.cleanup_resources"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.ResourceManager.cleanup_resources" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete all extracted resource files and directories, returning a list
of the file and directory names that could not be successfully removed.
This function does not have any concurrency protection, so it should
generally only be called when the extraction path is a temporary
directory exclusive to a single process.  This method is not
automatically called; you must call it explicitly or register it as an
<code class="docutils literal notranslate"><span class="pre">atexit</span></code> function if you wish to ensure cleanup of a temporary
directory used for extractions.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.ResourceManager.extraction_error">
<code class="sig-name descname">extraction_error</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#ResourceManager.extraction_error"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.ResourceManager.extraction_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Give an error message for problems extracting file(s)</p>
</dd></dl>

<dl class="attribute">
<dt id="nmodl.dsl.ResourceManager.extraction_path">
<code class="sig-name descname">extraction_path</code><em class="property"> = None</em><a class="headerlink" href="#nmodl.dsl.ResourceManager.extraction_path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.ResourceManager.get_cache_path">
<code class="sig-name descname">get_cache_path</code><span class="sig-paren">(</span><em class="sig-param">archive_name</em>, <em class="sig-param">names=()</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#ResourceManager.get_cache_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.ResourceManager.get_cache_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return absolute location in cache for <cite>archive_name</cite> and <cite>names</cite></p>
<p>The parent directory of the resulting path will be created if it does
not already exist.  <cite>archive_name</cite> should be the base filename of the
enclosing egg (which may not be the name of the enclosing zipfile!),
including its “.egg” extension.  <cite>names</cite>, if provided, should be a
sequence of path name parts “under” the egg’s extraction location.</p>
<p>This method should only be called by resource providers that need to
obtain an extraction location, and only for names they intend to
extract, as it tracks the generated names for possible cleanup later.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.ResourceManager.postprocess">
<code class="sig-name descname">postprocess</code><span class="sig-paren">(</span><em class="sig-param">tempname</em>, <em class="sig-param">filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#ResourceManager.postprocess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.ResourceManager.postprocess" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform any platform-specific postprocessing of <cite>tempname</cite></p>
<p>This is where Mac header rewrites should be done; other platforms don’t
have anything special they should do.</p>
<p>Resource providers should call this method ONLY after successfully
extracting a compressed resource.  They must NOT call it on resources
that are already in the filesystem.</p>
<p><cite>tempname</cite> is the current (temporary) name of the file, and <cite>filename</cite>
is the name it will be renamed to by the caller after this routine
returns.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.ResourceManager.resource_exists">
<code class="sig-name descname">resource_exists</code><span class="sig-paren">(</span><em class="sig-param">package_or_requirement</em>, <em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#ResourceManager.resource_exists"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.ResourceManager.resource_exists" title="Permalink to this definition">¶</a></dt>
<dd><p>Does the named resource exist?</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.ResourceManager.resource_filename">
<code class="sig-name descname">resource_filename</code><span class="sig-paren">(</span><em class="sig-param">package_or_requirement</em>, <em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#ResourceManager.resource_filename"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.ResourceManager.resource_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a true filesystem path for specified resource</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.ResourceManager.resource_isdir">
<code class="sig-name descname">resource_isdir</code><span class="sig-paren">(</span><em class="sig-param">package_or_requirement</em>, <em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#ResourceManager.resource_isdir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.ResourceManager.resource_isdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the named resource an existing directory?</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.ResourceManager.resource_listdir">
<code class="sig-name descname">resource_listdir</code><span class="sig-paren">(</span><em class="sig-param">package_or_requirement</em>, <em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#ResourceManager.resource_listdir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.ResourceManager.resource_listdir" title="Permalink to this definition">¶</a></dt>
<dd><p>List the contents of the named resource directory</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.ResourceManager.resource_stream">
<code class="sig-name descname">resource_stream</code><span class="sig-paren">(</span><em class="sig-param">package_or_requirement</em>, <em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#ResourceManager.resource_stream"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.ResourceManager.resource_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a readable file-like object for specified resource</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.ResourceManager.resource_string">
<code class="sig-name descname">resource_string</code><span class="sig-paren">(</span><em class="sig-param">package_or_requirement</em>, <em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#ResourceManager.resource_string"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.ResourceManager.resource_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Return specified resource as a string</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.ResourceManager.set_extraction_path">
<code class="sig-name descname">set_extraction_path</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#ResourceManager.set_extraction_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.ResourceManager.set_extraction_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the base path where resources will be extracted to, if needed.</p>
<p>If you do not call this routine before any extractions take place, the
path defaults to the return value of <code class="docutils literal notranslate"><span class="pre">get_default_cache()</span></code>.  (Which
is based on the <code class="docutils literal notranslate"><span class="pre">PYTHON_EGG_CACHE</span></code> environment variable, with various
platform-specific fallbacks.  See that routine’s documentation for more
details.)</p>
<p>Resources are extracted to subdirectories of this path based upon
information given by the <code class="docutils literal notranslate"><span class="pre">IResourceProvider</span></code>.  You may set this to a
temporary directory, but then you must call <code class="docutils literal notranslate"><span class="pre">cleanup_resources()</span></code> to
delete the extracted files when done.  There is no guarantee that
<code class="docutils literal notranslate"><span class="pre">cleanup_resources()</span></code> will be able to remove all extracted files.</p>
<p>(Note: you may not change the extraction path for a given resource
manager once resources have been extracted, unless you first call
<code class="docutils literal notranslate"><span class="pre">cleanup_resources()</span></code>.)</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="nmodl.dsl.UnknownExtra">
<em class="property">exception </em><code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">UnknownExtra</code><a class="reference internal" href="_modules/pkg_resources.html#UnknownExtra"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.UnknownExtra" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pkg_resources.ResolutionError</span></code></p>
<p>Distribution doesn’t have an “extra feature” of the given name</p>
</dd></dl>

<dl class="exception">
<dt id="nmodl.dsl.VersionConflict">
<em class="property">exception </em><code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">VersionConflict</code><a class="reference internal" href="_modules/pkg_resources.html#VersionConflict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.VersionConflict" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pkg_resources.ResolutionError</span></code></p>
<p>An already-installed version conflicts with the requested version.</p>
<p>Should be initialized with the installed Distribution and the requested
Requirement.</p>
<dl class="method">
<dt id="nmodl.dsl.VersionConflict.dist">
<em class="property">property </em><code class="sig-name descname">dist</code><a class="headerlink" href="#nmodl.dsl.VersionConflict.dist" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.VersionConflict.report">
<code class="sig-name descname">report</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#VersionConflict.report"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.VersionConflict.report" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.VersionConflict.req">
<em class="property">property </em><code class="sig-name descname">req</code><a class="headerlink" href="#nmodl.dsl.VersionConflict.req" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.VersionConflict.with_context">
<code class="sig-name descname">with_context</code><span class="sig-paren">(</span><em class="sig-param">required_by</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#VersionConflict.with_context"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.VersionConflict.with_context" title="Permalink to this definition">¶</a></dt>
<dd><p>If required_by is non-empty, return a version of self that is a
ContextualVersionConflict.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.dsl.WorkingSet">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">WorkingSet</code><span class="sig-paren">(</span><em class="sig-param">entries=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#WorkingSet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.WorkingSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A collection of active distributions on sys.path (or a similar list)</p>
<dl class="method">
<dt id="nmodl.dsl.WorkingSet.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param">dist</em>, <em class="sig-param">entry=None</em>, <em class="sig-param">insert=True</em>, <em class="sig-param">replace=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#WorkingSet.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.WorkingSet.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add <cite>dist</cite> to working set, associated with <cite>entry</cite></p>
<p>If <cite>entry</cite> is unspecified, it defaults to the <code class="docutils literal notranslate"><span class="pre">.location</span></code> of <cite>dist</cite>.
On exit from this routine, <cite>entry</cite> is added to the end of the working
set’s <code class="docutils literal notranslate"><span class="pre">.entries</span></code> (if it wasn’t already present).</p>
<p><cite>dist</cite> is only added to the working set if it’s for a project that
doesn’t already have a distribution in the set, unless <cite>replace=True</cite>.
If it’s added, any callbacks registered with the <code class="docutils literal notranslate"><span class="pre">subscribe()</span></code> method
will be called.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.WorkingSet.add_entry">
<code class="sig-name descname">add_entry</code><span class="sig-paren">(</span><em class="sig-param">entry</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#WorkingSet.add_entry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.WorkingSet.add_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a path item to <code class="docutils literal notranslate"><span class="pre">.entries</span></code>, finding any distributions on it</p>
<p><code class="docutils literal notranslate"><span class="pre">find_distributions(entry,</span> <span class="pre">True)</span></code> is used to find distributions
corresponding to the path entry, and they are added.  <cite>entry</cite> is
always appended to <code class="docutils literal notranslate"><span class="pre">.entries</span></code>, even if it is already present.
(This is because <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> can contain the same value more than
once, and the <code class="docutils literal notranslate"><span class="pre">.entries</span></code> of the <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> WorkingSet should always
equal <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>.)</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.WorkingSet.find">
<code class="sig-name descname">find</code><span class="sig-paren">(</span><em class="sig-param">req</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#WorkingSet.find"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.WorkingSet.find" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a distribution matching requirement <cite>req</cite></p>
<p>If there is an active distribution for the requested project, this
returns it as long as it meets the version requirement specified by
<cite>req</cite>.  But, if there is an active distribution for the project and it
does <em>not</em> meet the <cite>req</cite> requirement, <code class="docutils literal notranslate"><span class="pre">VersionConflict</span></code> is raised.
If there is no active distribution for the requested project, <code class="docutils literal notranslate"><span class="pre">None</span></code>
is returned.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.WorkingSet.find_plugins">
<code class="sig-name descname">find_plugins</code><span class="sig-paren">(</span><em class="sig-param">plugin_env</em>, <em class="sig-param">full_env=None</em>, <em class="sig-param">installer=None</em>, <em class="sig-param">fallback=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#WorkingSet.find_plugins"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.WorkingSet.find_plugins" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all activatable distributions in <cite>plugin_env</cite></p>
<p>Example usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">distributions</span><span class="p">,</span> <span class="n">errors</span> <span class="o">=</span> <span class="n">working_set</span><span class="o">.</span><span class="n">find_plugins</span><span class="p">(</span>
    <span class="n">Environment</span><span class="p">(</span><span class="n">plugin_dirlist</span><span class="p">)</span>
<span class="p">)</span>
<span class="c1"># add plugins+libs to sys.path</span>
<span class="nb">map</span><span class="p">(</span><span class="n">working_set</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="n">distributions</span><span class="p">)</span>
<span class="c1"># display errors</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Could not load&#39;</span><span class="p">,</span> <span class="n">errors</span><span class="p">)</span>
</pre></div>
</div>
<p>The <cite>plugin_env</cite> should be an <code class="docutils literal notranslate"><span class="pre">Environment</span></code> instance that contains
only distributions that are in the project’s “plugin directory” or
directories. The <cite>full_env</cite>, if supplied, should be an <code class="docutils literal notranslate"><span class="pre">Environment</span></code>
contains all currently-available distributions.  If <cite>full_env</cite> is not
supplied, one is created automatically from the <code class="docutils literal notranslate"><span class="pre">WorkingSet</span></code> this
method is called on, which will typically mean that every directory on
<code class="docutils literal notranslate"><span class="pre">sys.path</span></code> will be scanned for distributions.</p>
<p><cite>installer</cite> is a standard installer callback as used by the
<code class="docutils literal notranslate"><span class="pre">resolve()</span></code> method. The <cite>fallback</cite> flag indicates whether we should
attempt to resolve older versions of a plugin if the newest version
cannot be resolved.</p>
<p>This method returns a 2-tuple: (<cite>distributions</cite>, <cite>error_info</cite>), where
<cite>distributions</cite> is a list of the distributions found in <cite>plugin_env</cite>
that were loadable, along with any other distributions that are needed
to resolve their dependencies.  <cite>error_info</cite> is a dictionary mapping
unloadable plugin distributions to an exception instance describing the
error that occurred. Usually this will be a <code class="docutils literal notranslate"><span class="pre">DistributionNotFound</span></code> or
<code class="docutils literal notranslate"><span class="pre">VersionConflict</span></code> instance.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.WorkingSet.iter_entry_points">
<code class="sig-name descname">iter_entry_points</code><span class="sig-paren">(</span><em class="sig-param">group</em>, <em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#WorkingSet.iter_entry_points"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.WorkingSet.iter_entry_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield entry point objects from <cite>group</cite> matching <cite>name</cite></p>
<p>If <cite>name</cite> is None, yields all entry points in <cite>group</cite> from all
distributions in the working set, otherwise only ones matching
both <cite>group</cite> and <cite>name</cite> are yielded (in distribution order).</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.WorkingSet.require">
<code class="sig-name descname">require</code><span class="sig-paren">(</span><em class="sig-param">*requirements</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#WorkingSet.require"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.WorkingSet.require" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure that distributions matching <cite>requirements</cite> are activated</p>
<p><cite>requirements</cite> must be a string or a (possibly-nested) sequence
thereof, specifying the distributions and versions required.  The
return value is a sequence of the distributions that needed to be
activated to fulfill the requirements; all relevant distributions are
included, even if they were already activated in this working set.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.WorkingSet.resolve">
<code class="sig-name descname">resolve</code><span class="sig-paren">(</span><em class="sig-param">requirements</em>, <em class="sig-param">env=None</em>, <em class="sig-param">installer=None</em>, <em class="sig-param">replace_conflicting=False</em>, <em class="sig-param">extras=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#WorkingSet.resolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.WorkingSet.resolve" title="Permalink to this definition">¶</a></dt>
<dd><p>List all distributions needed to (recursively) meet <cite>requirements</cite></p>
<p><cite>requirements</cite> must be a sequence of <code class="docutils literal notranslate"><span class="pre">Requirement</span></code> objects.  <cite>env</cite>,
if supplied, should be an <code class="docutils literal notranslate"><span class="pre">Environment</span></code> instance.  If
not supplied, it defaults to all distributions available within any
entry or distribution in the working set.  <cite>installer</cite>, if supplied,
will be invoked with each requirement that cannot be met by an
already-installed distribution; it should return a <code class="docutils literal notranslate"><span class="pre">Distribution</span></code> or
<code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Unless <cite>replace_conflicting=True</cite>, raises a VersionConflict exception
if
any requirements are found on the path that have the correct name but
the wrong version.  Otherwise, if an <cite>installer</cite> is supplied it will be
invoked to obtain the correct version of the requirement and activate
it.</p>
<p><cite>extras</cite> is a list of the extras to be used with these requirements.
This is important because extra requirements may look like <cite>my_req;
extra = “my_extra”</cite>, which would otherwise be interpreted as a purely
optional requirement.  Instead, we want to be able to assert that these
requirements are truly required.</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.WorkingSet.run_script">
<code class="sig-name descname">run_script</code><span class="sig-paren">(</span><em class="sig-param">requires</em>, <em class="sig-param">script_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#WorkingSet.run_script"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.WorkingSet.run_script" title="Permalink to this definition">¶</a></dt>
<dd><p>Locate distribution for <cite>requires</cite> and run <cite>script_name</cite> script</p>
</dd></dl>

<dl class="method">
<dt id="nmodl.dsl.WorkingSet.subscribe">
<code class="sig-name descname">subscribe</code><span class="sig-paren">(</span><em class="sig-param">callback</em>, <em class="sig-param">existing=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#WorkingSet.subscribe"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.WorkingSet.subscribe" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke <cite>callback</cite> for all distributions</p>
<p>If <cite>existing=True</cite> (default),
call on all existing ones, as well.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.dsl.ZipProvider">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">ZipProvider</code><span class="sig-paren">(</span><em class="sig-param">module</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#ZipProvider"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.ZipProvider" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pkg_resources.EggProvider</span></code></p>
<p>Resource support for zips and eggs</p>
<dl class="attribute">
<dt id="nmodl.dsl.ZipProvider.eagers">
<code class="sig-name descname">eagers</code><em class="property"> = None</em><a class="headerlink" href="#nmodl.dsl.ZipProvider.eagers" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.ZipProvider.get_resource_filename">
<code class="sig-name descname">get_resource_filename</code><span class="sig-paren">(</span><em class="sig-param">manager</em>, <em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#ZipProvider.get_resource_filename"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.ZipProvider.get_resource_filename" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.dsl.ZipProvider.zipinfo">
<em class="property">property </em><code class="sig-name descname">zipinfo</code><a class="headerlink" href="#nmodl.dsl.ZipProvider.zipinfo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.add_activation_listener">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">add_activation_listener</code><span class="sig-paren">(</span><em class="sig-param">callback</em>, <em class="sig-param">existing=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.dsl.add_activation_listener" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke <cite>callback</cite> for all distributions</p>
<p>If <cite>existing=True</cite> (default),
call on all existing ones, as well.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.cleanup_resources">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">cleanup_resources</code><span class="sig-paren">(</span><em class="sig-param">force=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.dsl.cleanup_resources" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete all extracted resource files and directories, returning a list
of the file and directory names that could not be successfully removed.
This function does not have any concurrency protection, so it should
generally only be called when the extraction path is a temporary
directory exclusive to a single process.  This method is not
automatically called; you must call it explicitly or register it as an
<code class="docutils literal notranslate"><span class="pre">atexit</span></code> function if you wish to ensure cleanup of a temporary
directory used for extractions.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.compatible_platforms">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">compatible_platforms</code><span class="sig-paren">(</span><em class="sig-param">provided</em>, <em class="sig-param">required</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#compatible_platforms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.compatible_platforms" title="Permalink to this definition">¶</a></dt>
<dd><p>Can code for the <cite>provided</cite> platform run on the <cite>required</cite> platform?</p>
<p>Returns true if either platform is <code class="docutils literal notranslate"><span class="pre">None</span></code>, or the platforms are equal.</p>
<p>XXX Needs compatibility checks for Linux and other unixy OSes.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.declare_namespace">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">declare_namespace</code><span class="sig-paren">(</span><em class="sig-param">packageName</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#declare_namespace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.declare_namespace" title="Permalink to this definition">¶</a></dt>
<dd><p>Declare that package ‘packageName’ is a namespace package</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.ensure_directory">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">ensure_directory</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#ensure_directory"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.ensure_directory" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure that the parent directory of <cite>path</cite> exists</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.evaluate_marker">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">evaluate_marker</code><span class="sig-paren">(</span><em class="sig-param">text</em>, <em class="sig-param">extra=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#evaluate_marker"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.evaluate_marker" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a PEP 508 environment marker.
Return a boolean indicating the marker result in this environment.
Raise SyntaxError if marker is invalid.</p>
<p>This implementation uses the ‘pyparsing’ module.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.find_distributions">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">find_distributions</code><span class="sig-paren">(</span><em class="sig-param">path_item</em>, <em class="sig-param">only=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#find_distributions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.find_distributions" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield distributions accessible via <cite>path_item</cite></p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.fixup_namespace_packages">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">fixup_namespace_packages</code><span class="sig-paren">(</span><em class="sig-param">path_item</em>, <em class="sig-param">parent=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#fixup_namespace_packages"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.fixup_namespace_packages" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure that previously-declared namespace packages include path_item</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.get_default_cache">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">get_default_cache</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#get_default_cache"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.get_default_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <code class="docutils literal notranslate"><span class="pre">PYTHON_EGG_CACHE</span></code> environment variable
or a platform-relevant user cache dir for an app
named “Python-Eggs”.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.get_distribution">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">get_distribution</code><span class="sig-paren">(</span><em class="sig-param">dist</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#get_distribution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.get_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a current distribution object for a Requirement or string</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.get_entry_info">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">get_entry_info</code><span class="sig-paren">(</span><em class="sig-param">dist</em>, <em class="sig-param">group</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#get_entry_info"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.get_entry_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the EntryPoint object for <cite>group`+`name</cite>, or <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.get_entry_map">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">get_entry_map</code><span class="sig-paren">(</span><em class="sig-param">dist</em>, <em class="sig-param">group=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#get_entry_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.get_entry_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the entry point map for <cite>group</cite>, or the full entry map</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.get_importer">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">get_importer</code><span class="sig-paren">(</span><em class="sig-param">path_item</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkgutil.html#get_importer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.get_importer" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a finder for the given path item</p>
<p>The returned finder is cached in sys.path_importer_cache
if it was newly created by a path hook.</p>
<p>The cache (or part of it) can be cleared manually if a
rescan of sys.path_hooks is necessary.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.get_platform">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">get_platform</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.dsl.get_platform" title="Permalink to this definition">¶</a></dt>
<dd><p>Return this platform’s string for platform-specific distributions</p>
<p>XXX Currently this is the same as <code class="docutils literal notranslate"><span class="pre">distutils.util.get_platform()</span></code>, but it
needs some hacks for Linux and macOS.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.get_provider">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">get_provider</code><span class="sig-paren">(</span><em class="sig-param">moduleOrReq</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#get_provider"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.get_provider" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an IResourceProvider for the named module or requirement</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.invalid_marker">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">invalid_marker</code><span class="sig-paren">(</span><em class="sig-param">text</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#invalid_marker"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.invalid_marker" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate text as a PEP 508 environment marker; return an exception
if invalid or False otherwise.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.iter_entry_points">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">iter_entry_points</code><span class="sig-paren">(</span><em class="sig-param">group</em>, <em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.dsl.iter_entry_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield entry point objects from <cite>group</cite> matching <cite>name</cite></p>
<p>If <cite>name</cite> is None, yields all entry points in <cite>group</cite> from all
distributions in the working set, otherwise only ones matching
both <cite>group</cite> and <cite>name</cite> are yielded (in distribution order).</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.list_examples">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">list_examples</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmodl/dsl.html#list_examples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.list_examples" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of examples available</p>
<p>The NMODL Framework provides a few examples for testing</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>List of available examples</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.load_entry_point">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">load_entry_point</code><span class="sig-paren">(</span><em class="sig-param">dist</em>, <em class="sig-param">group</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#load_entry_point"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.load_entry_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <cite>name</cite> entry point of <cite>group</cite> for <cite>dist</cite> or raise ImportError</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.load_example">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">load_example</code><span class="sig-paren">(</span><em class="sig-param">example</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmodl/dsl.html#load_example"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.load_example" title="Permalink to this definition">¶</a></dt>
<dd><p>Load an example from the NMODL examples</p>
<p>The NMODL Framework provides a few examples for testing. The list of examples can be requested
using <cite>list_examples()</cite>. This function then returns the NMODL code of the requested example
file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>example</strong> – Filename of an example as provided by <cite>list_examples()</cite></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>List of available examples</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.normalize_path">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">normalize_path</code><span class="sig-paren">(</span><em class="sig-param">filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#normalize_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.normalize_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize a file/dir name for comparison purposes</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.parse_requirements">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">parse_requirements</code><span class="sig-paren">(</span><em class="sig-param">strs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#parse_requirements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.parse_requirements" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield <code class="docutils literal notranslate"><span class="pre">Requirement</span></code> objects for each specification in <cite>strs</cite></p>
<p><cite>strs</cite> must be a string, or a (possibly-nested) iterable thereof.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.parse_version">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">parse_version</code><span class="sig-paren">(</span><em class="sig-param">v</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#parse_version"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.parse_version" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nmodl.dsl.register_finder">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">register_finder</code><span class="sig-paren">(</span><em class="sig-param">importer_type</em>, <em class="sig-param">distribution_finder</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#register_finder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.register_finder" title="Permalink to this definition">¶</a></dt>
<dd><p>Register <cite>distribution_finder</cite> to find distributions in sys.path items</p>
<p><cite>importer_type</cite> is the type or class of a PEP 302 “Importer” (sys.path item
handler), and <cite>distribution_finder</cite> is a callable that, passed a path
item and the importer instance, yields <code class="docutils literal notranslate"><span class="pre">Distribution</span></code> instances found on
that path item.  See <code class="docutils literal notranslate"><span class="pre">pkg_resources.find_on_path</span></code> for an example.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.register_loader_type">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">register_loader_type</code><span class="sig-paren">(</span><em class="sig-param">loader_type</em>, <em class="sig-param">provider_factory</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#register_loader_type"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.register_loader_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Register <cite>provider_factory</cite> to make providers for <cite>loader_type</cite></p>
<p><cite>loader_type</cite> is the type or class of a PEP 302 <code class="docutils literal notranslate"><span class="pre">module.__loader__</span></code>,
and <cite>provider_factory</cite> is a function that, passed a <em>module</em> object,
returns an <code class="docutils literal notranslate"><span class="pre">IResourceProvider</span></code> for that module.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.register_namespace_handler">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">register_namespace_handler</code><span class="sig-paren">(</span><em class="sig-param">importer_type</em>, <em class="sig-param">namespace_handler</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#register_namespace_handler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.register_namespace_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>Register <cite>namespace_handler</cite> to declare namespace packages</p>
<p><cite>importer_type</cite> is the type or class of a PEP 302 “Importer” (sys.path item
handler), and <cite>namespace_handler</cite> is a callable like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">namespace_handler</span><span class="p">(</span><span class="n">importer</span><span class="p">,</span> <span class="n">path_entry</span><span class="p">,</span> <span class="n">moduleName</span><span class="p">,</span> <span class="n">module</span><span class="p">):</span>
    <span class="c1"># return a path_entry to use for child packages</span>
</pre></div>
</div>
<p>Namespace handlers are only called if the importer object has already
agreed that it can handle the relevant path item, and they should only
return a subpath if the module __path__ does not already contain an
equivalent subpath.  For an example namespace handler, see
<code class="docutils literal notranslate"><span class="pre">pkg_resources.file_ns_handler</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.require">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">require</code><span class="sig-paren">(</span><em class="sig-param">*requirements</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.dsl.require" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure that distributions matching <cite>requirements</cite> are activated</p>
<p><cite>requirements</cite> must be a string or a (possibly-nested) sequence
thereof, specifying the distributions and versions required.  The
return value is a sequence of the distributions that needed to be
activated to fulfill the requirements; all relevant distributions are
included, even if they were already activated in this working set.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.resource_exists">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">resource_exists</code><span class="sig-paren">(</span><em class="sig-param">package_or_requirement</em>, <em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.dsl.resource_exists" title="Permalink to this definition">¶</a></dt>
<dd><p>Does the named resource exist?</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.resource_filename">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">resource_filename</code><span class="sig-paren">(</span><em class="sig-param">package_or_requirement</em>, <em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.dsl.resource_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a true filesystem path for specified resource</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.resource_isdir">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">resource_isdir</code><span class="sig-paren">(</span><em class="sig-param">package_or_requirement</em>, <em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.dsl.resource_isdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the named resource an existing directory?</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.resource_listdir">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">resource_listdir</code><span class="sig-paren">(</span><em class="sig-param">package_or_requirement</em>, <em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.dsl.resource_listdir" title="Permalink to this definition">¶</a></dt>
<dd><p>List the contents of the named resource directory</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.resource_stream">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">resource_stream</code><span class="sig-paren">(</span><em class="sig-param">package_or_requirement</em>, <em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.dsl.resource_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a readable file-like object for specified resource</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.resource_string">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">resource_string</code><span class="sig-paren">(</span><em class="sig-param">package_or_requirement</em>, <em class="sig-param">resource_name</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.dsl.resource_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Return specified resource as a string</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.run_main">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">run_main</code><span class="sig-paren">(</span><em class="sig-param">requires</em>, <em class="sig-param">script_name</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.dsl.run_main" title="Permalink to this definition">¶</a></dt>
<dd><p>Locate distribution for <cite>requires</cite> and run <cite>script_name</cite> script</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.run_script">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">run_script</code><span class="sig-paren">(</span><em class="sig-param">requires</em>, <em class="sig-param">script_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#run_script"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.run_script" title="Permalink to this definition">¶</a></dt>
<dd><p>Locate distribution for <cite>requires</cite> and run <cite>script_name</cite> script</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.safe_extra">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">safe_extra</code><span class="sig-paren">(</span><em class="sig-param">extra</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#safe_extra"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.safe_extra" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an arbitrary string to a standard ‘extra’ name</p>
<p>Any runs of non-alphanumeric characters are replaced with a single ‘_’,
and the result is always lowercased.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.safe_name">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">safe_name</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#safe_name"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.safe_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an arbitrary string to a standard distribution name</p>
<p>Any runs of non-alphanumeric/. characters are replaced with a single ‘-‘.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.safe_version">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">safe_version</code><span class="sig-paren">(</span><em class="sig-param">version</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#safe_version"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.safe_version" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an arbitrary string to a standard version string</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.set_extraction_path">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">set_extraction_path</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.dsl.set_extraction_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the base path where resources will be extracted to, if needed.</p>
<p>If you do not call this routine before any extractions take place, the
path defaults to the return value of <code class="docutils literal notranslate"><span class="pre">get_default_cache()</span></code>.  (Which
is based on the <code class="docutils literal notranslate"><span class="pre">PYTHON_EGG_CACHE</span></code> environment variable, with various
platform-specific fallbacks.  See that routine’s documentation for more
details.)</p>
<p>Resources are extracted to subdirectories of this path based upon
information given by the <code class="docutils literal notranslate"><span class="pre">IResourceProvider</span></code>.  You may set this to a
temporary directory, but then you must call <code class="docutils literal notranslate"><span class="pre">cleanup_resources()</span></code> to
delete the extracted files when done.  There is no guarantee that
<code class="docutils literal notranslate"><span class="pre">cleanup_resources()</span></code> will be able to remove all extracted files.</p>
<p>(Note: you may not change the extraction path for a given resource
manager once resources have been extracted, unless you first call
<code class="docutils literal notranslate"><span class="pre">cleanup_resources()</span></code>.)</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.split_sections">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">split_sections</code><span class="sig-paren">(</span><em class="sig-param">s</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#split_sections"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.split_sections" title="Permalink to this definition">¶</a></dt>
<dd><p>Split a string or iterable thereof into (section, content) pairs</p>
<p>Each <code class="docutils literal notranslate"><span class="pre">section</span></code> is a stripped version of the section header (“[section]”)
and each <code class="docutils literal notranslate"><span class="pre">content</span></code> is a list of stripped lines excluding blank lines and
comment-only lines.  If there are any such lines before the first section
header, they’re returned in a first <code class="docutils literal notranslate"><span class="pre">section</span></code> of <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.to_filename">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">to_filename</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#to_filename"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.to_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a project or version name to its filename-escaped form</p>
<p>Any ‘-’ characters are currently replaced with ‘_’.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.to_json">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">to_json</code><span class="sig-paren">(</span><em class="sig-param">node: nmodl::ast::Ast</em>, <em class="sig-param">compact: bool = False</em>, <em class="sig-param">expand: bool = False</em>, <em class="sig-param">add_nmodl: bool = False</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.dsl.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Given AST node, return the JSON string representation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node</strong> (<em>AST</em>) – AST node</p></li>
<li><p><strong>compact</strong> (<em>bool</em>) – Compact node</p></li>
<li><p><strong>expand</strong> (<em>bool</em>) – Expand node</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>JSON string representation</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ast</span> <span class="o">=</span> <span class="n">driver</span><span class="o">.</span><span class="n">parse_string</span><span class="p">(</span><span class="s2">&quot;NEURON</span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nmodl</span><span class="o">.</span><span class="n">to_json</span><span class="p">(</span><span class="n">ast</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;{&quot;Program&quot;:[{&quot;NeuronBlock&quot;:[{&quot;StatementBlock&quot;:[]}]}]}&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.to_nmodl">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">to_nmodl</code><span class="sig-paren">(</span><em class="sig-param">node: nmodl::ast::Ast</em>, <em class="sig-param">exclude_types: Set[nmodl::ast::AstNodeType] = set()</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.dsl.to_nmodl" title="Permalink to this definition">¶</a></dt>
<dd><p>Given AST node, return the NMODL string representation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node</strong> (<em>AST</em>) – AST node</p></li>
<li><p><strong>excludeTypes</strong> (<em>set of AstNodeType</em>) – Excluded node types</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>NMODL string representation</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ast</span> <span class="o">=</span> <span class="n">driver</span><span class="o">.</span><span class="n">parse_string</span><span class="p">(</span><span class="s2">&quot;NEURON</span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nmodl</span><span class="o">.</span><span class="n">to_nmodl</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span>
<span class="go">&#39;NEURON {\n}\n&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="nmodl.dsl.yield_lines">
<code class="sig-prename descclassname">nmodl.dsl.</code><code class="sig-name descname">yield_lines</code><span class="sig-paren">(</span><em class="sig-param">iterable</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pkg_resources.html#yield_lines"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.dsl.yield_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield valid lines of a string or iterable</p>
</dd></dl>

</section>
<section id="module-nmodl.ode">
<span id="nmodl-ode-module"></span><h2>nmodl.ode module<a class="headerlink" href="#module-nmodl.ode" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nmodl.ode.differentiate2c">
<code class="sig-prename descclassname">nmodl.ode.</code><code class="sig-name descname">differentiate2c</code><span class="sig-paren">(</span><em class="sig-param">expression</em>, <em class="sig-param">dependent_var</em>, <em class="sig-param">vars</em>, <em class="sig-param">prev_expressions=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmodl/ode.html#differentiate2c"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ode.differentiate2c" title="Permalink to this definition">¶</a></dt>
<dd><p>Analytically differentiate supplied expression, return solution as C code.</p>
<p>Expression should be of the form “f(x)”, where “x” is
the dependent variable, and the function returns df(x)/dx</p>
<p>The set vars must contain all variables used in the expression.</p>
<p>Furthermore, if any of these variables are themselves functions that should
be substituted before differentiating, they can be supplied in the prev_expressions list.
Before differentiating each of these expressions will be substituted into expressions,
where possible, in reverse order - i.e. starting from the end of the list.</p>
<p>If the result coincides with one of the vars, or the LHS of one of
the prev_expressions, then it is simplified to this expression.</p>
<p>Some simple examples of use:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nmodl.ode.differentiate2c</span> <span class="pre">(&quot;a*x&quot;,</span> <span class="pre">&quot;x&quot;,</span> <span class="pre">{&quot;a&quot;})</span> <span class="pre">==</span> <span class="pre">&quot;a&quot;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">differentiate2c</span> <span class="pre">(&quot;cos(y)</span> <span class="pre">+</span> <span class="pre">b*y**2&quot;,</span> <span class="pre">&quot;y&quot;,</span> <span class="pre">{&quot;a&quot;,&quot;b&quot;})</span> <span class="pre">==</span> <span class="pre">&quot;Dy</span> <span class="pre">=</span> <span class="pre">2*b*y</span> <span class="pre">-</span> <span class="pre">sin(y)&quot;</span></code></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expression</strong> – expression to be differentiated e.g. “a*x + b”</p></li>
<li><p><strong>dependent_var</strong> – dependent variable, e.g. “x”</p></li>
<li><p><strong>vars</strong> – set of all other variables used in expression, e.g. {“a”, “b”, “c”}</p></li>
<li><p><strong>prev_expressions</strong> – time-ordered list of preceeding expressions
to evaluate &amp; substitute, e.g. [“b = x + c”, “a = 12*b”]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>string containing analytic derivative of expression (including any substitutions
of variables from supplied prev_expressions) w.r.t. dependent_var as C code.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nmodl.ode.forwards_euler2c">
<code class="sig-prename descclassname">nmodl.ode.</code><code class="sig-name descname">forwards_euler2c</code><span class="sig-paren">(</span><em class="sig-param">diff_string</em>, <em class="sig-param">dt_var</em>, <em class="sig-param">vars</em>, <em class="sig-param">function_calls</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmodl/ode.html#forwards_euler2c"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ode.forwards_euler2c" title="Permalink to this definition">¶</a></dt>
<dd><p>Return forwards euler solution of diff_string as C code.</p>
<p>Derivative should be of the form “x’ = f(x)”,
and vars should contain the set of all the variables
referenced by f(x), for example:
-forwards_euler2c(“x’ = a*x”, [“a”,”x”])
-forwards_euler2c(“x’ = a + b*x - sin(3.2)”, {“x”,”a”,”b”})</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>diff_string</strong> – Derivative to be integrated e.g. “x’ = a*x”</p></li>
<li><p><strong>dt_var</strong> – name of timestep dt variable in NEURON</p></li>
<li><p><strong>vars</strong> – set of variables used in expression, e.g. {“x”, “a”}</p></li>
<li><p><strong>function_calls</strong> – set of function calls used in the ODE</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>String containing forwards Euler timestep as C code</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nmodl.ode.import_module">
<code class="sig-prename descclassname">nmodl.ode.</code><code class="sig-name descname">import_module</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">package=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/importlib.html#import_module"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ode.import_module" title="Permalink to this definition">¶</a></dt>
<dd><p>Import a module.</p>
<p>The ‘package’ argument is required when performing a relative import. It
specifies the package to use as the anchor point from which to resolve the
relative import to an absolute import.</p>
</dd></dl>

<dl class="function">
<dt id="nmodl.ode.integrate2c">
<code class="sig-prename descclassname">nmodl.ode.</code><code class="sig-name descname">integrate2c</code><span class="sig-paren">(</span><em class="sig-param">diff_string</em>, <em class="sig-param">dt_var</em>, <em class="sig-param">vars</em>, <em class="sig-param">use_pade_approx=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmodl/ode.html#integrate2c"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ode.integrate2c" title="Permalink to this definition">¶</a></dt>
<dd><p>Analytically integrate supplied derivative, return solution as C code.</p>
<p>Given a differential equation of the form x’ = f(x), the value of
x at time t+dt is found in terms of the value of x at time t:
x(t + dt) = g( x(t), dt )
and this equation is returned in the format NEURON expects:
x = g( x, dt ),
where the x on the right is the current value of x at time t,
and the x on the left is the new value of x at time t+dt</p>
<p>The derivative should be of the form “x’ = f(x)”,
and vars should contain the set of all the variables
referenced by f(x), for example:</p>
<p>-<code class="docutils literal notranslate"><span class="pre">integrate2c(&quot;x'</span> <span class="pre">=</span> <span class="pre">a*x&quot;,</span> <span class="pre">&quot;dt&quot;,</span> <span class="pre">{&quot;a&quot;})</span></code>
-<code class="docutils literal notranslate"><span class="pre">integrate2c(&quot;x'</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">b*x</span> <span class="pre">-</span> <span class="pre">sin(3.2)&quot;,</span> <span class="pre">&quot;dt&quot;,</span> <span class="pre">{&quot;a&quot;,&quot;b&quot;})</span></code></p>
<p>Optionally, the analytic result can be expanded in powers of dt,
and the (1,1) Pade approximant to the solution returned.
This approximate solution is correct to second order in dt.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>diff_string</strong> – Derivative to be integrated e.g. “x’ = a*x + b”</p></li>
<li><p><strong>t_var</strong> – name of time variable t in NEURON</p></li>
<li><p><strong>dt_var</strong> – name of timestep variable dt in NEURON</p></li>
<li><p><strong>vars</strong> – set of variables used in expression, e.g. {“a”, “b”}</p></li>
<li><p><strong>use_pade_approx</strong> – if False, return exact solution
if True, return (1,1) Pade approx to solution
correct to second order in dt_var</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>string containing analytic integral of derivative as C code</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – if the ODE is too hard, or if it fails to solve it.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nmodl.ode.solve_lin_system">
<code class="sig-prename descclassname">nmodl.ode.</code><code class="sig-name descname">solve_lin_system</code><span class="sig-paren">(</span><em class="sig-param">eq_strings</em>, <em class="sig-param">vars</em>, <em class="sig-param">constants</em>, <em class="sig-param">function_calls</em>, <em class="sig-param">tmp_unique_prefix</em>, <em class="sig-param">small_system=False</em>, <em class="sig-param">do_cse=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmodl/ode.html#solve_lin_system"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ode.solve_lin_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve linear system of equations, return solution as C code.</p>
<dl class="simple">
<dt>If system is small (small_system=True, typically N&lt;=3):</dt><dd><ul class="simple">
<li><p>solve analytically by gaussian elimination</p></li>
<li><p>optionally do Common Subexpression Elimination if do_cse is true</p></li>
</ul>
</dd>
<dt>If system is large (default):</dt><dd><ul class="simple">
<li><p>gaussian elimination may not be numerically stable at runtime</p></li>
<li><p>instead return a matrix J and vector F, where J X = F</p></li>
<li><p>this linear system can then be solved for X by e.g. LU factorization</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eqs</strong> – list of equations e.g. [“x + y = a”, “y = 3 + b”]</p></li>
<li><p><strong>vars</strong> – list of variables to solve for, e.g. [“x”, “y”]</p></li>
<li><p><strong>constants</strong> – set of any other symbolic expressions used, e.g. {“a”, “b”}</p></li>
<li><p><strong>function_calls</strong> – set of function calls used in the ODE</p></li>
<li><p><strong>tmp_unique_prefix</strong> – is a unique prefix on which new variables can be easily created
by appending strings. It is usually of the form “tmp”</p></li>
<li><p><strong>small_system</strong> – if True, solve analytically by gaussian elimination
otherwise return matrix system to be solved</p></li>
<li><p><strong>do_cse</strong> – if True, do Common Subexpression Elimination</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list of strings containing assignment statements
vars: list of strings containing new local variables</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>code</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nmodl.ode.solve_non_lin_system">
<code class="sig-prename descclassname">nmodl.ode.</code><code class="sig-name descname">solve_non_lin_system</code><span class="sig-paren">(</span><em class="sig-param">eq_strings</em>, <em class="sig-param">vars</em>, <em class="sig-param">constants</em>, <em class="sig-param">function_calls</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nmodl/ode.html#solve_non_lin_system"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nmodl.ode.solve_non_lin_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve non-linear system of equations, return solution as C code.</p>
<blockquote>
<div><ul class="simple">
<li><p>returns a vector F, and its Jacobian J, both in terms of X</p></li>
<li><p>where F(X) = 0 is the implicit equation to solve for X</p></li>
<li><p>this non-linear system can then be solved with the newton solver</p></li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eqs</strong> – list of equations e.g. [“x + y = a”, “y = 3 + b”]</p></li>
<li><p><strong>vars</strong> – list of variables to solve for, e.g. [“x”, “y”]</p></li>
<li><p><strong>constants</strong> – set of any other symbolic expressions used, e.g. {“a”, “b”}</p></li>
<li><p><strong>function_calls</strong> – set of function calls used in the ODE</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>List of strings containing assignment statements</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-nmodl.symtab">
<span id="nmodl-symtab-module"></span><h2>nmodl.symtab module<a class="headerlink" href="#module-nmodl.symtab" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nmodl.symtab.Access">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.symtab.</code><code class="sig-name descname">Access</code><a class="headerlink" href="#nmodl.symtab.Access" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_builtins.pybind11_object</span></code></p>
<p>Members:</p>
<p>read</p>
<p>write</p>
<dl class="method">
<dt id="nmodl.symtab.Access.name">
<em class="property">property </em><code class="sig-name descname">name</code><a class="headerlink" href="#nmodl.symtab.Access.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.Access.read">
<code class="sig-name descname">read</code><em class="property"> = &lt;Access.read: 1&gt;</em><a class="headerlink" href="#nmodl.symtab.Access.read" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.Access.write">
<code class="sig-name descname">write</code><em class="property"> = &lt;Access.write: 2&gt;</em><a class="headerlink" href="#nmodl.symtab.Access.write" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.symtab.DeclarationType">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.symtab.</code><code class="sig-name descname">DeclarationType</code><a class="headerlink" href="#nmodl.symtab.DeclarationType" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_builtins.pybind11_object</span></code></p>
<blockquote>
<div><p>Variable DeclarationType enum</p>
</div></blockquote>
<p>Members:</p>
<blockquote>
<div><p>function</p>
<p>variable</p>
</div></blockquote>
<dl class="attribute">
<dt id="nmodl.symtab.DeclarationType.function">
<code class="sig-name descname">function</code><em class="property"> = &lt;DeclarationType.function: 1&gt;</em><a class="headerlink" href="#nmodl.symtab.DeclarationType.function" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.DeclarationType.name">
<em class="property">property </em><code class="sig-name descname">name</code><a class="headerlink" href="#nmodl.symtab.DeclarationType.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.DeclarationType.variable">
<code class="sig-name descname">variable</code><em class="property"> = &lt;DeclarationType.variable: 0&gt;</em><a class="headerlink" href="#nmodl.symtab.DeclarationType.variable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.symtab.NmodlType">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.symtab.</code><code class="sig-name descname">NmodlType</code><a class="headerlink" href="#nmodl.symtab.NmodlType" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_builtins.pybind11_object</span></code></p>
<p>Members:</p>
<p>argument</p>
<p>bbcore_pointer_var</p>
<p>constant_var</p>
<p>assigned_definition</p>
<p>derivative_block</p>
<p>discrete_block</p>
<p>electrode_cur_var</p>
<p>extern_method</p>
<p>extern_neuron_variable</p>
<p>extern_var</p>
<p>vector_def</p>
<p>function_block</p>
<p>function_table_block</p>
<p>global_var</p>
<p>kinetic_block</p>
<p>linear_block</p>
<p>local_var</p>
<p>man_linear_block</p>
<p>nonspecific_cur_var</p>
<p>param_assign</p>
<p>partial_block</p>
<p>pointer_var</p>
<p>prime_name</p>
<p>procedure_block</p>
<p>range_var</p>
<p>read_ion_var</p>
<p>section_var</p>
<p>state_var</p>
<p>table_assigned_var</p>
<p>table_statement_var</p>
<p>to_solve</p>
<p>unit_def</p>
<p>useion</p>
<p>write_ion_var</p>
<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.argument">
<code class="sig-name descname">argument</code><em class="property"> = &lt;NmodlType.argument: 32768&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.argument" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.assigned_definition">
<code class="sig-name descname">assigned_definition</code><em class="property"> = &lt;NmodlType.assigned_definition: 256&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.assigned_definition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.bbcore_pointer_var">
<code class="sig-name descname">bbcore_pointer_var</code><em class="property"> = &lt;NmodlType.bbcore_pointer_var: 32&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.bbcore_pointer_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.constant_var">
<code class="sig-name descname">constant_var</code><em class="property"> = &lt;NmodlType.constant_var: 2097152&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.constant_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.derivative_block">
<code class="sig-name descname">derivative_block</code><em class="property"> = &lt;NmodlType.derivative_block: 262144&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.derivative_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.discrete_block">
<code class="sig-name descname">discrete_block</code><em class="property"> = &lt;NmodlType.discrete_block: 8589934592&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.discrete_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.electrode_cur_var">
<code class="sig-name descname">electrode_cur_var</code><em class="property"> = &lt;NmodlType.electrode_cur_var: 8192&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.electrode_cur_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.extern_method">
<code class="sig-name descname">extern_method</code><em class="property"> = &lt;NmodlType.extern_method: 134217728&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.extern_method" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.extern_neuron_variable">
<code class="sig-name descname">extern_neuron_variable</code><em class="property"> = &lt;NmodlType.extern_neuron_variable: 67108864&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.extern_neuron_variable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.extern_var">
<code class="sig-name descname">extern_var</code><em class="property"> = &lt;NmodlType.extern_var: 64&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.extern_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.function_block">
<code class="sig-name descname">function_block</code><em class="property"> = &lt;NmodlType.function_block: 65536&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.function_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.function_table_block">
<code class="sig-name descname">function_table_block</code><em class="property"> = &lt;NmodlType.function_table_block: 16777216&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.function_table_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.global_var">
<code class="sig-name descname">global_var</code><em class="property"> = &lt;NmodlType.global_var: 2&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.global_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.kinetic_block">
<code class="sig-name descname">kinetic_block</code><em class="property"> = &lt;NmodlType.kinetic_block: 8388608&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.kinetic_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.linear_block">
<code class="sig-name descname">linear_block</code><em class="property"> = &lt;NmodlType.linear_block: 524288&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.linear_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.local_var">
<code class="sig-name descname">local_var</code><em class="property"> = &lt;NmodlType.local_var: 1&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.local_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.man_linear_block">
<code class="sig-name descname">man_linear_block</code><em class="property"> = &lt;NmodlType.man_linear_block: 1048576&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.man_linear_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.NmodlType.name">
<code class="sig-name descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.symtab.NmodlType.name" title="Permalink to this definition">¶</a></dt>
<dd><p>__str__(<a href="#id1"><span class="problematic" id="id2">*</span></a>args, <a href="#id3"><span class="problematic" id="id4">**</span></a>kwargs)
Overloaded function.</p>
<ol class="arabic simple">
<li><p>__str__(self: handle) -&gt; str</p></li>
<li><p>__str__(self: nmodl._nmodl.symtab.NmodlType) -&gt; str</p></li>
</ol>
</dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.nonspecific_cur_var">
<code class="sig-name descname">nonspecific_cur_var</code><em class="property"> = &lt;NmodlType.nonspecific_cur_var: 4096&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.nonspecific_cur_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.param_assign">
<code class="sig-name descname">param_assign</code><em class="property"> = &lt;NmodlType.param_assign: 8&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.param_assign" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.partial_block">
<code class="sig-name descname">partial_block</code><em class="property"> = &lt;NmodlType.partial_block: 4194304&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.partial_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.pointer_var">
<code class="sig-name descname">pointer_var</code><em class="property"> = &lt;NmodlType.pointer_var: 16&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.pointer_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.prime_name">
<code class="sig-name descname">prime_name</code><em class="property"> = &lt;NmodlType.prime_name: 128&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.prime_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.procedure_block">
<code class="sig-name descname">procedure_block</code><em class="property"> = &lt;NmodlType.procedure_block: 131072&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.procedure_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.range_var">
<code class="sig-name descname">range_var</code><em class="property"> = &lt;NmodlType.range_var: 4&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.range_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.read_ion_var">
<code class="sig-name descname">read_ion_var</code><em class="property"> = &lt;NmodlType.read_ion_var: 1024&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.read_ion_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.section_var">
<code class="sig-name descname">section_var</code><em class="property"> = &lt;NmodlType.section_var: 16384&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.section_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.state_var">
<code class="sig-name descname">state_var</code><em class="property"> = &lt;NmodlType.state_var: 268435456&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.state_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.table_assigned_var">
<code class="sig-name descname">table_assigned_var</code><em class="property"> = &lt;NmodlType.table_assigned_var: 4294967296&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.table_assigned_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.table_statement_var">
<code class="sig-name descname">table_statement_var</code><em class="property"> = &lt;NmodlType.table_statement_var: 2147483648&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.table_statement_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.to_solve">
<code class="sig-name descname">to_solve</code><em class="property"> = &lt;NmodlType.to_solve: 536870912&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.to_solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.unit_def">
<code class="sig-name descname">unit_def</code><em class="property"> = &lt;NmodlType.unit_def: 512&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.unit_def" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.useion">
<code class="sig-name descname">useion</code><em class="property"> = &lt;NmodlType.useion: 1073741824&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.useion" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.vector_def">
<code class="sig-name descname">vector_def</code><em class="property"> = &lt;NmodlType.vector_def: 33554432&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.vector_def" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.NmodlType.write_ion_var">
<code class="sig-name descname">write_ion_var</code><em class="property"> = &lt;NmodlType.write_ion_var: 2048&gt;</em><a class="headerlink" href="#nmodl.symtab.NmodlType.write_ion_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.symtab.Scope">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.symtab.</code><code class="sig-name descname">Scope</code><a class="headerlink" href="#nmodl.symtab.Scope" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_builtins.pybind11_object</span></code></p>
<p>Members:</p>
<p>external</p>
<p>global</p>
<p>local</p>
<p>neuron</p>
<dl class="attribute">
<dt id="nmodl.symtab.Scope.external">
<code class="sig-name descname">external</code><em class="property"> = &lt;Scope.external: 3&gt;</em><a class="headerlink" href="#nmodl.symtab.Scope.external" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.Scope.global">
<code class="sig-name descname">global</code><em class="property"> = &lt;Scope.global: 1&gt;</em><a class="headerlink" href="#nmodl.symtab.Scope.global" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.Scope.local">
<code class="sig-name descname">local</code><em class="property"> = &lt;Scope.local: 0&gt;</em><a class="headerlink" href="#nmodl.symtab.Scope.local" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.Scope.name">
<em class="property">property </em><code class="sig-name descname">name</code><a class="headerlink" href="#nmodl.symtab.Scope.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.Scope.neuron">
<code class="sig-name descname">neuron</code><em class="property"> = &lt;Scope.neuron: 2&gt;</em><a class="headerlink" href="#nmodl.symtab.Scope.neuron" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.symtab.Status">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.symtab.</code><code class="sig-name descname">Status</code><a class="headerlink" href="#nmodl.symtab.Status" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_builtins.pybind11_object</span></code></p>
<p>Members:</p>
<p>created</p>
<p>from_state</p>
<p>globalized</p>
<p>inlined</p>
<p>localized</p>
<p>renamed</p>
<p>thread_safe</p>
<dl class="attribute">
<dt id="nmodl.symtab.Status.created">
<code class="sig-name descname">created</code><em class="property"> = &lt;Status.created: 16&gt;</em><a class="headerlink" href="#nmodl.symtab.Status.created" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.Status.from_state">
<code class="sig-name descname">from_state</code><em class="property"> = &lt;Status.from_state: 32&gt;</em><a class="headerlink" href="#nmodl.symtab.Status.from_state" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.Status.globalized">
<code class="sig-name descname">globalized</code><em class="property"> = &lt;Status.globalized: 2&gt;</em><a class="headerlink" href="#nmodl.symtab.Status.globalized" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.Status.inlined">
<code class="sig-name descname">inlined</code><em class="property"> = &lt;Status.inlined: 4&gt;</em><a class="headerlink" href="#nmodl.symtab.Status.inlined" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.Status.localized">
<code class="sig-name descname">localized</code><em class="property"> = &lt;Status.localized: 1&gt;</em><a class="headerlink" href="#nmodl.symtab.Status.localized" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.Status.name">
<code class="sig-name descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.symtab.Status.name" title="Permalink to this definition">¶</a></dt>
<dd><p>__str__(<a href="#id5"><span class="problematic" id="id6">*</span></a>args, <a href="#id7"><span class="problematic" id="id8">**</span></a>kwargs)
Overloaded function.</p>
<ol class="arabic simple">
<li><p>__str__(self: handle) -&gt; str</p></li>
<li><p>__str__(self: nmodl._nmodl.symtab.Status) -&gt; str</p></li>
</ol>
</dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.Status.renamed">
<code class="sig-name descname">renamed</code><em class="property"> = &lt;Status.renamed: 8&gt;</em><a class="headerlink" href="#nmodl.symtab.Status.renamed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.Status.thread_safe">
<code class="sig-name descname">thread_safe</code><em class="property"> = &lt;Status.thread_safe: 64&gt;</em><a class="headerlink" href="#nmodl.symtab.Status.thread_safe" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.symtab.Symbol">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.symtab.</code><code class="sig-name descname">Symbol</code><a class="headerlink" href="#nmodl.symtab.Symbol" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_builtins.pybind11_object</span></code></p>
<p>Symbol class</p>
<dl class="method">
<dt id="nmodl.symtab.Symbol.get_id">
<code class="sig-name descname">get_id</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.Symbol</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#nmodl.symtab.Symbol.get_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.Symbol.get_name">
<code class="sig-name descname">get_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.Symbol</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.symtab.Symbol.get_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.Symbol.get_node">
<code class="sig-name descname">get_node</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.Symbol</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.ast.Ast<a class="headerlink" href="#nmodl.symtab.Symbol.get_node" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.Symbol.get_original_name">
<code class="sig-name descname">get_original_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.Symbol</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.symtab.Symbol.get_original_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.Symbol.get_properties">
<code class="sig-name descname">get_properties</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.Symbol</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.symtab.NmodlType<a class="headerlink" href="#nmodl.symtab.Symbol.get_properties" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.Symbol.get_status">
<code class="sig-name descname">get_status</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.Symbol</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.symtab.Status<a class="headerlink" href="#nmodl.symtab.Symbol.get_status" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.Symbol.get_token">
<code class="sig-name descname">get_token</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.Symbol</em><span class="sig-paren">)</span> &#x2192; nmodl::ModToken<a class="headerlink" href="#nmodl.symtab.Symbol.get_token" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.Symbol.has_all_properties">
<code class="sig-name descname">has_all_properties</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.Symbol</em>, <em class="sig-param">arg0: nmodl._nmodl.symtab.NmodlType</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.symtab.Symbol.has_all_properties" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.Symbol.has_all_status">
<code class="sig-name descname">has_all_status</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.Symbol</em>, <em class="sig-param">arg0: nmodl._nmodl.symtab.Status</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.symtab.Symbol.has_all_status" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.Symbol.has_any_property">
<code class="sig-name descname">has_any_property</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.Symbol</em>, <em class="sig-param">arg0: nmodl._nmodl.symtab.NmodlType</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.symtab.Symbol.has_any_property" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.Symbol.has_any_status">
<code class="sig-name descname">has_any_status</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.Symbol</em>, <em class="sig-param">arg0: nmodl._nmodl.symtab.Status</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.symtab.Symbol.has_any_status" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.Symbol.is_external_variable">
<code class="sig-name descname">is_external_variable</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.Symbol</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.symtab.Symbol.is_external_variable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.Symbol.is_variable">
<code class="sig-name descname">is_variable</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.Symbol</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.symtab.Symbol.is_variable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.symtab.SymbolTable">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.symtab.</code><code class="sig-name descname">SymbolTable</code><a class="headerlink" href="#nmodl.symtab.SymbolTable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_builtins.pybind11_object</span></code></p>
<p>SymbolTable class</p>
<dl class="attribute">
<dt id="nmodl.symtab.SymbolTable.name">
<code class="sig-name descname">name</code><a class="headerlink" href="#nmodl.symtab.SymbolTable.name" title="Permalink to this definition">¶</a></dt>
<dd><p>name of the block</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.SymbolTable.table">
<code class="sig-name descname">table</code><a class="headerlink" href="#nmodl.symtab.SymbolTable.table" title="Permalink to this definition">¶</a></dt>
<dd><p>table holding all symbols in the current block</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>Table</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.SymbolTable.node">
<code class="sig-name descname">node</code><a class="headerlink" href="#nmodl.symtab.SymbolTable.node" title="Permalink to this definition">¶</a></dt>
<dd><p>pointer to ast node for which current block symbol created</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>AST</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.SymbolTable.global">
<code class="sig-name descname">global</code><a class="headerlink" href="#nmodl.symtab.SymbolTable.global" title="Permalink to this definition">¶</a></dt>
<dd><p>true if current symbol table is global. blocks like neuron,
parameter defines global variables and hence they go into single global symbol table</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.SymbolTable.parent">
<code class="sig-name descname">parent</code><a class="headerlink" href="#nmodl.symtab.SymbolTable.parent" title="Permalink to this definition">¶</a></dt>
<dd><p>pointer to the symbol table of parent block in the mod file</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#nmodl.symtab.SymbolTable" title="nmodl.symtab.SymbolTable">SymbolTable</a></p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.SymbolTable.children">
<code class="sig-name descname">children</code><a class="headerlink" href="#nmodl.symtab.SymbolTable.children" title="Permalink to this definition">¶</a></dt>
<dd><p>symbol table for each enclosing block in the current nmodl block construct.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dict of (str, <a class="reference internal" href="#nmodl.symtab.SymbolTable" title="nmodl.symtab.SymbolTable">SymbolTable</a>)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymbolTable.get_parent_table">
<code class="sig-name descname">get_parent_table</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymbolTable</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.symtab.SymbolTable<a class="headerlink" href="#nmodl.symtab.SymbolTable.get_parent_table" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymbolTable.get_parent_table_name">
<code class="sig-name descname">get_parent_table_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymbolTable</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.symtab.SymbolTable.get_parent_table_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymbolTable.get_variables">
<code class="sig-name descname">get_variables</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymbolTable</em>, <em class="sig-param">with: nmodl._nmodl.symtab.NmodlType = &lt;NmodlType.???: 0&gt;</em>, <em class="sig-param">without: nmodl._nmodl.symtab.NmodlType = &lt;NmodlType.???: 0&gt;</em><span class="sig-paren">)</span> &#x2192; List[nmodl._nmodl.symtab.Symbol]<a class="headerlink" href="#nmodl.symtab.SymbolTable.get_variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymbolTable.get_variables_with_properties">
<code class="sig-name descname">get_variables_with_properties</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymbolTable</em>, <em class="sig-param">properties: nmodl._nmodl.symtab.NmodlType</em>, <em class="sig-param">all: bool = False</em><span class="sig-paren">)</span> &#x2192; List[nmodl._nmodl.symtab.Symbol]<a class="headerlink" href="#nmodl.symtab.SymbolTable.get_variables_with_properties" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymbolTable.get_variables_with_status">
<code class="sig-name descname">get_variables_with_status</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymbolTable</em>, <em class="sig-param">status: nmodl._nmodl.symtab.Status</em>, <em class="sig-param">all: bool = False</em><span class="sig-paren">)</span> &#x2192; List[nmodl._nmodl.symtab.Symbol]<a class="headerlink" href="#nmodl.symtab.SymbolTable.get_variables_with_status" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymbolTable.insert">
<code class="sig-name descname">insert</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymbolTable</em>, <em class="sig-param">arg0: nmodl._nmodl.symtab.Symbol</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymbolTable.insert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymbolTable.insert_table">
<code class="sig-name descname">insert_table</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymbolTable</em>, <em class="sig-param">arg0: str</em>, <em class="sig-param">arg1: nmodl._nmodl.symtab.SymbolTable</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymbolTable.insert_table" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymbolTable.is_method_defined">
<code class="sig-name descname">is_method_defined</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymbolTable</em>, <em class="sig-param">arg0: str</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#nmodl.symtab.SymbolTable.is_method_defined" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymbolTable.lookup">
<code class="sig-name descname">lookup</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymbolTable</em>, <em class="sig-param">arg0: str</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.symtab.Symbol<a class="headerlink" href="#nmodl.symtab.SymbolTable.lookup" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymbolTable.lookup_in_scope">
<code class="sig-name descname">lookup_in_scope</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymbolTable</em>, <em class="sig-param">arg0: str</em><span class="sig-paren">)</span> &#x2192; nmodl._nmodl.symtab.Symbol<a class="headerlink" href="#nmodl.symtab.SymbolTable.lookup_in_scope" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymbolTable</em><span class="sig-paren">)</span> &#x2192; str</dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymbolTable.title">
<code class="sig-name descname">title</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymbolTable</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#nmodl.symtab.SymbolTable.title" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.symtab.SymtabVisitor">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.symtab.</code><code class="sig-name descname">SymtabVisitor</code><a class="headerlink" href="#nmodl.symtab.SymtabVisitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.visitor.AstVisitor</span></code></p>
<p>SymtabVisitor class</p>
<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.add_model_symbol_with_property">
<code class="sig-name descname">add_model_symbol_with_property</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">node: nmodl._nmodl.ast.Node</em>, <em class="sig-param">property: nmodl._nmodl.symtab.NmodlType</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.add_model_symbol_with_property" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.setup_symbol">
<code class="sig-name descname">setup_symbol</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Node</em>, <em class="sig-param">arg1: nmodl._nmodl.symtab.NmodlType</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.setup_symbol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.setup_symbol_table">
<code class="sig-name descname">setup_symbol_table</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Ast</em>, <em class="sig-param">arg1: str</em>, <em class="sig-param">arg2: bool</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.setup_symbol_table" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.setup_symbol_table_for_global_block">
<code class="sig-name descname">setup_symbol_table_for_global_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Node</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.setup_symbol_table_for_global_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.setup_symbol_table_for_program_block">
<code class="sig-name descname">setup_symbol_table_for_program_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Program</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.setup_symbol_table_for_program_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.setup_symbol_table_for_scoped_block">
<code class="sig-name descname">setup_symbol_table_for_scoped_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Node</em>, <em class="sig-param">arg1: str</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.setup_symbol_table_for_scoped_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_after_block">
<code class="sig-name descname">visit_after_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.AfterBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_after_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_argument">
<code class="sig-name descname">visit_argument</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Argument</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_argument" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_assigned_block">
<code class="sig-name descname">visit_assigned_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.AssignedBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_assigned_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_assigned_definition">
<code class="sig-name descname">visit_assigned_definition</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.AssignedDefinition</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_assigned_definition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_ba_block">
<code class="sig-name descname">visit_ba_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.BABlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_ba_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_ba_block_type">
<code class="sig-name descname">visit_ba_block_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.BABlockType</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_ba_block_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_bbcore_pointer">
<code class="sig-name descname">visit_bbcore_pointer</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.BbcorePointer</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_bbcore_pointer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_bbcore_pointer_var">
<code class="sig-name descname">visit_bbcore_pointer_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.BbcorePointerVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_bbcore_pointer_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_before_block">
<code class="sig-name descname">visit_before_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.BeforeBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_before_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_binary_expression">
<code class="sig-name descname">visit_binary_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.BinaryExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_binary_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_binary_operator">
<code class="sig-name descname">visit_binary_operator</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.BinaryOperator</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_binary_operator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_block">
<code class="sig-name descname">visit_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Block</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_block_comment">
<code class="sig-name descname">visit_block_comment</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.BlockComment</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_block_comment" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_boolean">
<code class="sig-name descname">visit_boolean</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Boolean</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_boolean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_breakpoint_block">
<code class="sig-name descname">visit_breakpoint_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.BreakpointBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_breakpoint_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_compartment">
<code class="sig-name descname">visit_compartment</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Compartment</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_compartment" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_conductance_hint">
<code class="sig-name descname">visit_conductance_hint</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.ConductanceHint</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_conductance_hint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_conserve">
<code class="sig-name descname">visit_conserve</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Conserve</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_conserve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_constant_block">
<code class="sig-name descname">visit_constant_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.ConstantBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_constant_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_constant_statement">
<code class="sig-name descname">visit_constant_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.ConstantStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_constant_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_constant_var">
<code class="sig-name descname">visit_constant_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.ConstantVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_constant_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_constructor_block">
<code class="sig-name descname">visit_constructor_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.ConstructorBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_constructor_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_define">
<code class="sig-name descname">visit_define</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Define</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_define" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_derivative_block">
<code class="sig-name descname">visit_derivative_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.DerivativeBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_derivative_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_derivimplicit_callback">
<code class="sig-name descname">visit_derivimplicit_callback</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.DerivimplicitCallback</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_derivimplicit_callback" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_destructor_block">
<code class="sig-name descname">visit_destructor_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.DestructorBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_destructor_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_diff_eq_expression">
<code class="sig-name descname">visit_diff_eq_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.DiffEqExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_diff_eq_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_discrete_block">
<code class="sig-name descname">visit_discrete_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.DiscreteBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_discrete_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_double">
<code class="sig-name descname">visit_double</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Double</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_double" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_double_unit">
<code class="sig-name descname">visit_double_unit</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.DoubleUnit</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_double_unit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_eigen_linear_solver_block">
<code class="sig-name descname">visit_eigen_linear_solver_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.EigenLinearSolverBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_eigen_linear_solver_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_eigen_newton_solver_block">
<code class="sig-name descname">visit_eigen_newton_solver_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.EigenNewtonSolverBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_eigen_newton_solver_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_electrode_cur_var">
<code class="sig-name descname">visit_electrode_cur_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.ElectrodeCurVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_electrode_cur_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_electrode_current">
<code class="sig-name descname">visit_electrode_current</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.ElectrodeCurrent</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_electrode_current" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_else_if_statement">
<code class="sig-name descname">visit_else_if_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.ElseIfStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_else_if_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_else_statement">
<code class="sig-name descname">visit_else_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.ElseStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_else_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_expression">
<code class="sig-name descname">visit_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Expression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_expression_statement">
<code class="sig-name descname">visit_expression_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.ExpressionStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_expression_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_extern_var">
<code class="sig-name descname">visit_extern_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.ExternVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_extern_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_external">
<code class="sig-name descname">visit_external</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.External</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_external" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_factor_def">
<code class="sig-name descname">visit_factor_def</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.FactorDef</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_factor_def" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_first_last_type_index">
<code class="sig-name descname">visit_first_last_type_index</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.FirstLastTypeIndex</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_first_last_type_index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_float">
<code class="sig-name descname">visit_float</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_float" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_for_all_statement">
<code class="sig-name descname">visit_for_all_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.ForAllStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_for_all_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_for_netcon">
<code class="sig-name descname">visit_for_netcon</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.ForNetcon</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_for_netcon" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_from_statement">
<code class="sig-name descname">visit_from_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.FromStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_from_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_function_block">
<code class="sig-name descname">visit_function_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.FunctionBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_function_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_function_call">
<code class="sig-name descname">visit_function_call</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.FunctionCall</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_function_call" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_function_table_block">
<code class="sig-name descname">visit_function_table_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.FunctionTableBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_function_table_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_global">
<code class="sig-name descname">visit_global</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Global</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_global" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_global_var">
<code class="sig-name descname">visit_global_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.GlobalVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_global_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_identifier">
<code class="sig-name descname">visit_identifier</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Identifier</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_identifier" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_if_statement">
<code class="sig-name descname">visit_if_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.IfStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_if_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_include">
<code class="sig-name descname">visit_include</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Include</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_include" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_independent_block">
<code class="sig-name descname">visit_independent_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.IndependentBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_independent_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_independent_definition">
<code class="sig-name descname">visit_independent_definition</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.IndependentDefinition</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_independent_definition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_indexed_name">
<code class="sig-name descname">visit_indexed_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.IndexedName</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_indexed_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_initial_block">
<code class="sig-name descname">visit_initial_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.InitialBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_initial_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_integer">
<code class="sig-name descname">visit_integer</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Integer</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_integer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_kinetic_block">
<code class="sig-name descname">visit_kinetic_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.KineticBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_kinetic_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_lag_statement">
<code class="sig-name descname">visit_lag_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.LagStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_lag_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_limits">
<code class="sig-name descname">visit_limits</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Limits</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_limits" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_lin_equation">
<code class="sig-name descname">visit_lin_equation</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.LinEquation</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_lin_equation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_line_comment">
<code class="sig-name descname">visit_line_comment</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.LineComment</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_line_comment" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_linear_block">
<code class="sig-name descname">visit_linear_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.LinearBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_linear_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_local_list_statement">
<code class="sig-name descname">visit_local_list_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.LocalListStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_local_list_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_local_var">
<code class="sig-name descname">visit_local_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.LocalVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_local_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_lon_difuse">
<code class="sig-name descname">visit_lon_difuse</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.LonDifuse</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_lon_difuse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_match">
<code class="sig-name descname">visit_match</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Match</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_match" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_match_block">
<code class="sig-name descname">visit_match_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.MatchBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_match_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_model">
<code class="sig-name descname">visit_model</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Model</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_mutex_lock">
<code class="sig-name descname">visit_mutex_lock</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.MutexLock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_mutex_lock" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_mutex_unlock">
<code class="sig-name descname">visit_mutex_unlock</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.MutexUnlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_mutex_unlock" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_name">
<code class="sig-name descname">visit_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Name</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_net_receive_block">
<code class="sig-name descname">visit_net_receive_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.NetReceiveBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_net_receive_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_neuron_block">
<code class="sig-name descname">visit_neuron_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.NeuronBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_neuron_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_node">
<code class="sig-name descname">visit_node</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Node</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_node" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_non_lin_equation">
<code class="sig-name descname">visit_non_lin_equation</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.NonLinEquation</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_non_lin_equation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_non_linear_block">
<code class="sig-name descname">visit_non_linear_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.NonLinearBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_non_linear_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_nonspecific">
<code class="sig-name descname">visit_nonspecific</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Nonspecific</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_nonspecific" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_nonspecific_cur_var">
<code class="sig-name descname">visit_nonspecific_cur_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.NonspecificCurVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_nonspecific_cur_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_nrn_state_block">
<code class="sig-name descname">visit_nrn_state_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.NrnStateBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_nrn_state_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_number">
<code class="sig-name descname">visit_number</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Number</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_number" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_number_range">
<code class="sig-name descname">visit_number_range</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.NumberRange</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_number_range" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_ontology_statement">
<code class="sig-name descname">visit_ontology_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.OntologyStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_ontology_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_param_assign">
<code class="sig-name descname">visit_param_assign</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.ParamAssign</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_param_assign" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_param_block">
<code class="sig-name descname">visit_param_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.ParamBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_param_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_paren_expression">
<code class="sig-name descname">visit_paren_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.ParenExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_paren_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_partial_block">
<code class="sig-name descname">visit_partial_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.PartialBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_partial_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_partial_boundary">
<code class="sig-name descname">visit_partial_boundary</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.PartialBoundary</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_partial_boundary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_partial_equation">
<code class="sig-name descname">visit_partial_equation</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.PartialEquation</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_partial_equation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_plot_block">
<code class="sig-name descname">visit_plot_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.PlotBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_plot_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_plot_declaration">
<code class="sig-name descname">visit_plot_declaration</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.PlotDeclaration</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_plot_declaration" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_plot_var">
<code class="sig-name descname">visit_plot_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.PlotVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_plot_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_pointer">
<code class="sig-name descname">visit_pointer</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Pointer</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_pointer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_pointer_var">
<code class="sig-name descname">visit_pointer_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.PointerVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_pointer_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_prime_name">
<code class="sig-name descname">visit_prime_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.PrimeName</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_prime_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_procedure_block">
<code class="sig-name descname">visit_procedure_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.ProcedureBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_procedure_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_program">
<code class="sig-name descname">visit_program</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Program</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_program" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_protect_statement">
<code class="sig-name descname">visit_protect_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.ProtectStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_protect_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_queue_expression_type">
<code class="sig-name descname">visit_queue_expression_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.QueueExpressionType</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_queue_expression_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_queue_statement">
<code class="sig-name descname">visit_queue_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.QueueStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_queue_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_range">
<code class="sig-name descname">visit_range</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Range</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_range" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_range_var">
<code class="sig-name descname">visit_range_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.RangeVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_range_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_react_var_name">
<code class="sig-name descname">visit_react_var_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.ReactVarName</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_react_var_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_reaction_operator">
<code class="sig-name descname">visit_reaction_operator</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.ReactionOperator</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_reaction_operator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_reaction_statement">
<code class="sig-name descname">visit_reaction_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.ReactionStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_reaction_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_read_ion_var">
<code class="sig-name descname">visit_read_ion_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.ReadIonVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_read_ion_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_reset">
<code class="sig-name descname">visit_reset</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Reset</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_section">
<code class="sig-name descname">visit_section</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Section</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_section" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_section_var">
<code class="sig-name descname">visit_section_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.SectionVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_section_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_sens">
<code class="sig-name descname">visit_sens</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Sens</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_sens" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_solution_expression">
<code class="sig-name descname">visit_solution_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.SolutionExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_solution_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_solve_block">
<code class="sig-name descname">visit_solve_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.SolveBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_solve_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_state_block">
<code class="sig-name descname">visit_state_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.StateBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_state_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_statement">
<code class="sig-name descname">visit_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Statement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_statement_block">
<code class="sig-name descname">visit_statement_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.StatementBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_statement_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_step_block">
<code class="sig-name descname">visit_step_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.StepBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_step_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_stepped">
<code class="sig-name descname">visit_stepped</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Stepped</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_stepped" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_string">
<code class="sig-name descname">visit_string</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.String</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_string" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_suffix">
<code class="sig-name descname">visit_suffix</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Suffix</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_suffix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_table_statement">
<code class="sig-name descname">visit_table_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.TableStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_table_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_terminal_block">
<code class="sig-name descname">visit_terminal_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.TerminalBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_terminal_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_thread_safe">
<code class="sig-name descname">visit_thread_safe</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.ThreadSafe</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_thread_safe" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_threadsafe_var">
<code class="sig-name descname">visit_threadsafe_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.ThreadsafeVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_threadsafe_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_unary_expression">
<code class="sig-name descname">visit_unary_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.UnaryExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_unary_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_unary_operator">
<code class="sig-name descname">visit_unary_operator</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.UnaryOperator</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_unary_operator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_unit">
<code class="sig-name descname">visit_unit</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Unit</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_unit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_unit_block">
<code class="sig-name descname">visit_unit_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.UnitBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_unit_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_unit_def">
<code class="sig-name descname">visit_unit_def</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.UnitDef</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_unit_def" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_unit_state">
<code class="sig-name descname">visit_unit_state</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.UnitState</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_unit_state" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_update_dt">
<code class="sig-name descname">visit_update_dt</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.UpdateDt</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_update_dt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_useion">
<code class="sig-name descname">visit_useion</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Useion</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_useion" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_valence">
<code class="sig-name descname">visit_valence</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Valence</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_valence" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_var_name">
<code class="sig-name descname">visit_var_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.VarName</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_var_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_verbatim">
<code class="sig-name descname">visit_verbatim</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Verbatim</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_verbatim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_watch">
<code class="sig-name descname">visit_watch</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.Watch</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_watch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_watch_statement">
<code class="sig-name descname">visit_watch_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.WatchStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_watch_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_while_statement">
<code class="sig-name descname">visit_while_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.WhileStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_while_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_wrapped_expression">
<code class="sig-name descname">visit_wrapped_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.WrappedExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_wrapped_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.SymtabVisitor.visit_write_ion_var">
<code class="sig-name descname">visit_write_ion_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.symtab.SymtabVisitor</em>, <em class="sig-param">arg0: nmodl._nmodl.ast.WriteIonVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.symtab.SymtabVisitor.visit_write_ion_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.symtab.VariableType">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.symtab.</code><code class="sig-name descname">VariableType</code><a class="headerlink" href="#nmodl.symtab.VariableType" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_builtins.pybind11_object</span></code></p>
<p>Members:</p>
<p>array</p>
<p>scalar</p>
<dl class="attribute">
<dt id="nmodl.symtab.VariableType.array">
<code class="sig-name descname">array</code><em class="property"> = &lt;VariableType.array: 1&gt;</em><a class="headerlink" href="#nmodl.symtab.VariableType.array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.symtab.VariableType.name">
<em class="property">property </em><code class="sig-name descname">name</code><a class="headerlink" href="#nmodl.symtab.VariableType.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nmodl.symtab.VariableType.scalar">
<code class="sig-name descname">scalar</code><em class="property"> = &lt;VariableType.scalar: 0&gt;</em><a class="headerlink" href="#nmodl.symtab.VariableType.scalar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-nmodl.visitor">
<span id="nmodl-visitor-module"></span><h2>nmodl.visitor module<a class="headerlink" href="#module-nmodl.visitor" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nmodl.visitor.AstLookupVisitor">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.visitor.</code><code class="sig-name descname">AstLookupVisitor</code><a class="headerlink" href="#nmodl.visitor.AstLookupVisitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.visitor.Visitor</span></code></p>
<p>AstLookupVisitor class</p>
<dl class="attribute">
<dt id="nmodl.visitor.AstLookupVisitor.types">
<code class="sig-name descname">types</code><a class="headerlink" href="#nmodl.visitor.AstLookupVisitor.types" title="Permalink to this definition">¶</a></dt>
<dd><p>node types to search in the AST</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list of <code class="xref py py-class docutils literal notranslate"><span class="pre">AstNodeType</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="nmodl.visitor.AstLookupVisitor.nodes">
<code class="sig-name descname">nodes</code><a class="headerlink" href="#nmodl.visitor.AstLookupVisitor.nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>matching nodes found in the AST</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list of AST</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstLookupVisitor.clear">
<code class="sig-name descname">clear</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstLookupVisitor</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstLookupVisitor.clear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstLookupVisitor.get_nodes">
<code class="sig-name descname">get_nodes</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstLookupVisitor</em><span class="sig-paren">)</span> &#x2192; List[nmodl::ast::Ast]<a class="headerlink" href="#nmodl.visitor.AstLookupVisitor.get_nodes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstLookupVisitor.lookup">
<code class="sig-name descname">lookup</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nmodl.visitor.AstLookupVisitor.lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>lookup(self: nmodl._nmodl.visitor.AstLookupVisitor, arg0: nmodl::ast::Ast) -&gt; List[nmodl::ast::Ast]</p></li>
<li><p>lookup(self: nmodl._nmodl.visitor.AstLookupVisitor, arg0: nmodl::ast::Ast, arg1: nmodl::ast::AstNodeType) -&gt; List[nmodl::ast::Ast]</p></li>
<li><p>lookup(self: nmodl._nmodl.visitor.AstLookupVisitor, arg0: nmodl::ast::Ast, arg1: List[nmodl::ast::AstNodeType]) -&gt; List[nmodl::ast::Ast]</p></li>
</ol>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.visitor.AstVisitor">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.visitor.</code><code class="sig-name descname">AstVisitor</code><a class="headerlink" href="#nmodl.visitor.AstVisitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.visitor.Visitor</span></code></p>
<p>AstVisitor class</p>
<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_after_block">
<code class="sig-name descname">visit_after_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::AfterBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_after_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_argument">
<code class="sig-name descname">visit_argument</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Argument</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_argument" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_assigned_block">
<code class="sig-name descname">visit_assigned_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::AssignedBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_assigned_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_assigned_definition">
<code class="sig-name descname">visit_assigned_definition</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::AssignedDefinition</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_assigned_definition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_ba_block">
<code class="sig-name descname">visit_ba_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BABlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_ba_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_ba_block_type">
<code class="sig-name descname">visit_ba_block_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BABlockType</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_ba_block_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_bbcore_pointer">
<code class="sig-name descname">visit_bbcore_pointer</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BbcorePointer</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_bbcore_pointer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_bbcore_pointer_var">
<code class="sig-name descname">visit_bbcore_pointer_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BbcorePointerVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_bbcore_pointer_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_before_block">
<code class="sig-name descname">visit_before_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BeforeBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_before_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_binary_expression">
<code class="sig-name descname">visit_binary_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BinaryExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_binary_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_binary_operator">
<code class="sig-name descname">visit_binary_operator</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BinaryOperator</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_binary_operator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_block">
<code class="sig-name descname">visit_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Block</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_block_comment">
<code class="sig-name descname">visit_block_comment</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BlockComment</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_block_comment" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_boolean">
<code class="sig-name descname">visit_boolean</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Boolean</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_boolean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_breakpoint_block">
<code class="sig-name descname">visit_breakpoint_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BreakpointBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_breakpoint_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_compartment">
<code class="sig-name descname">visit_compartment</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Compartment</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_compartment" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_conductance_hint">
<code class="sig-name descname">visit_conductance_hint</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ConductanceHint</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_conductance_hint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_conserve">
<code class="sig-name descname">visit_conserve</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Conserve</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_conserve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_constant_block">
<code class="sig-name descname">visit_constant_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ConstantBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_constant_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_constant_statement">
<code class="sig-name descname">visit_constant_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ConstantStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_constant_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_constant_var">
<code class="sig-name descname">visit_constant_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ConstantVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_constant_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_constructor_block">
<code class="sig-name descname">visit_constructor_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ConstructorBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_constructor_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_define">
<code class="sig-name descname">visit_define</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Define</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_define" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_derivative_block">
<code class="sig-name descname">visit_derivative_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::DerivativeBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_derivative_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_derivimplicit_callback">
<code class="sig-name descname">visit_derivimplicit_callback</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::DerivimplicitCallback</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_derivimplicit_callback" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_destructor_block">
<code class="sig-name descname">visit_destructor_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::DestructorBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_destructor_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_diff_eq_expression">
<code class="sig-name descname">visit_diff_eq_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::DiffEqExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_diff_eq_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_discrete_block">
<code class="sig-name descname">visit_discrete_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::DiscreteBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_discrete_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_double">
<code class="sig-name descname">visit_double</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Double</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_double" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_double_unit">
<code class="sig-name descname">visit_double_unit</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::DoubleUnit</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_double_unit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_eigen_linear_solver_block">
<code class="sig-name descname">visit_eigen_linear_solver_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::EigenLinearSolverBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_eigen_linear_solver_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_eigen_newton_solver_block">
<code class="sig-name descname">visit_eigen_newton_solver_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::EigenNewtonSolverBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_eigen_newton_solver_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_electrode_cur_var">
<code class="sig-name descname">visit_electrode_cur_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ElectrodeCurVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_electrode_cur_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_electrode_current">
<code class="sig-name descname">visit_electrode_current</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ElectrodeCurrent</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_electrode_current" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_else_if_statement">
<code class="sig-name descname">visit_else_if_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ElseIfStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_else_if_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_else_statement">
<code class="sig-name descname">visit_else_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ElseStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_else_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_expression">
<code class="sig-name descname">visit_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Expression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_expression_statement">
<code class="sig-name descname">visit_expression_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ExpressionStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_expression_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_extern_var">
<code class="sig-name descname">visit_extern_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ExternVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_extern_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_external">
<code class="sig-name descname">visit_external</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::External</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_external" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_factor_def">
<code class="sig-name descname">visit_factor_def</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::FactorDef</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_factor_def" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_first_last_type_index">
<code class="sig-name descname">visit_first_last_type_index</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::FirstLastTypeIndex</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_first_last_type_index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_float">
<code class="sig-name descname">visit_float</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_float" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_for_all_statement">
<code class="sig-name descname">visit_for_all_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ForAllStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_for_all_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_for_netcon">
<code class="sig-name descname">visit_for_netcon</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ForNetcon</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_for_netcon" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_from_statement">
<code class="sig-name descname">visit_from_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::FromStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_from_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_function_block">
<code class="sig-name descname">visit_function_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::FunctionBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_function_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_function_call">
<code class="sig-name descname">visit_function_call</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::FunctionCall</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_function_call" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_function_table_block">
<code class="sig-name descname">visit_function_table_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::FunctionTableBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_function_table_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_global">
<code class="sig-name descname">visit_global</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Global</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_global" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_global_var">
<code class="sig-name descname">visit_global_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::GlobalVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_global_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_identifier">
<code class="sig-name descname">visit_identifier</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Identifier</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_identifier" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_if_statement">
<code class="sig-name descname">visit_if_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::IfStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_if_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_include">
<code class="sig-name descname">visit_include</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Include</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_include" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_independent_block">
<code class="sig-name descname">visit_independent_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::IndependentBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_independent_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_independent_definition">
<code class="sig-name descname">visit_independent_definition</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::IndependentDefinition</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_independent_definition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_indexed_name">
<code class="sig-name descname">visit_indexed_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::IndexedName</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_indexed_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_initial_block">
<code class="sig-name descname">visit_initial_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::InitialBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_initial_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_integer">
<code class="sig-name descname">visit_integer</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Integer</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_integer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_kinetic_block">
<code class="sig-name descname">visit_kinetic_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::KineticBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_kinetic_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_lag_statement">
<code class="sig-name descname">visit_lag_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::LagStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_lag_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_limits">
<code class="sig-name descname">visit_limits</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Limits</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_limits" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_lin_equation">
<code class="sig-name descname">visit_lin_equation</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::LinEquation</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_lin_equation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_line_comment">
<code class="sig-name descname">visit_line_comment</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::LineComment</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_line_comment" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_linear_block">
<code class="sig-name descname">visit_linear_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::LinearBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_linear_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_local_list_statement">
<code class="sig-name descname">visit_local_list_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::LocalListStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_local_list_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_local_var">
<code class="sig-name descname">visit_local_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::LocalVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_local_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_lon_difuse">
<code class="sig-name descname">visit_lon_difuse</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::LonDifuse</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_lon_difuse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_match">
<code class="sig-name descname">visit_match</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Match</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_match" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_match_block">
<code class="sig-name descname">visit_match_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::MatchBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_match_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_model">
<code class="sig-name descname">visit_model</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Model</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_mutex_lock">
<code class="sig-name descname">visit_mutex_lock</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::MutexLock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_mutex_lock" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_mutex_unlock">
<code class="sig-name descname">visit_mutex_unlock</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::MutexUnlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_mutex_unlock" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_name">
<code class="sig-name descname">visit_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Name</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_net_receive_block">
<code class="sig-name descname">visit_net_receive_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::NetReceiveBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_net_receive_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_neuron_block">
<code class="sig-name descname">visit_neuron_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::NeuronBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_neuron_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_node">
<code class="sig-name descname">visit_node</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Node</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_node" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_non_lin_equation">
<code class="sig-name descname">visit_non_lin_equation</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::NonLinEquation</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_non_lin_equation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_non_linear_block">
<code class="sig-name descname">visit_non_linear_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::NonLinearBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_non_linear_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_nonspecific">
<code class="sig-name descname">visit_nonspecific</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Nonspecific</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_nonspecific" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_nonspecific_cur_var">
<code class="sig-name descname">visit_nonspecific_cur_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::NonspecificCurVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_nonspecific_cur_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_nrn_state_block">
<code class="sig-name descname">visit_nrn_state_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::NrnStateBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_nrn_state_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_number">
<code class="sig-name descname">visit_number</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Number</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_number" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_number_range">
<code class="sig-name descname">visit_number_range</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::NumberRange</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_number_range" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_ontology_statement">
<code class="sig-name descname">visit_ontology_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::OntologyStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_ontology_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_param_assign">
<code class="sig-name descname">visit_param_assign</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ParamAssign</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_param_assign" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_param_block">
<code class="sig-name descname">visit_param_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ParamBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_param_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_paren_expression">
<code class="sig-name descname">visit_paren_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ParenExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_paren_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_partial_block">
<code class="sig-name descname">visit_partial_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::PartialBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_partial_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_partial_boundary">
<code class="sig-name descname">visit_partial_boundary</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::PartialBoundary</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_partial_boundary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_partial_equation">
<code class="sig-name descname">visit_partial_equation</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::PartialEquation</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_partial_equation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_plot_block">
<code class="sig-name descname">visit_plot_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::PlotBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_plot_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_plot_declaration">
<code class="sig-name descname">visit_plot_declaration</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::PlotDeclaration</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_plot_declaration" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_plot_var">
<code class="sig-name descname">visit_plot_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::PlotVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_plot_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_pointer">
<code class="sig-name descname">visit_pointer</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Pointer</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_pointer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_pointer_var">
<code class="sig-name descname">visit_pointer_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::PointerVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_pointer_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_prime_name">
<code class="sig-name descname">visit_prime_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::PrimeName</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_prime_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_procedure_block">
<code class="sig-name descname">visit_procedure_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ProcedureBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_procedure_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_program">
<code class="sig-name descname">visit_program</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Program</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_program" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_protect_statement">
<code class="sig-name descname">visit_protect_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ProtectStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_protect_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_queue_expression_type">
<code class="sig-name descname">visit_queue_expression_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::QueueExpressionType</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_queue_expression_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_queue_statement">
<code class="sig-name descname">visit_queue_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::QueueStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_queue_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_range">
<code class="sig-name descname">visit_range</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Range</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_range" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_range_var">
<code class="sig-name descname">visit_range_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::RangeVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_range_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_react_var_name">
<code class="sig-name descname">visit_react_var_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ReactVarName</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_react_var_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_reaction_operator">
<code class="sig-name descname">visit_reaction_operator</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ReactionOperator</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_reaction_operator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_reaction_statement">
<code class="sig-name descname">visit_reaction_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ReactionStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_reaction_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_read_ion_var">
<code class="sig-name descname">visit_read_ion_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ReadIonVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_read_ion_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_reset">
<code class="sig-name descname">visit_reset</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Reset</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_section">
<code class="sig-name descname">visit_section</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Section</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_section" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_section_var">
<code class="sig-name descname">visit_section_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::SectionVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_section_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_sens">
<code class="sig-name descname">visit_sens</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Sens</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_sens" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_solution_expression">
<code class="sig-name descname">visit_solution_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::SolutionExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_solution_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_solve_block">
<code class="sig-name descname">visit_solve_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::SolveBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_solve_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_state_block">
<code class="sig-name descname">visit_state_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::StateBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_state_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_statement">
<code class="sig-name descname">visit_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Statement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_statement_block">
<code class="sig-name descname">visit_statement_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::StatementBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_statement_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_step_block">
<code class="sig-name descname">visit_step_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::StepBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_step_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_stepped">
<code class="sig-name descname">visit_stepped</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Stepped</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_stepped" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_string">
<code class="sig-name descname">visit_string</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::String</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_string" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_suffix">
<code class="sig-name descname">visit_suffix</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Suffix</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_suffix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_table_statement">
<code class="sig-name descname">visit_table_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::TableStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_table_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_terminal_block">
<code class="sig-name descname">visit_terminal_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::TerminalBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_terminal_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_thread_safe">
<code class="sig-name descname">visit_thread_safe</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ThreadSafe</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_thread_safe" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_threadsafe_var">
<code class="sig-name descname">visit_threadsafe_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ThreadsafeVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_threadsafe_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_unary_expression">
<code class="sig-name descname">visit_unary_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::UnaryExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_unary_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_unary_operator">
<code class="sig-name descname">visit_unary_operator</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::UnaryOperator</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_unary_operator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_unit">
<code class="sig-name descname">visit_unit</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Unit</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_unit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_unit_block">
<code class="sig-name descname">visit_unit_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::UnitBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_unit_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_unit_def">
<code class="sig-name descname">visit_unit_def</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::UnitDef</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_unit_def" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_unit_state">
<code class="sig-name descname">visit_unit_state</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::UnitState</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_unit_state" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_update_dt">
<code class="sig-name descname">visit_update_dt</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::UpdateDt</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_update_dt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_useion">
<code class="sig-name descname">visit_useion</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Useion</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_useion" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_valence">
<code class="sig-name descname">visit_valence</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Valence</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_valence" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_var_name">
<code class="sig-name descname">visit_var_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::VarName</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_var_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_verbatim">
<code class="sig-name descname">visit_verbatim</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Verbatim</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_verbatim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_watch">
<code class="sig-name descname">visit_watch</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Watch</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_watch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_watch_statement">
<code class="sig-name descname">visit_watch_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::WatchStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_watch_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_while_statement">
<code class="sig-name descname">visit_while_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::WhileStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_while_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_wrapped_expression">
<code class="sig-name descname">visit_wrapped_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::WrappedExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_wrapped_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.AstVisitor.visit_write_ion_var">
<code class="sig-name descname">visit_write_ion_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.AstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::WriteIonVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.AstVisitor.visit_write_ion_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.visitor.ConstAstVisitor">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.visitor.</code><code class="sig-name descname">ConstAstVisitor</code><a class="headerlink" href="#nmodl.visitor.ConstAstVisitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.visitor.ConstVisitor</span></code></p>
<p>AstVisitor class</p>
<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_after_block">
<code class="sig-name descname">visit_after_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::AfterBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_after_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_argument">
<code class="sig-name descname">visit_argument</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Argument</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_argument" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_assigned_block">
<code class="sig-name descname">visit_assigned_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::AssignedBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_assigned_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_assigned_definition">
<code class="sig-name descname">visit_assigned_definition</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::AssignedDefinition</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_assigned_definition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_ba_block">
<code class="sig-name descname">visit_ba_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BABlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_ba_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_ba_block_type">
<code class="sig-name descname">visit_ba_block_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BABlockType</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_ba_block_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_bbcore_pointer">
<code class="sig-name descname">visit_bbcore_pointer</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BbcorePointer</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_bbcore_pointer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_bbcore_pointer_var">
<code class="sig-name descname">visit_bbcore_pointer_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BbcorePointerVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_bbcore_pointer_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_before_block">
<code class="sig-name descname">visit_before_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BeforeBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_before_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_binary_expression">
<code class="sig-name descname">visit_binary_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BinaryExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_binary_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_binary_operator">
<code class="sig-name descname">visit_binary_operator</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BinaryOperator</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_binary_operator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_block">
<code class="sig-name descname">visit_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Block</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_block_comment">
<code class="sig-name descname">visit_block_comment</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BlockComment</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_block_comment" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_boolean">
<code class="sig-name descname">visit_boolean</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Boolean</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_boolean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_breakpoint_block">
<code class="sig-name descname">visit_breakpoint_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BreakpointBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_breakpoint_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_compartment">
<code class="sig-name descname">visit_compartment</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Compartment</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_compartment" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_conductance_hint">
<code class="sig-name descname">visit_conductance_hint</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ConductanceHint</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_conductance_hint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_conserve">
<code class="sig-name descname">visit_conserve</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Conserve</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_conserve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_constant_block">
<code class="sig-name descname">visit_constant_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ConstantBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_constant_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_constant_statement">
<code class="sig-name descname">visit_constant_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ConstantStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_constant_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_constant_var">
<code class="sig-name descname">visit_constant_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ConstantVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_constant_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_constructor_block">
<code class="sig-name descname">visit_constructor_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ConstructorBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_constructor_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_define">
<code class="sig-name descname">visit_define</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Define</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_define" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_derivative_block">
<code class="sig-name descname">visit_derivative_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::DerivativeBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_derivative_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_derivimplicit_callback">
<code class="sig-name descname">visit_derivimplicit_callback</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::DerivimplicitCallback</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_derivimplicit_callback" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_destructor_block">
<code class="sig-name descname">visit_destructor_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::DestructorBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_destructor_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_diff_eq_expression">
<code class="sig-name descname">visit_diff_eq_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::DiffEqExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_diff_eq_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_discrete_block">
<code class="sig-name descname">visit_discrete_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::DiscreteBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_discrete_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_double">
<code class="sig-name descname">visit_double</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Double</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_double" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_double_unit">
<code class="sig-name descname">visit_double_unit</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::DoubleUnit</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_double_unit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_eigen_linear_solver_block">
<code class="sig-name descname">visit_eigen_linear_solver_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::EigenLinearSolverBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_eigen_linear_solver_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_eigen_newton_solver_block">
<code class="sig-name descname">visit_eigen_newton_solver_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::EigenNewtonSolverBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_eigen_newton_solver_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_electrode_cur_var">
<code class="sig-name descname">visit_electrode_cur_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ElectrodeCurVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_electrode_cur_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_electrode_current">
<code class="sig-name descname">visit_electrode_current</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ElectrodeCurrent</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_electrode_current" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_else_if_statement">
<code class="sig-name descname">visit_else_if_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ElseIfStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_else_if_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_else_statement">
<code class="sig-name descname">visit_else_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ElseStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_else_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_expression">
<code class="sig-name descname">visit_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Expression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_expression_statement">
<code class="sig-name descname">visit_expression_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ExpressionStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_expression_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_extern_var">
<code class="sig-name descname">visit_extern_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ExternVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_extern_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_external">
<code class="sig-name descname">visit_external</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::External</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_external" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_factor_def">
<code class="sig-name descname">visit_factor_def</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::FactorDef</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_factor_def" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_first_last_type_index">
<code class="sig-name descname">visit_first_last_type_index</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::FirstLastTypeIndex</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_first_last_type_index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_float">
<code class="sig-name descname">visit_float</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_float" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_for_all_statement">
<code class="sig-name descname">visit_for_all_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ForAllStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_for_all_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_for_netcon">
<code class="sig-name descname">visit_for_netcon</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ForNetcon</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_for_netcon" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_from_statement">
<code class="sig-name descname">visit_from_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::FromStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_from_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_function_block">
<code class="sig-name descname">visit_function_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::FunctionBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_function_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_function_call">
<code class="sig-name descname">visit_function_call</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::FunctionCall</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_function_call" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_function_table_block">
<code class="sig-name descname">visit_function_table_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::FunctionTableBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_function_table_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_global">
<code class="sig-name descname">visit_global</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Global</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_global" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_global_var">
<code class="sig-name descname">visit_global_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::GlobalVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_global_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_identifier">
<code class="sig-name descname">visit_identifier</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Identifier</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_identifier" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_if_statement">
<code class="sig-name descname">visit_if_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::IfStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_if_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_include">
<code class="sig-name descname">visit_include</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Include</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_include" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_independent_block">
<code class="sig-name descname">visit_independent_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::IndependentBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_independent_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_independent_definition">
<code class="sig-name descname">visit_independent_definition</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::IndependentDefinition</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_independent_definition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_indexed_name">
<code class="sig-name descname">visit_indexed_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::IndexedName</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_indexed_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_initial_block">
<code class="sig-name descname">visit_initial_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::InitialBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_initial_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_integer">
<code class="sig-name descname">visit_integer</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Integer</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_integer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_kinetic_block">
<code class="sig-name descname">visit_kinetic_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::KineticBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_kinetic_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_lag_statement">
<code class="sig-name descname">visit_lag_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::LagStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_lag_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_limits">
<code class="sig-name descname">visit_limits</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Limits</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_limits" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_lin_equation">
<code class="sig-name descname">visit_lin_equation</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::LinEquation</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_lin_equation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_line_comment">
<code class="sig-name descname">visit_line_comment</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::LineComment</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_line_comment" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_linear_block">
<code class="sig-name descname">visit_linear_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::LinearBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_linear_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_local_list_statement">
<code class="sig-name descname">visit_local_list_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::LocalListStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_local_list_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_local_var">
<code class="sig-name descname">visit_local_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::LocalVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_local_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_lon_difuse">
<code class="sig-name descname">visit_lon_difuse</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::LonDifuse</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_lon_difuse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_match">
<code class="sig-name descname">visit_match</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Match</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_match" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_match_block">
<code class="sig-name descname">visit_match_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::MatchBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_match_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_model">
<code class="sig-name descname">visit_model</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Model</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_mutex_lock">
<code class="sig-name descname">visit_mutex_lock</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::MutexLock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_mutex_lock" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_mutex_unlock">
<code class="sig-name descname">visit_mutex_unlock</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::MutexUnlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_mutex_unlock" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_name">
<code class="sig-name descname">visit_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Name</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_net_receive_block">
<code class="sig-name descname">visit_net_receive_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::NetReceiveBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_net_receive_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_neuron_block">
<code class="sig-name descname">visit_neuron_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::NeuronBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_neuron_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_node">
<code class="sig-name descname">visit_node</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Node</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_node" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_non_lin_equation">
<code class="sig-name descname">visit_non_lin_equation</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::NonLinEquation</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_non_lin_equation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_non_linear_block">
<code class="sig-name descname">visit_non_linear_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::NonLinearBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_non_linear_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_nonspecific">
<code class="sig-name descname">visit_nonspecific</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Nonspecific</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_nonspecific" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_nonspecific_cur_var">
<code class="sig-name descname">visit_nonspecific_cur_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::NonspecificCurVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_nonspecific_cur_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_nrn_state_block">
<code class="sig-name descname">visit_nrn_state_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::NrnStateBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_nrn_state_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_number">
<code class="sig-name descname">visit_number</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Number</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_number" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_number_range">
<code class="sig-name descname">visit_number_range</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::NumberRange</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_number_range" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_ontology_statement">
<code class="sig-name descname">visit_ontology_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::OntologyStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_ontology_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_param_assign">
<code class="sig-name descname">visit_param_assign</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ParamAssign</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_param_assign" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_param_block">
<code class="sig-name descname">visit_param_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ParamBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_param_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_paren_expression">
<code class="sig-name descname">visit_paren_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ParenExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_paren_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_partial_block">
<code class="sig-name descname">visit_partial_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::PartialBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_partial_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_partial_boundary">
<code class="sig-name descname">visit_partial_boundary</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::PartialBoundary</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_partial_boundary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_partial_equation">
<code class="sig-name descname">visit_partial_equation</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::PartialEquation</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_partial_equation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_plot_block">
<code class="sig-name descname">visit_plot_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::PlotBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_plot_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_plot_declaration">
<code class="sig-name descname">visit_plot_declaration</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::PlotDeclaration</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_plot_declaration" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_plot_var">
<code class="sig-name descname">visit_plot_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::PlotVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_plot_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_pointer">
<code class="sig-name descname">visit_pointer</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Pointer</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_pointer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_pointer_var">
<code class="sig-name descname">visit_pointer_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::PointerVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_pointer_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_prime_name">
<code class="sig-name descname">visit_prime_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::PrimeName</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_prime_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_procedure_block">
<code class="sig-name descname">visit_procedure_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ProcedureBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_procedure_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_program">
<code class="sig-name descname">visit_program</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Program</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_program" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_protect_statement">
<code class="sig-name descname">visit_protect_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ProtectStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_protect_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_queue_expression_type">
<code class="sig-name descname">visit_queue_expression_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::QueueExpressionType</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_queue_expression_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_queue_statement">
<code class="sig-name descname">visit_queue_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::QueueStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_queue_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_range">
<code class="sig-name descname">visit_range</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Range</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_range" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_range_var">
<code class="sig-name descname">visit_range_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::RangeVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_range_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_react_var_name">
<code class="sig-name descname">visit_react_var_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ReactVarName</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_react_var_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_reaction_operator">
<code class="sig-name descname">visit_reaction_operator</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ReactionOperator</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_reaction_operator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_reaction_statement">
<code class="sig-name descname">visit_reaction_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ReactionStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_reaction_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_read_ion_var">
<code class="sig-name descname">visit_read_ion_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ReadIonVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_read_ion_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_reset">
<code class="sig-name descname">visit_reset</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Reset</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_section">
<code class="sig-name descname">visit_section</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Section</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_section" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_section_var">
<code class="sig-name descname">visit_section_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::SectionVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_section_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_sens">
<code class="sig-name descname">visit_sens</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Sens</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_sens" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_solution_expression">
<code class="sig-name descname">visit_solution_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::SolutionExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_solution_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_solve_block">
<code class="sig-name descname">visit_solve_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::SolveBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_solve_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_state_block">
<code class="sig-name descname">visit_state_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::StateBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_state_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_statement">
<code class="sig-name descname">visit_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Statement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_statement_block">
<code class="sig-name descname">visit_statement_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::StatementBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_statement_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_step_block">
<code class="sig-name descname">visit_step_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::StepBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_step_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_stepped">
<code class="sig-name descname">visit_stepped</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Stepped</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_stepped" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_string">
<code class="sig-name descname">visit_string</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::String</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_string" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_suffix">
<code class="sig-name descname">visit_suffix</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Suffix</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_suffix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_table_statement">
<code class="sig-name descname">visit_table_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::TableStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_table_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_terminal_block">
<code class="sig-name descname">visit_terminal_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::TerminalBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_terminal_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_thread_safe">
<code class="sig-name descname">visit_thread_safe</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ThreadSafe</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_thread_safe" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_threadsafe_var">
<code class="sig-name descname">visit_threadsafe_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ThreadsafeVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_threadsafe_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_unary_expression">
<code class="sig-name descname">visit_unary_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::UnaryExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_unary_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_unary_operator">
<code class="sig-name descname">visit_unary_operator</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::UnaryOperator</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_unary_operator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_unit">
<code class="sig-name descname">visit_unit</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Unit</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_unit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_unit_block">
<code class="sig-name descname">visit_unit_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::UnitBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_unit_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_unit_def">
<code class="sig-name descname">visit_unit_def</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::UnitDef</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_unit_def" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_unit_state">
<code class="sig-name descname">visit_unit_state</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::UnitState</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_unit_state" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_update_dt">
<code class="sig-name descname">visit_update_dt</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::UpdateDt</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_update_dt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_useion">
<code class="sig-name descname">visit_useion</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Useion</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_useion" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_valence">
<code class="sig-name descname">visit_valence</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Valence</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_valence" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_var_name">
<code class="sig-name descname">visit_var_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::VarName</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_var_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_verbatim">
<code class="sig-name descname">visit_verbatim</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Verbatim</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_verbatim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_watch">
<code class="sig-name descname">visit_watch</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Watch</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_watch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_watch_statement">
<code class="sig-name descname">visit_watch_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::WatchStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_watch_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_while_statement">
<code class="sig-name descname">visit_while_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::WhileStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_while_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_wrapped_expression">
<code class="sig-name descname">visit_wrapped_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::WrappedExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_wrapped_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstAstVisitor.visit_write_ion_var">
<code class="sig-name descname">visit_write_ion_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstAstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::WriteIonVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstAstVisitor.visit_write_ion_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.visitor.ConstVisitor">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.visitor.</code><code class="sig-name descname">ConstVisitor</code><a class="headerlink" href="#nmodl.visitor.ConstVisitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_builtins.pybind11_object</span></code></p>
<p>Base Visitor class</p>
<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_after_block">
<code class="sig-name descname">visit_after_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::AfterBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_after_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_argument">
<code class="sig-name descname">visit_argument</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Argument</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_argument" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_assigned_block">
<code class="sig-name descname">visit_assigned_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::AssignedBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_assigned_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_assigned_definition">
<code class="sig-name descname">visit_assigned_definition</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::AssignedDefinition</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_assigned_definition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_ba_block">
<code class="sig-name descname">visit_ba_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BABlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_ba_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_ba_block_type">
<code class="sig-name descname">visit_ba_block_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BABlockType</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_ba_block_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_bbcore_pointer">
<code class="sig-name descname">visit_bbcore_pointer</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BbcorePointer</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_bbcore_pointer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_bbcore_pointer_var">
<code class="sig-name descname">visit_bbcore_pointer_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BbcorePointerVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_bbcore_pointer_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_before_block">
<code class="sig-name descname">visit_before_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BeforeBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_before_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_binary_expression">
<code class="sig-name descname">visit_binary_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BinaryExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_binary_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_binary_operator">
<code class="sig-name descname">visit_binary_operator</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BinaryOperator</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_binary_operator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_block">
<code class="sig-name descname">visit_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Block</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_block_comment">
<code class="sig-name descname">visit_block_comment</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BlockComment</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_block_comment" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_boolean">
<code class="sig-name descname">visit_boolean</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Boolean</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_boolean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_breakpoint_block">
<code class="sig-name descname">visit_breakpoint_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BreakpointBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_breakpoint_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_compartment">
<code class="sig-name descname">visit_compartment</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Compartment</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_compartment" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_conductance_hint">
<code class="sig-name descname">visit_conductance_hint</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ConductanceHint</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_conductance_hint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_conserve">
<code class="sig-name descname">visit_conserve</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Conserve</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_conserve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_constant_block">
<code class="sig-name descname">visit_constant_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ConstantBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_constant_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_constant_statement">
<code class="sig-name descname">visit_constant_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ConstantStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_constant_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_constant_var">
<code class="sig-name descname">visit_constant_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ConstantVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_constant_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_constructor_block">
<code class="sig-name descname">visit_constructor_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ConstructorBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_constructor_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_define">
<code class="sig-name descname">visit_define</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Define</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_define" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_derivative_block">
<code class="sig-name descname">visit_derivative_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::DerivativeBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_derivative_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_derivimplicit_callback">
<code class="sig-name descname">visit_derivimplicit_callback</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::DerivimplicitCallback</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_derivimplicit_callback" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_destructor_block">
<code class="sig-name descname">visit_destructor_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::DestructorBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_destructor_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_diff_eq_expression">
<code class="sig-name descname">visit_diff_eq_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::DiffEqExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_diff_eq_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_discrete_block">
<code class="sig-name descname">visit_discrete_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::DiscreteBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_discrete_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_double">
<code class="sig-name descname">visit_double</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Double</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_double" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_double_unit">
<code class="sig-name descname">visit_double_unit</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::DoubleUnit</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_double_unit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_eigen_linear_solver_block">
<code class="sig-name descname">visit_eigen_linear_solver_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::EigenLinearSolverBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_eigen_linear_solver_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_eigen_newton_solver_block">
<code class="sig-name descname">visit_eigen_newton_solver_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::EigenNewtonSolverBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_eigen_newton_solver_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_electrode_cur_var">
<code class="sig-name descname">visit_electrode_cur_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ElectrodeCurVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_electrode_cur_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_electrode_current">
<code class="sig-name descname">visit_electrode_current</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ElectrodeCurrent</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_electrode_current" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_else_if_statement">
<code class="sig-name descname">visit_else_if_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ElseIfStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_else_if_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_else_statement">
<code class="sig-name descname">visit_else_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ElseStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_else_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_expression">
<code class="sig-name descname">visit_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Expression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_expression_statement">
<code class="sig-name descname">visit_expression_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ExpressionStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_expression_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_extern_var">
<code class="sig-name descname">visit_extern_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ExternVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_extern_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_external">
<code class="sig-name descname">visit_external</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::External</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_external" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_factor_def">
<code class="sig-name descname">visit_factor_def</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::FactorDef</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_factor_def" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_first_last_type_index">
<code class="sig-name descname">visit_first_last_type_index</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::FirstLastTypeIndex</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_first_last_type_index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_float">
<code class="sig-name descname">visit_float</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_float" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_for_all_statement">
<code class="sig-name descname">visit_for_all_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ForAllStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_for_all_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_for_netcon">
<code class="sig-name descname">visit_for_netcon</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ForNetcon</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_for_netcon" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_from_statement">
<code class="sig-name descname">visit_from_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::FromStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_from_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_function_block">
<code class="sig-name descname">visit_function_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::FunctionBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_function_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_function_call">
<code class="sig-name descname">visit_function_call</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::FunctionCall</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_function_call" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_function_table_block">
<code class="sig-name descname">visit_function_table_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::FunctionTableBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_function_table_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_global">
<code class="sig-name descname">visit_global</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Global</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_global" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_global_var">
<code class="sig-name descname">visit_global_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::GlobalVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_global_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_identifier">
<code class="sig-name descname">visit_identifier</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Identifier</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_identifier" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_if_statement">
<code class="sig-name descname">visit_if_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::IfStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_if_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_include">
<code class="sig-name descname">visit_include</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Include</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_include" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_independent_block">
<code class="sig-name descname">visit_independent_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::IndependentBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_independent_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_independent_definition">
<code class="sig-name descname">visit_independent_definition</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::IndependentDefinition</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_independent_definition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_indexed_name">
<code class="sig-name descname">visit_indexed_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::IndexedName</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_indexed_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_initial_block">
<code class="sig-name descname">visit_initial_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::InitialBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_initial_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_integer">
<code class="sig-name descname">visit_integer</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Integer</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_integer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_kinetic_block">
<code class="sig-name descname">visit_kinetic_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::KineticBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_kinetic_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_lag_statement">
<code class="sig-name descname">visit_lag_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::LagStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_lag_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_limits">
<code class="sig-name descname">visit_limits</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Limits</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_limits" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_lin_equation">
<code class="sig-name descname">visit_lin_equation</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::LinEquation</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_lin_equation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_line_comment">
<code class="sig-name descname">visit_line_comment</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::LineComment</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_line_comment" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_linear_block">
<code class="sig-name descname">visit_linear_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::LinearBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_linear_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_local_list_statement">
<code class="sig-name descname">visit_local_list_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::LocalListStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_local_list_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_local_var">
<code class="sig-name descname">visit_local_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::LocalVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_local_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_lon_difuse">
<code class="sig-name descname">visit_lon_difuse</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::LonDifuse</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_lon_difuse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_match">
<code class="sig-name descname">visit_match</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Match</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_match" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_match_block">
<code class="sig-name descname">visit_match_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::MatchBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_match_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_model">
<code class="sig-name descname">visit_model</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Model</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_mutex_lock">
<code class="sig-name descname">visit_mutex_lock</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::MutexLock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_mutex_lock" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_mutex_unlock">
<code class="sig-name descname">visit_mutex_unlock</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::MutexUnlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_mutex_unlock" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_name">
<code class="sig-name descname">visit_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Name</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_net_receive_block">
<code class="sig-name descname">visit_net_receive_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::NetReceiveBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_net_receive_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_neuron_block">
<code class="sig-name descname">visit_neuron_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::NeuronBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_neuron_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_node">
<code class="sig-name descname">visit_node</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Node</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_node" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_non_lin_equation">
<code class="sig-name descname">visit_non_lin_equation</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::NonLinEquation</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_non_lin_equation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_non_linear_block">
<code class="sig-name descname">visit_non_linear_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::NonLinearBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_non_linear_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_nonspecific">
<code class="sig-name descname">visit_nonspecific</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Nonspecific</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_nonspecific" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_nonspecific_cur_var">
<code class="sig-name descname">visit_nonspecific_cur_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::NonspecificCurVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_nonspecific_cur_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_nrn_state_block">
<code class="sig-name descname">visit_nrn_state_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::NrnStateBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_nrn_state_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_number">
<code class="sig-name descname">visit_number</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Number</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_number" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_number_range">
<code class="sig-name descname">visit_number_range</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::NumberRange</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_number_range" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_ontology_statement">
<code class="sig-name descname">visit_ontology_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::OntologyStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_ontology_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_param_assign">
<code class="sig-name descname">visit_param_assign</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ParamAssign</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_param_assign" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_param_block">
<code class="sig-name descname">visit_param_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ParamBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_param_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_paren_expression">
<code class="sig-name descname">visit_paren_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ParenExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_paren_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_partial_block">
<code class="sig-name descname">visit_partial_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::PartialBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_partial_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_partial_boundary">
<code class="sig-name descname">visit_partial_boundary</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::PartialBoundary</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_partial_boundary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_partial_equation">
<code class="sig-name descname">visit_partial_equation</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::PartialEquation</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_partial_equation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_plot_block">
<code class="sig-name descname">visit_plot_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::PlotBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_plot_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_plot_declaration">
<code class="sig-name descname">visit_plot_declaration</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::PlotDeclaration</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_plot_declaration" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_plot_var">
<code class="sig-name descname">visit_plot_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::PlotVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_plot_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_pointer">
<code class="sig-name descname">visit_pointer</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Pointer</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_pointer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_pointer_var">
<code class="sig-name descname">visit_pointer_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::PointerVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_pointer_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_prime_name">
<code class="sig-name descname">visit_prime_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::PrimeName</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_prime_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_procedure_block">
<code class="sig-name descname">visit_procedure_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ProcedureBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_procedure_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_program">
<code class="sig-name descname">visit_program</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Program</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_program" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_protect_statement">
<code class="sig-name descname">visit_protect_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ProtectStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_protect_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_queue_expression_type">
<code class="sig-name descname">visit_queue_expression_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::QueueExpressionType</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_queue_expression_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_queue_statement">
<code class="sig-name descname">visit_queue_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::QueueStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_queue_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_range">
<code class="sig-name descname">visit_range</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Range</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_range" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_range_var">
<code class="sig-name descname">visit_range_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::RangeVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_range_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_react_var_name">
<code class="sig-name descname">visit_react_var_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ReactVarName</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_react_var_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_reaction_operator">
<code class="sig-name descname">visit_reaction_operator</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ReactionOperator</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_reaction_operator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_reaction_statement">
<code class="sig-name descname">visit_reaction_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ReactionStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_reaction_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_read_ion_var">
<code class="sig-name descname">visit_read_ion_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ReadIonVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_read_ion_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_reset">
<code class="sig-name descname">visit_reset</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Reset</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_section">
<code class="sig-name descname">visit_section</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Section</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_section" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_section_var">
<code class="sig-name descname">visit_section_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::SectionVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_section_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_sens">
<code class="sig-name descname">visit_sens</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Sens</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_sens" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_solution_expression">
<code class="sig-name descname">visit_solution_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::SolutionExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_solution_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_solve_block">
<code class="sig-name descname">visit_solve_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::SolveBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_solve_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_state_block">
<code class="sig-name descname">visit_state_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::StateBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_state_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_statement">
<code class="sig-name descname">visit_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Statement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_statement_block">
<code class="sig-name descname">visit_statement_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::StatementBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_statement_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_step_block">
<code class="sig-name descname">visit_step_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::StepBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_step_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_stepped">
<code class="sig-name descname">visit_stepped</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Stepped</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_stepped" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_string">
<code class="sig-name descname">visit_string</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::String</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_string" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_suffix">
<code class="sig-name descname">visit_suffix</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Suffix</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_suffix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_table_statement">
<code class="sig-name descname">visit_table_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::TableStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_table_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_terminal_block">
<code class="sig-name descname">visit_terminal_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::TerminalBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_terminal_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_thread_safe">
<code class="sig-name descname">visit_thread_safe</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ThreadSafe</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_thread_safe" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_threadsafe_var">
<code class="sig-name descname">visit_threadsafe_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ThreadsafeVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_threadsafe_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_unary_expression">
<code class="sig-name descname">visit_unary_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::UnaryExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_unary_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_unary_operator">
<code class="sig-name descname">visit_unary_operator</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::UnaryOperator</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_unary_operator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_unit">
<code class="sig-name descname">visit_unit</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Unit</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_unit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_unit_block">
<code class="sig-name descname">visit_unit_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::UnitBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_unit_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_unit_def">
<code class="sig-name descname">visit_unit_def</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::UnitDef</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_unit_def" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_unit_state">
<code class="sig-name descname">visit_unit_state</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::UnitState</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_unit_state" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_update_dt">
<code class="sig-name descname">visit_update_dt</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::UpdateDt</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_update_dt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_useion">
<code class="sig-name descname">visit_useion</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Useion</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_useion" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_valence">
<code class="sig-name descname">visit_valence</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Valence</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_valence" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_var_name">
<code class="sig-name descname">visit_var_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::VarName</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_var_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_verbatim">
<code class="sig-name descname">visit_verbatim</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Verbatim</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_verbatim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_watch">
<code class="sig-name descname">visit_watch</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Watch</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_watch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_watch_statement">
<code class="sig-name descname">visit_watch_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::WatchStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_watch_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_while_statement">
<code class="sig-name descname">visit_while_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::WhileStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_while_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_wrapped_expression">
<code class="sig-name descname">visit_wrapped_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::WrappedExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_wrapped_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.ConstVisitor.visit_write_ion_var">
<code class="sig-name descname">visit_write_ion_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstVisitor</em>, <em class="sig-param">arg0: nmodl::ast::WriteIonVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstVisitor.visit_write_ion_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.visitor.ConstantFolderVisitor">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.visitor.</code><code class="sig-name descname">ConstantFolderVisitor</code><a class="headerlink" href="#nmodl.visitor.ConstantFolderVisitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.visitor.AstVisitor</span></code></p>
<p>ConstantFolderVisitor class</p>
<dl class="method">
<dt id="nmodl.visitor.ConstantFolderVisitor.visit_program">
<code class="sig-name descname">visit_program</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.ConstantFolderVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Program</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.ConstantFolderVisitor.visit_program" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.visitor.InlineVisitor">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.visitor.</code><code class="sig-name descname">InlineVisitor</code><a class="headerlink" href="#nmodl.visitor.InlineVisitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.visitor.AstVisitor</span></code></p>
<p>InlineVisitor class</p>
<dl class="method">
<dt id="nmodl.visitor.InlineVisitor.visit_program">
<code class="sig-name descname">visit_program</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.InlineVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Program</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.InlineVisitor.visit_program" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.visitor.KineticBlockVisitor">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.visitor.</code><code class="sig-name descname">KineticBlockVisitor</code><a class="headerlink" href="#nmodl.visitor.KineticBlockVisitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.visitor.AstVisitor</span></code></p>
<p>KineticBlockVisitor class</p>
<dl class="method">
<dt id="nmodl.visitor.KineticBlockVisitor.visit_program">
<code class="sig-name descname">visit_program</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.KineticBlockVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Program</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.KineticBlockVisitor.visit_program" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.visitor.LocalVarRenameVisitor">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.visitor.</code><code class="sig-name descname">LocalVarRenameVisitor</code><a class="headerlink" href="#nmodl.visitor.LocalVarRenameVisitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.visitor.AstVisitor</span></code></p>
<p>LocalVarRenameVisitor class</p>
<dl class="method">
<dt id="nmodl.visitor.LocalVarRenameVisitor.visit_program">
<code class="sig-name descname">visit_program</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.LocalVarRenameVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Program</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.LocalVarRenameVisitor.visit_program" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.visitor.NmodlPrintVisitor">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.visitor.</code><code class="sig-name descname">NmodlPrintVisitor</code><a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.visitor.ConstVisitor</span></code></p>
<p>NmodlPrintVisitor class</p>
<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_after_block">
<code class="sig-name descname">visit_after_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::AfterBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_after_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_argument">
<code class="sig-name descname">visit_argument</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Argument</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_argument" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_assigned_block">
<code class="sig-name descname">visit_assigned_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::AssignedBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_assigned_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_assigned_definition">
<code class="sig-name descname">visit_assigned_definition</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::AssignedDefinition</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_assigned_definition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_ba_block">
<code class="sig-name descname">visit_ba_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BABlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_ba_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_ba_block_type">
<code class="sig-name descname">visit_ba_block_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BABlockType</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_ba_block_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_bbcore_pointer">
<code class="sig-name descname">visit_bbcore_pointer</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BbcorePointer</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_bbcore_pointer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_bbcore_pointer_var">
<code class="sig-name descname">visit_bbcore_pointer_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BbcorePointerVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_bbcore_pointer_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_before_block">
<code class="sig-name descname">visit_before_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BeforeBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_before_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_binary_expression">
<code class="sig-name descname">visit_binary_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BinaryExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_binary_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_binary_operator">
<code class="sig-name descname">visit_binary_operator</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BinaryOperator</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_binary_operator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_block">
<code class="sig-name descname">visit_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Block</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_block_comment">
<code class="sig-name descname">visit_block_comment</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BlockComment</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_block_comment" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_boolean">
<code class="sig-name descname">visit_boolean</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Boolean</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_boolean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_breakpoint_block">
<code class="sig-name descname">visit_breakpoint_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::BreakpointBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_breakpoint_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_compartment">
<code class="sig-name descname">visit_compartment</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Compartment</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_compartment" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_conductance_hint">
<code class="sig-name descname">visit_conductance_hint</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ConductanceHint</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_conductance_hint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_conserve">
<code class="sig-name descname">visit_conserve</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Conserve</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_conserve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_constant_block">
<code class="sig-name descname">visit_constant_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ConstantBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_constant_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_constant_statement">
<code class="sig-name descname">visit_constant_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ConstantStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_constant_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_constant_var">
<code class="sig-name descname">visit_constant_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ConstantVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_constant_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_constructor_block">
<code class="sig-name descname">visit_constructor_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ConstructorBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_constructor_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_define">
<code class="sig-name descname">visit_define</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Define</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_define" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_derivative_block">
<code class="sig-name descname">visit_derivative_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::DerivativeBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_derivative_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_derivimplicit_callback">
<code class="sig-name descname">visit_derivimplicit_callback</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::DerivimplicitCallback</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_derivimplicit_callback" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_destructor_block">
<code class="sig-name descname">visit_destructor_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::DestructorBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_destructor_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_diff_eq_expression">
<code class="sig-name descname">visit_diff_eq_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::DiffEqExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_diff_eq_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_discrete_block">
<code class="sig-name descname">visit_discrete_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::DiscreteBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_discrete_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_double">
<code class="sig-name descname">visit_double</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Double</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_double" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_double_unit">
<code class="sig-name descname">visit_double_unit</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::DoubleUnit</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_double_unit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_eigen_linear_solver_block">
<code class="sig-name descname">visit_eigen_linear_solver_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::EigenLinearSolverBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_eigen_linear_solver_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_eigen_newton_solver_block">
<code class="sig-name descname">visit_eigen_newton_solver_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::EigenNewtonSolverBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_eigen_newton_solver_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_electrode_cur_var">
<code class="sig-name descname">visit_electrode_cur_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ElectrodeCurVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_electrode_cur_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_electrode_current">
<code class="sig-name descname">visit_electrode_current</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ElectrodeCurrent</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_electrode_current" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_else_if_statement">
<code class="sig-name descname">visit_else_if_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ElseIfStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_else_if_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_else_statement">
<code class="sig-name descname">visit_else_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ElseStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_else_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_expression">
<code class="sig-name descname">visit_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Expression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_expression_statement">
<code class="sig-name descname">visit_expression_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ExpressionStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_expression_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_extern_var">
<code class="sig-name descname">visit_extern_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ExternVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_extern_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_external">
<code class="sig-name descname">visit_external</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::External</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_external" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_factor_def">
<code class="sig-name descname">visit_factor_def</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::FactorDef</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_factor_def" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_first_last_type_index">
<code class="sig-name descname">visit_first_last_type_index</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::FirstLastTypeIndex</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_first_last_type_index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_float">
<code class="sig-name descname">visit_float</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_float" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_for_all_statement">
<code class="sig-name descname">visit_for_all_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ForAllStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_for_all_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_for_netcon">
<code class="sig-name descname">visit_for_netcon</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ForNetcon</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_for_netcon" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_from_statement">
<code class="sig-name descname">visit_from_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::FromStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_from_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_function_block">
<code class="sig-name descname">visit_function_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::FunctionBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_function_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_function_call">
<code class="sig-name descname">visit_function_call</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::FunctionCall</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_function_call" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_function_table_block">
<code class="sig-name descname">visit_function_table_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::FunctionTableBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_function_table_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_global">
<code class="sig-name descname">visit_global</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Global</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_global" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_global_var">
<code class="sig-name descname">visit_global_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::GlobalVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_global_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_identifier">
<code class="sig-name descname">visit_identifier</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Identifier</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_identifier" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_if_statement">
<code class="sig-name descname">visit_if_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::IfStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_if_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_include">
<code class="sig-name descname">visit_include</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Include</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_include" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_independent_block">
<code class="sig-name descname">visit_independent_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::IndependentBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_independent_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_independent_definition">
<code class="sig-name descname">visit_independent_definition</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::IndependentDefinition</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_independent_definition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_indexed_name">
<code class="sig-name descname">visit_indexed_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::IndexedName</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_indexed_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_initial_block">
<code class="sig-name descname">visit_initial_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::InitialBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_initial_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_integer">
<code class="sig-name descname">visit_integer</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Integer</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_integer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_kinetic_block">
<code class="sig-name descname">visit_kinetic_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::KineticBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_kinetic_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_lag_statement">
<code class="sig-name descname">visit_lag_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::LagStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_lag_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_limits">
<code class="sig-name descname">visit_limits</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Limits</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_limits" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_lin_equation">
<code class="sig-name descname">visit_lin_equation</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::LinEquation</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_lin_equation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_line_comment">
<code class="sig-name descname">visit_line_comment</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::LineComment</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_line_comment" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_linear_block">
<code class="sig-name descname">visit_linear_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::LinearBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_linear_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_local_list_statement">
<code class="sig-name descname">visit_local_list_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::LocalListStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_local_list_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_local_var">
<code class="sig-name descname">visit_local_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::LocalVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_local_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_lon_difuse">
<code class="sig-name descname">visit_lon_difuse</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::LonDifuse</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_lon_difuse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_match">
<code class="sig-name descname">visit_match</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Match</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_match" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_match_block">
<code class="sig-name descname">visit_match_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::MatchBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_match_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_model">
<code class="sig-name descname">visit_model</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Model</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_mutex_lock">
<code class="sig-name descname">visit_mutex_lock</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::MutexLock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_mutex_lock" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_mutex_unlock">
<code class="sig-name descname">visit_mutex_unlock</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::MutexUnlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_mutex_unlock" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_name">
<code class="sig-name descname">visit_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Name</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_net_receive_block">
<code class="sig-name descname">visit_net_receive_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::NetReceiveBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_net_receive_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_neuron_block">
<code class="sig-name descname">visit_neuron_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::NeuronBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_neuron_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_node">
<code class="sig-name descname">visit_node</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Node</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_node" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_non_lin_equation">
<code class="sig-name descname">visit_non_lin_equation</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::NonLinEquation</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_non_lin_equation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_non_linear_block">
<code class="sig-name descname">visit_non_linear_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::NonLinearBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_non_linear_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_nonspecific">
<code class="sig-name descname">visit_nonspecific</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Nonspecific</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_nonspecific" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_nonspecific_cur_var">
<code class="sig-name descname">visit_nonspecific_cur_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::NonspecificCurVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_nonspecific_cur_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_nrn_state_block">
<code class="sig-name descname">visit_nrn_state_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::NrnStateBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_nrn_state_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_number">
<code class="sig-name descname">visit_number</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Number</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_number" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_number_range">
<code class="sig-name descname">visit_number_range</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::NumberRange</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_number_range" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_ontology_statement">
<code class="sig-name descname">visit_ontology_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::OntologyStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_ontology_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_param_assign">
<code class="sig-name descname">visit_param_assign</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ParamAssign</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_param_assign" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_param_block">
<code class="sig-name descname">visit_param_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ParamBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_param_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_paren_expression">
<code class="sig-name descname">visit_paren_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ParenExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_paren_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_partial_block">
<code class="sig-name descname">visit_partial_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::PartialBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_partial_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_partial_boundary">
<code class="sig-name descname">visit_partial_boundary</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::PartialBoundary</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_partial_boundary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_partial_equation">
<code class="sig-name descname">visit_partial_equation</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::PartialEquation</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_partial_equation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_plot_block">
<code class="sig-name descname">visit_plot_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::PlotBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_plot_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_plot_declaration">
<code class="sig-name descname">visit_plot_declaration</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::PlotDeclaration</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_plot_declaration" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_plot_var">
<code class="sig-name descname">visit_plot_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::PlotVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_plot_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_pointer">
<code class="sig-name descname">visit_pointer</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Pointer</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_pointer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_pointer_var">
<code class="sig-name descname">visit_pointer_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::PointerVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_pointer_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_prime_name">
<code class="sig-name descname">visit_prime_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::PrimeName</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_prime_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_procedure_block">
<code class="sig-name descname">visit_procedure_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ProcedureBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_procedure_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_program">
<code class="sig-name descname">visit_program</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Program</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_program" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_protect_statement">
<code class="sig-name descname">visit_protect_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ProtectStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_protect_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_queue_expression_type">
<code class="sig-name descname">visit_queue_expression_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::QueueExpressionType</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_queue_expression_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_queue_statement">
<code class="sig-name descname">visit_queue_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::QueueStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_queue_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_range">
<code class="sig-name descname">visit_range</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Range</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_range" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_range_var">
<code class="sig-name descname">visit_range_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::RangeVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_range_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_react_var_name">
<code class="sig-name descname">visit_react_var_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ReactVarName</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_react_var_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_reaction_operator">
<code class="sig-name descname">visit_reaction_operator</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ReactionOperator</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_reaction_operator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_reaction_statement">
<code class="sig-name descname">visit_reaction_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ReactionStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_reaction_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_read_ion_var">
<code class="sig-name descname">visit_read_ion_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ReadIonVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_read_ion_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_reset">
<code class="sig-name descname">visit_reset</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Reset</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_section">
<code class="sig-name descname">visit_section</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Section</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_section" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_section_var">
<code class="sig-name descname">visit_section_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::SectionVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_section_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_sens">
<code class="sig-name descname">visit_sens</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Sens</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_sens" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_solution_expression">
<code class="sig-name descname">visit_solution_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::SolutionExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_solution_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_solve_block">
<code class="sig-name descname">visit_solve_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::SolveBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_solve_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_state_block">
<code class="sig-name descname">visit_state_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::StateBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_state_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_statement">
<code class="sig-name descname">visit_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Statement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_statement_block">
<code class="sig-name descname">visit_statement_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::StatementBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_statement_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_step_block">
<code class="sig-name descname">visit_step_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::StepBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_step_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_stepped">
<code class="sig-name descname">visit_stepped</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Stepped</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_stepped" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_string">
<code class="sig-name descname">visit_string</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::String</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_string" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_suffix">
<code class="sig-name descname">visit_suffix</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Suffix</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_suffix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_table_statement">
<code class="sig-name descname">visit_table_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::TableStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_table_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_terminal_block">
<code class="sig-name descname">visit_terminal_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::TerminalBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_terminal_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_thread_safe">
<code class="sig-name descname">visit_thread_safe</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ThreadSafe</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_thread_safe" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_threadsafe_var">
<code class="sig-name descname">visit_threadsafe_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::ThreadsafeVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_threadsafe_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_unary_expression">
<code class="sig-name descname">visit_unary_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::UnaryExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_unary_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_unary_operator">
<code class="sig-name descname">visit_unary_operator</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::UnaryOperator</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_unary_operator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_unit">
<code class="sig-name descname">visit_unit</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Unit</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_unit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_unit_block">
<code class="sig-name descname">visit_unit_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::UnitBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_unit_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_unit_def">
<code class="sig-name descname">visit_unit_def</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::UnitDef</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_unit_def" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_unit_state">
<code class="sig-name descname">visit_unit_state</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::UnitState</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_unit_state" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_update_dt">
<code class="sig-name descname">visit_update_dt</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::UpdateDt</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_update_dt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_useion">
<code class="sig-name descname">visit_useion</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Useion</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_useion" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_valence">
<code class="sig-name descname">visit_valence</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Valence</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_valence" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_var_name">
<code class="sig-name descname">visit_var_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::VarName</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_var_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_verbatim">
<code class="sig-name descname">visit_verbatim</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Verbatim</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_verbatim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_watch">
<code class="sig-name descname">visit_watch</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Watch</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_watch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_watch_statement">
<code class="sig-name descname">visit_watch_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::WatchStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_watch_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_while_statement">
<code class="sig-name descname">visit_while_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::WhileStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_while_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_wrapped_expression">
<code class="sig-name descname">visit_wrapped_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::WrappedExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_wrapped_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.NmodlPrintVisitor.visit_write_ion_var">
<code class="sig-name descname">visit_write_ion_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.NmodlPrintVisitor</em>, <em class="sig-param">arg0: nmodl::ast::WriteIonVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.NmodlPrintVisitor.visit_write_ion_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.visitor.SympyConductanceVisitor">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.visitor.</code><code class="sig-name descname">SympyConductanceVisitor</code><a class="headerlink" href="#nmodl.visitor.SympyConductanceVisitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.visitor.AstVisitor</span></code></p>
<p>SympyConductanceVisitor class</p>
<dl class="method">
<dt id="nmodl.visitor.SympyConductanceVisitor.visit_program">
<code class="sig-name descname">visit_program</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.SympyConductanceVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Program</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.SympyConductanceVisitor.visit_program" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.visitor.SympySolverVisitor">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.visitor.</code><code class="sig-name descname">SympySolverVisitor</code><a class="headerlink" href="#nmodl.visitor.SympySolverVisitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">nmodl._nmodl.visitor.AstVisitor</span></code></p>
<p>SympySolverVisitor class</p>
<dl class="method">
<dt id="nmodl.visitor.SympySolverVisitor.visit_program">
<code class="sig-name descname">visit_program</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.SympySolverVisitor</em>, <em class="sig-param">arg0: nmodl::ast::Program</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.SympySolverVisitor.visit_program" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nmodl.visitor.Visitor">
<em class="property">class </em><code class="sig-prename descclassname">nmodl.visitor.</code><code class="sig-name descname">Visitor</code><a class="headerlink" href="#nmodl.visitor.Visitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_builtins.pybind11_object</span></code></p>
<p>Base Visitor class</p>
<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_after_block">
<code class="sig-name descname">visit_after_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::AfterBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_after_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_argument">
<code class="sig-name descname">visit_argument</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Argument</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_argument" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_assigned_block">
<code class="sig-name descname">visit_assigned_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::AssignedBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_assigned_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_assigned_definition">
<code class="sig-name descname">visit_assigned_definition</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::AssignedDefinition</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_assigned_definition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_ba_block">
<code class="sig-name descname">visit_ba_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::BABlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_ba_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_ba_block_type">
<code class="sig-name descname">visit_ba_block_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::BABlockType</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_ba_block_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_bbcore_pointer">
<code class="sig-name descname">visit_bbcore_pointer</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::BbcorePointer</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_bbcore_pointer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_bbcore_pointer_var">
<code class="sig-name descname">visit_bbcore_pointer_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::BbcorePointerVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_bbcore_pointer_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_before_block">
<code class="sig-name descname">visit_before_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::BeforeBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_before_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_binary_expression">
<code class="sig-name descname">visit_binary_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::BinaryExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_binary_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_binary_operator">
<code class="sig-name descname">visit_binary_operator</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::BinaryOperator</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_binary_operator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_block">
<code class="sig-name descname">visit_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Block</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_block_comment">
<code class="sig-name descname">visit_block_comment</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::BlockComment</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_block_comment" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_boolean">
<code class="sig-name descname">visit_boolean</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Boolean</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_boolean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_breakpoint_block">
<code class="sig-name descname">visit_breakpoint_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::BreakpointBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_breakpoint_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_compartment">
<code class="sig-name descname">visit_compartment</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Compartment</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_compartment" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_conductance_hint">
<code class="sig-name descname">visit_conductance_hint</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::ConductanceHint</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_conductance_hint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_conserve">
<code class="sig-name descname">visit_conserve</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Conserve</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_conserve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_constant_block">
<code class="sig-name descname">visit_constant_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::ConstantBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_constant_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_constant_statement">
<code class="sig-name descname">visit_constant_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::ConstantStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_constant_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_constant_var">
<code class="sig-name descname">visit_constant_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::ConstantVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_constant_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_constructor_block">
<code class="sig-name descname">visit_constructor_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::ConstructorBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_constructor_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_define">
<code class="sig-name descname">visit_define</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Define</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_define" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_derivative_block">
<code class="sig-name descname">visit_derivative_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::DerivativeBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_derivative_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_derivimplicit_callback">
<code class="sig-name descname">visit_derivimplicit_callback</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::DerivimplicitCallback</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_derivimplicit_callback" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_destructor_block">
<code class="sig-name descname">visit_destructor_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::DestructorBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_destructor_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_diff_eq_expression">
<code class="sig-name descname">visit_diff_eq_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::DiffEqExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_diff_eq_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_discrete_block">
<code class="sig-name descname">visit_discrete_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::DiscreteBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_discrete_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_double">
<code class="sig-name descname">visit_double</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Double</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_double" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_double_unit">
<code class="sig-name descname">visit_double_unit</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::DoubleUnit</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_double_unit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_eigen_linear_solver_block">
<code class="sig-name descname">visit_eigen_linear_solver_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::EigenLinearSolverBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_eigen_linear_solver_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_eigen_newton_solver_block">
<code class="sig-name descname">visit_eigen_newton_solver_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::EigenNewtonSolverBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_eigen_newton_solver_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_electrode_cur_var">
<code class="sig-name descname">visit_electrode_cur_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::ElectrodeCurVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_electrode_cur_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_electrode_current">
<code class="sig-name descname">visit_electrode_current</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::ElectrodeCurrent</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_electrode_current" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_else_if_statement">
<code class="sig-name descname">visit_else_if_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::ElseIfStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_else_if_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_else_statement">
<code class="sig-name descname">visit_else_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::ElseStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_else_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_expression">
<code class="sig-name descname">visit_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Expression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_expression_statement">
<code class="sig-name descname">visit_expression_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::ExpressionStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_expression_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_extern_var">
<code class="sig-name descname">visit_extern_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::ExternVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_extern_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_external">
<code class="sig-name descname">visit_external</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::External</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_external" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_factor_def">
<code class="sig-name descname">visit_factor_def</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::FactorDef</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_factor_def" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_first_last_type_index">
<code class="sig-name descname">visit_first_last_type_index</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::FirstLastTypeIndex</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_first_last_type_index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_float">
<code class="sig-name descname">visit_float</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_float" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_for_all_statement">
<code class="sig-name descname">visit_for_all_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::ForAllStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_for_all_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_for_netcon">
<code class="sig-name descname">visit_for_netcon</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::ForNetcon</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_for_netcon" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_from_statement">
<code class="sig-name descname">visit_from_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::FromStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_from_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_function_block">
<code class="sig-name descname">visit_function_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::FunctionBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_function_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_function_call">
<code class="sig-name descname">visit_function_call</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::FunctionCall</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_function_call" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_function_table_block">
<code class="sig-name descname">visit_function_table_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::FunctionTableBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_function_table_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_global">
<code class="sig-name descname">visit_global</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Global</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_global" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_global_var">
<code class="sig-name descname">visit_global_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::GlobalVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_global_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_identifier">
<code class="sig-name descname">visit_identifier</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Identifier</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_identifier" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_if_statement">
<code class="sig-name descname">visit_if_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::IfStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_if_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_include">
<code class="sig-name descname">visit_include</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Include</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_include" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_independent_block">
<code class="sig-name descname">visit_independent_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::IndependentBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_independent_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_independent_definition">
<code class="sig-name descname">visit_independent_definition</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::IndependentDefinition</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_independent_definition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_indexed_name">
<code class="sig-name descname">visit_indexed_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::IndexedName</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_indexed_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_initial_block">
<code class="sig-name descname">visit_initial_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::InitialBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_initial_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_integer">
<code class="sig-name descname">visit_integer</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Integer</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_integer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_kinetic_block">
<code class="sig-name descname">visit_kinetic_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::KineticBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_kinetic_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_lag_statement">
<code class="sig-name descname">visit_lag_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::LagStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_lag_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_limits">
<code class="sig-name descname">visit_limits</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Limits</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_limits" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_lin_equation">
<code class="sig-name descname">visit_lin_equation</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::LinEquation</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_lin_equation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_line_comment">
<code class="sig-name descname">visit_line_comment</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::LineComment</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_line_comment" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_linear_block">
<code class="sig-name descname">visit_linear_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::LinearBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_linear_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_local_list_statement">
<code class="sig-name descname">visit_local_list_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::LocalListStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_local_list_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_local_var">
<code class="sig-name descname">visit_local_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::LocalVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_local_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_lon_difuse">
<code class="sig-name descname">visit_lon_difuse</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::LonDifuse</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_lon_difuse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_match">
<code class="sig-name descname">visit_match</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Match</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_match" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_match_block">
<code class="sig-name descname">visit_match_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::MatchBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_match_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_model">
<code class="sig-name descname">visit_model</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Model</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_mutex_lock">
<code class="sig-name descname">visit_mutex_lock</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::MutexLock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_mutex_lock" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_mutex_unlock">
<code class="sig-name descname">visit_mutex_unlock</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::MutexUnlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_mutex_unlock" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_name">
<code class="sig-name descname">visit_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Name</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_net_receive_block">
<code class="sig-name descname">visit_net_receive_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::NetReceiveBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_net_receive_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_neuron_block">
<code class="sig-name descname">visit_neuron_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::NeuronBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_neuron_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_node">
<code class="sig-name descname">visit_node</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Node</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_node" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_non_lin_equation">
<code class="sig-name descname">visit_non_lin_equation</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::NonLinEquation</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_non_lin_equation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_non_linear_block">
<code class="sig-name descname">visit_non_linear_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::NonLinearBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_non_linear_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_nonspecific">
<code class="sig-name descname">visit_nonspecific</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Nonspecific</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_nonspecific" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_nonspecific_cur_var">
<code class="sig-name descname">visit_nonspecific_cur_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::NonspecificCurVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_nonspecific_cur_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_nrn_state_block">
<code class="sig-name descname">visit_nrn_state_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::NrnStateBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_nrn_state_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_number">
<code class="sig-name descname">visit_number</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Number</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_number" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_number_range">
<code class="sig-name descname">visit_number_range</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::NumberRange</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_number_range" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_ontology_statement">
<code class="sig-name descname">visit_ontology_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::OntologyStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_ontology_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_param_assign">
<code class="sig-name descname">visit_param_assign</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::ParamAssign</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_param_assign" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_param_block">
<code class="sig-name descname">visit_param_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::ParamBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_param_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_paren_expression">
<code class="sig-name descname">visit_paren_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::ParenExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_paren_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_partial_block">
<code class="sig-name descname">visit_partial_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::PartialBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_partial_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_partial_boundary">
<code class="sig-name descname">visit_partial_boundary</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::PartialBoundary</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_partial_boundary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_partial_equation">
<code class="sig-name descname">visit_partial_equation</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::PartialEquation</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_partial_equation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_plot_block">
<code class="sig-name descname">visit_plot_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::PlotBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_plot_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_plot_declaration">
<code class="sig-name descname">visit_plot_declaration</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::PlotDeclaration</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_plot_declaration" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_plot_var">
<code class="sig-name descname">visit_plot_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::PlotVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_plot_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_pointer">
<code class="sig-name descname">visit_pointer</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Pointer</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_pointer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_pointer_var">
<code class="sig-name descname">visit_pointer_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::PointerVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_pointer_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_prime_name">
<code class="sig-name descname">visit_prime_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::PrimeName</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_prime_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_procedure_block">
<code class="sig-name descname">visit_procedure_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::ProcedureBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_procedure_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_program">
<code class="sig-name descname">visit_program</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Program</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_program" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_protect_statement">
<code class="sig-name descname">visit_protect_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::ProtectStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_protect_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_queue_expression_type">
<code class="sig-name descname">visit_queue_expression_type</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::QueueExpressionType</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_queue_expression_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_queue_statement">
<code class="sig-name descname">visit_queue_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::QueueStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_queue_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_range">
<code class="sig-name descname">visit_range</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Range</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_range" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_range_var">
<code class="sig-name descname">visit_range_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::RangeVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_range_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_react_var_name">
<code class="sig-name descname">visit_react_var_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::ReactVarName</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_react_var_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_reaction_operator">
<code class="sig-name descname">visit_reaction_operator</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::ReactionOperator</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_reaction_operator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_reaction_statement">
<code class="sig-name descname">visit_reaction_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::ReactionStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_reaction_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_read_ion_var">
<code class="sig-name descname">visit_read_ion_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::ReadIonVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_read_ion_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_reset">
<code class="sig-name descname">visit_reset</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Reset</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_section">
<code class="sig-name descname">visit_section</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Section</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_section" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_section_var">
<code class="sig-name descname">visit_section_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::SectionVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_section_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_sens">
<code class="sig-name descname">visit_sens</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Sens</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_sens" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_solution_expression">
<code class="sig-name descname">visit_solution_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::SolutionExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_solution_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_solve_block">
<code class="sig-name descname">visit_solve_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::SolveBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_solve_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_state_block">
<code class="sig-name descname">visit_state_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::StateBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_state_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_statement">
<code class="sig-name descname">visit_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Statement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_statement_block">
<code class="sig-name descname">visit_statement_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::StatementBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_statement_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_step_block">
<code class="sig-name descname">visit_step_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::StepBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_step_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_stepped">
<code class="sig-name descname">visit_stepped</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Stepped</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_stepped" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_string">
<code class="sig-name descname">visit_string</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::String</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_string" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_suffix">
<code class="sig-name descname">visit_suffix</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Suffix</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_suffix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_table_statement">
<code class="sig-name descname">visit_table_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::TableStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_table_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_terminal_block">
<code class="sig-name descname">visit_terminal_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::TerminalBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_terminal_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_thread_safe">
<code class="sig-name descname">visit_thread_safe</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::ThreadSafe</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_thread_safe" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_threadsafe_var">
<code class="sig-name descname">visit_threadsafe_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::ThreadsafeVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_threadsafe_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_unary_expression">
<code class="sig-name descname">visit_unary_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::UnaryExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_unary_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_unary_operator">
<code class="sig-name descname">visit_unary_operator</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::UnaryOperator</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_unary_operator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_unit">
<code class="sig-name descname">visit_unit</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Unit</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_unit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_unit_block">
<code class="sig-name descname">visit_unit_block</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::UnitBlock</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_unit_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_unit_def">
<code class="sig-name descname">visit_unit_def</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::UnitDef</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_unit_def" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_unit_state">
<code class="sig-name descname">visit_unit_state</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::UnitState</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_unit_state" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_update_dt">
<code class="sig-name descname">visit_update_dt</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::UpdateDt</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_update_dt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_useion">
<code class="sig-name descname">visit_useion</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Useion</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_useion" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_valence">
<code class="sig-name descname">visit_valence</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Valence</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_valence" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_var_name">
<code class="sig-name descname">visit_var_name</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::VarName</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_var_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_verbatim">
<code class="sig-name descname">visit_verbatim</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Verbatim</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_verbatim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_watch">
<code class="sig-name descname">visit_watch</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::Watch</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_watch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_watch_statement">
<code class="sig-name descname">visit_watch_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::WatchStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_watch_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_while_statement">
<code class="sig-name descname">visit_while_statement</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::WhileStatement</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_while_statement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_wrapped_expression">
<code class="sig-name descname">visit_wrapped_expression</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::WrappedExpression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_wrapped_expression" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nmodl.visitor.Visitor.visit_write_ion_var">
<code class="sig-name descname">visit_write_ion_var</code><span class="sig-paren">(</span><em class="sig-param">self: nmodl._nmodl.visitor.Visitor</em>, <em class="sig-param">arg0: nmodl::ast::WriteIonVar</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#nmodl.visitor.Visitor.visit_write_ion_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="modules.html" class="btn btn-neutral float-left" title="Python package" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="doxygen.html" class="btn btn-neutral float-right" title="C++ API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, BlueBrain HPC team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>